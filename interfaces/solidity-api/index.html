<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://rankify.it/interfaces/solidity-api/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Solidity API - Rankify Documentation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Solidity API";
        var mkdocs_page_input_path = "interfaces/solidity-api.md";
        var mkdocs_page_url = "/interfaces/solidity-api/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/solidity.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/bash.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Rankify Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Welcome</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../..">Getting started</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../governance/">Governance</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../tokens/">Token types</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Architecture</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../architecture/">Smart contract infrastructure</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../architecture/applications/">Applications</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../architecture/specifications/">Specifications</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">interfaces</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="../contracts/*">None</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../js/">JavaScript SDK</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Support</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../support/">Community channels</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../support/faq/">Frequently asked questions</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Rankify Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Solidity API</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/rankify-it/edit/master/docs/interfaces/solidity-api.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="solidity-api">Solidity API<a class="headerlink" href="#solidity-api" title="Permanent link">#</a></h1>
<h2 id="compositeerc1155">CompositeERC1155<a class="headerlink" href="#compositeerc1155" title="Permanent link">#</a></h2>
<p><em>An abstract contract that extends LockableERC1155 and provides functionality for composite ERC1155 tokens.
Composite tokens can be "composed" from multiple underlying assets, which however do not change their owner
and in contrast to that use LockableERC1155 standard, which allows to read locked asset BalanceOf, OwnerOf methods correctly</em></p>
<h3 id="constructor">constructor<a class="headerlink" href="#constructor" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">constructor(string uri_, address[] dimensionTokens, uint256[] tokenWeights) internal</code></pre>
<h3 id="_mint">_mint<a class="headerlink" href="#_mint" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _mint(address to, uint256 tokenId, uint256 value, bytes data) internal virtual</code></pre>
<h3 id="_burn">_burn<a class="headerlink" href="#_burn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _burn(address from, uint256 id, uint256 amount) internal</code></pre>
<p>_Destroys <code>amount</code> tokens of token type <code>id</code> from <code>from</code></p>
<p>Emits a {TransferSingle} event.</p>
<p>Requirements:</p>
<ul>
<li><code>from</code> cannot be the zero address.</li>
<li><code>from</code> must have at least <code>amount</code> tokens of token type <code>id</code>._</li>
</ul>
<h3 id="decompose">decompose<a class="headerlink" href="#decompose" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function decompose(address from, uint256 id, uint256 amount) public virtual</code></pre>
<p><em>Decomposes a composite ERC1155 token into its individual components.
This function unlocks the specified amount of the composite token from each dimension,
and then burns the specified amount of the composite token from the caller's balance.</em></p>
<h4 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td>address</td>
<td>The address from which the composite token is being decomposed.</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>The ID of the composite token being decomposed.</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of the composite token to decompose.</td>
</tr>
</tbody>
</table>
<h3 id="burn">burn<a class="headerlink" href="#burn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function burn(address account, uint256 id, uint256 value) public virtual</code></pre>
<p>_Burns a specified amount of tokens from the given account.
This will burn all underlying (composite) assets</p>
<p>Requirements:
- <code>account</code> must be the token owner or an approved operator.
- <code>id</code> and <code>value</code> must be valid token ID and amount to burn.
- All underlying "composite" assets implement burn as well_</p>
<h4 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address of the token owner.</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>The ID of the token to burn.</td>
</tr>
<tr>
<td>value</td>
<td>uint256</td>
<td>The amount of tokens to burn.</td>
</tr>
</tbody>
</table>
<h3 id="getcomponents">getComponents<a class="headerlink" href="#getcomponents" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getComponents() public virtual returns (address[], uint256[])</code></pre>
<p><em>Retrieves the components of the CompositeERC1155 contract.</em></p>
<h4 id="return-values">Return Values<a class="headerlink" href="#return-values" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>address[]</td>
<td>An array of component addresses and an array of component weights.</td>
</tr>
<tr>
<td>[1]</td>
<td>uint256[]</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="diamondreentrancyguard">DiamondReentrancyGuard<a class="headerlink" href="#diamondreentrancyguard" title="Permanent link">#</a></h2>
<h3 id="nonreentrant">nonReentrant<a class="headerlink" href="#nonreentrant" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">modifier nonReentrant()</code></pre>
<h2 id="insufficient">insufficient<a class="headerlink" href="#insufficient" title="Permanent link">#</a></h2>
<pre class="highlight"><code class="language-solidity">error insufficient(uint256 id, uint256 balance, uint256 required)</code></pre>
<h2 id="lockableerc1155">LockableERC1155<a class="headerlink" href="#lockableerc1155" title="Permanent link">#</a></h2>
<p><em>This is an abstract contract that extends the ERC1155 token contract and implements the ILockableERC1155 interface.
     It provides functionality to lock and unlock token amounts for specific accounts and IDs.</em></p>
<h3 id="lockedamounts">lockedAmounts<a class="headerlink" href="#lockedamounts" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">mapping(address =&gt; mapping(uint256 =&gt; uint256)) lockedAmounts</code></pre>
<h3 id="lock">lock<a class="headerlink" href="#lock" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function lock(address account, uint256 id, uint256 amount) public virtual</code></pre>
<p><em>Locks a specified amount of tokens for a given account and token ID.
If the account does not have enough balance to lock the specified amount,
the function will revert with an "insufficient" error message.
Emits a <code>TokensLocked</code> event after successfully locking the tokens.</em></p>
<h4 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address of the account to lock tokens for.</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>The ID of the token to lock.</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens to lock.</td>
</tr>
</tbody>
</table>
<h3 id="unlock">unlock<a class="headerlink" href="#unlock" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function unlock(address account, uint256 id, uint256 amount) public virtual</code></pre>
<p><em>Unlocks a specified amount of tokens for a given account and token ID.
If the locked amount is less than the specified amount, it reverts with an "insufficient" error message.
Emits a <code>TokensUnlocked</code> event after unlocking the tokens.</em></p>
<h4 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address of the account to unlock tokens for.</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>The ID of the token to unlock.</td>
</tr>
<tr>
<td>amount</td>
<td>uint256</td>
<td>The amount of tokens to unlock.</td>
</tr>
</tbody>
</table>
<h3 id="unlockedbalanceof">unlockedBalanceOf<a class="headerlink" href="#unlockedbalanceof" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function unlockedBalanceOf(address account, uint256 id) public view returns (uint256)</code></pre>
<p><em>Returns the unlocked balance of a specific ERC1155 token for an account.
The unlocked balance is calculated by subtracting the locked amount from the total balance.</em></p>
<h4 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>account</td>
<td>address</td>
<td>The address of the account.</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>The ID of the ERC1155 token.</td>
</tr>
</tbody>
</table>
<h4 id="return-values_1">Return Values<a class="headerlink" href="#return-values_1" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>The unlocked balance of the ERC1155 token for the account.</td>
</tr>
</tbody>
</table>
<h3 id="_beforetokentransfer">_beforeTokenTransfer<a class="headerlink" href="#_beforetokentransfer" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _beforeTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal virtual</code></pre>
<p><em>Hook function that is called before any token transfer.
It checks if the transfer is allowed based on the locked amounts of the tokens.
If the transfer is not allowed, it reverts with an error message.</em></p>
<h4 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>operator</td>
<td>address</td>
<td>The address performing the token transfer.</td>
</tr>
<tr>
<td>from</td>
<td>address</td>
<td>The address from which the tokens are being transferred.</td>
</tr>
<tr>
<td>to</td>
<td>address</td>
<td>The address to which the tokens are being transferred.</td>
</tr>
<tr>
<td>ids</td>
<td>uint256[]</td>
<td>An array of token IDs being transferred.</td>
</tr>
<tr>
<td>amounts</td>
<td>uint256[]</td>
<td>An array of token amounts being transferred.</td>
</tr>
<tr>
<td>data</td>
<td>bytes</td>
<td>Additional data attached to the transfer.</td>
</tr>
</tbody>
</table>
<h2 id="eip712">EIP712<a class="headerlink" href="#eip712" title="Permanent link">#</a></h2>
<p>_https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.</p>
<p>The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,
thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding
they need in their contracts using a combination of <code>abi.encode</code> and <code>keccak256</code>.</p>
<p>This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding
scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
({_hashTypedDataV4}).</p>
<p>The implementation of the domain separator was designed to be as efficient as possible while still properly updating
the chain id to protect against replay attacks on an eventual fork of the chain.</p>
<p>NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
https://docs.metamask.io/guide/signing-data.html[<code>eth_signTypedDataV4</code> in MetaMask].</p>
<p>_Available since v3.4.__</p>
<h3 id="constructor_1">constructor<a class="headerlink" href="#constructor_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">constructor() internal</code></pre>
<p>_Initializes the domain separator and parameter caches.</p>
<p>The meaning of <code>name</code> and <code>version</code> is specified in
https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:</p>
<ul>
<li><code>name</code>: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.</li>
<li><code>version</code>: the current major version of the signing domain.</li>
</ul>
<p>NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
contract upgrade]._</p>
<h3 id="_domainseparatorv4">_domainSeparatorV4<a class="headerlink" href="#_domainseparatorv4" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _domainSeparatorV4() internal view returns (bytes32)</code></pre>
<p><em>Returns the domain separator for the current chain.</em></p>
<h3 id="_hashtypeddatav4">_hashTypedDataV4<a class="headerlink" href="#_hashtypeddatav4" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32)</code></pre>
<p>_Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
function returns the hash of the fully encoded EIP712 message for this domain.</p>
<p>This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:</p>
<pre class="highlight"><code class="language-solidity">bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
    keccak256("Mail(address to,string contents)"),
    mailTo,
    keccak256(bytes(mailContents))
)));
address signer = ECDSA.recover(digest, signature);
```_

## DNSFacet

### _isValidSignature

```solidity
function _isValidSignature(bytes message, bytes signature, address account) internal view returns (bool)</code></pre>
<h3 id="initializedomain">initializeDomain<a class="headerlink" href="#initializedomain" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) public</code></pre>
<p>_Initializes new LibMultipass.Domain and configures it's parameters</p>
<p>Requirements:
 registrar is not zero
 domainName is not empty
 domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names
 domainName does not exist yet
 onlyOwner
 referrerReward+referralDiscount cannot be larger than fee
 @param registrar address of registrar
 @param freeRegistrationsNumber number of registrations free of fee
 @param fee fee in base currency of network
 @param domainName name of LibMultipass.Domain
 @param referrerReward referral fee share in base currency of network
 @param referralDiscount referral discount in base currency of network</p>
<p>Emits an {InitializedDomain} event._</p>
<h3 id="activatedomain">activateDomain<a class="headerlink" href="#activatedomain" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function activateDomain(bytes32 domainName) public</code></pre>
<p>_Activates LibMultipass.Domain name</p>
<p>Requirements:
 msg.sender is Owner</p>
<p>Emits an {DomainActivated} event._</p>
<h3 id="deactivatedomain">deactivateDomain<a class="headerlink" href="#deactivatedomain" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function deactivateDomain(bytes32 domainName) public</code></pre>
<p>_Deactivates LibMultipass.Domain name</p>
<p>Deactivated LibMultipass.Domain cannot mutate names and will return zeros</p>
<p>Requirements:
 msg.sender is Owner OR registrar</p>
<p>Emits an {DomainDeactivated} event._</p>
<h3 id="changefee">changeFee<a class="headerlink" href="#changefee" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function changeFee(bytes32 domainName, uint256 fee) public</code></pre>
<p>_Changes registrar address</p>
<p>Requirements:
 msg.sender is Owner</p>
<p>Emits an {DomainFeeChanged} event._</p>
<h3 id="changeregistrar">changeRegistrar<a class="headerlink" href="#changeregistrar" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function changeRegistrar(bytes32 domainName, address newRegistrar) public</code></pre>
<p>_Changes registrar address</p>
<p>Requirements:
 msg.sender is Owner</p>
<p>Emits an {RegistrarChangeRequested} event._</p>
<h3 id="deletename">deleteName<a class="headerlink" href="#deletename" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function deleteName(struct LibMultipass.NameQuery query) public</code></pre>
<p>_deletes name</p>
<p>Requirements:
 msg.sender is Owner</p>
<p>Emits an {DomainTTLChangeRequested} event._</p>
<h3 id="changereferralprogram">changeReferralProgram<a class="headerlink" href="#changereferralprogram" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function changeReferralProgram(uint256 referrerReward, uint256 freeRegistrations, uint256 referralDiscount, bytes32 domainName) public</code></pre>
<h3 id="resolverecord">resolveRecord<a class="headerlink" href="#resolverecord" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function resolveRecord(struct LibMultipass.NameQuery query) public view returns (bool, struct LibMultipass.Record)</code></pre>
<p><em>resolves LibMultipass.Record of name query in to status and identity</em></p>
<h3 id="register">register<a class="headerlink" href="#register" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) public payable</code></pre>
<p>_registers new name under LibMultipass.Domain</p>
<p>Requirements:
 all arguments must be set
 domainName must be active
resolveRecord for given arguments should return no LibMultipass.Record</p>
<p>Emits an {registered} event._</p>
<h3 id="getmodifyprice">getModifyPrice<a class="headerlink" href="#getmodifyprice" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getModifyPrice(struct LibMultipass.NameQuery query) public view returns (uint256)</code></pre>
<h3 id="modifyusername">modifyUserName<a class="headerlink" href="#modifyusername" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) public payable</code></pre>
<p>_modifies exsisting LibMultipass.Record</p>
<p>Requirements:
resolveRecord for given arguments should return valid LibMultipass.Record
LibMultipass.Domain must be active
newAddress and newName should be set and be unique in current LibMultipass.Domain_</p>
<h4 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>domainName</td>
<td>bytes32</td>
<td>LibMultipass.Domain</td>
</tr>
<tr>
<td>query</td>
<td>struct LibMultipass.NameQuery</td>
<td></td>
</tr>
<tr>
<td>newName</td>
<td>bytes32</td>
<td>new name  Emits an {Modified} event.</td>
</tr>
<tr>
<td>registrarSignature</td>
<td>bytes</td>
<td></td>
</tr>
<tr>
<td>signatureDeadline</td>
<td>uint256</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="getbalance">getBalance<a class="headerlink" href="#getbalance" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getBalance() external view returns (uint256)</code></pre>
<p><em>returns balance of this contract</em></p>
<h3 id="getdomainstate">getDomainState<a class="headerlink" href="#getdomainstate" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain)</code></pre>
<p><em>returns LibMultipass.Domain state variables</em></p>
<h4 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>domainName</td>
<td>bytes32</td>
<td>name of the LibMultipass.Domain</td>
</tr>
</tbody>
</table>
<h4 id="return-values_2">Return Values<a class="headerlink" href="#return-values_2" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>struct LibMultipass.Domain</td>
<td>(name,       fee,       freeRegistrationsNumber,        referrerReward,        referralDiscount,        isActive,        registrar,        ttl,         registerSize)</td>
</tr>
</tbody>
</table>
<h3 id="getdomainstatebyidx">getDomainStateByIdx<a class="headerlink" href="#getdomainstatebyidx" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getDomainStateByIdx(uint256 index) external view returns (struct LibMultipass.Domain)</code></pre>
<h3 id="getcontractstate">getContractState<a class="headerlink" href="#getcontractstate" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getContractState() external view returns (uint256)</code></pre>
<p><em>returns contract state variables</em></p>
<h4 id="return-values_3">Return Values<a class="headerlink" href="#return-values_3" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>(s_numDomains)</td>
</tr>
</tbody>
</table>
<h3 id="withrawfunds">withrawFunds<a class="headerlink" href="#withrawfunds" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function withrawFunds(address to) public</code></pre>
<p>_Withraws funds stored in smart contract</p>
<p>Requirements:
 onlyOwner</p>
<p>Emits an {fundsWithdawn} event._</p>
<h2 id="eip712inspectorfacet">EIP712InspectorFacet<a class="headerlink" href="#eip712inspectorfacet" title="Permanent link">#</a></h2>
<h3 id="inspecteip712hashes">inspectEIP712Hashes<a class="headerlink" href="#inspecteip712hashes" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function inspectEIP712Hashes() public view returns (bytes32 _CACHED_DOMAIN_SEPARATOR, uint256 _CACHED_CHAIN_ID, address _CACHED_THIS, bytes32 _HASHED_NAME, bytes32 _HASHED_VERSION, bytes32 _TYPE_HASH)</code></pre>
<h3 id="currentchainid">currentChainId<a class="headerlink" href="#currentchainid" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function currentChainId() public view returns (uint256)</code></pre>
<h2 id="rankifyinstancegamemastersfacet">RankifyInstanceGameMastersFacet<a class="headerlink" href="#rankifyinstancegamemastersfacet" title="Permanent link">#</a></h2>
<h3 id="overtime">OverTime<a class="headerlink" href="#overtime" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event OverTime(uint256 gameId)</code></pre>
<h3 id="lastturn">LastTurn<a class="headerlink" href="#lastturn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event LastTurn(uint256 gameId)</code></pre>
<h3 id="proposalscore">ProposalScore<a class="headerlink" href="#proposalscore" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event ProposalScore(uint256 gameId, uint256 turn, string proposalHash, string proposal, uint256 score)</code></pre>
<h3 id="turnended">TurnEnded<a class="headerlink" href="#turnended" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event TurnEnded(uint256 gameId, uint256 turn, address[] players, uint256[] scores, string[] newProposals, uint256[] proposerIndicies, uint256[][] votes)</code></pre>
<h3 id="gameover">GameOver<a class="headerlink" href="#gameover" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event GameOver(uint256 gameId, address[] players, uint256[] scores)</code></pre>
<h3 id="proposalsubmitted">ProposalSubmitted<a class="headerlink" href="#proposalsubmitted" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event ProposalSubmitted(uint256 gameId, uint256 turn, address proposer, bytes32 commitmentHash, string proposalEncryptedByGM)</code></pre>
<h3 id="proposalparams">ProposalParams<a class="headerlink" href="#proposalparams" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct ProposalParams {
  uint256 gameId;
  string encryptedProposal;
  bytes32 commitmentHash;
  address proposer;
}</code></pre>
<h3 id="votesubmitted">VoteSubmitted<a class="headerlink" href="#votesubmitted" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event VoteSubmitted(uint256 gameId, uint256 turn, address player, string votesHidden)</code></pre>
<h3 id="submitvote">submitVote<a class="headerlink" href="#submitvote" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function submitVote(uint256 gameId, string encryptedVotes, address voter) public</code></pre>
<p>_Submits a vote for a game. <code>gameId</code> is the ID of the game. <code>encryptedVotes</code> is the encrypted votes. <code>voter</code> is the address of the voter.</p>
<p>Emits a <em>VoteSubmitted</em> event.</p>
<p>Requirements:</p>
<ul>
<li>The caller must be a game master of the game with <code>gameId</code>.</li>
<li>The game with <code>gameId</code> must exist.</li>
<li>The game with <code>gameId</code> must have started.</li>
<li>The game with <code>gameId</code> must not be over.</li>
<li><code>voter</code> must be in the game with <code>gameId</code>.</li>
<li>The current turn of the game with <code>gameId</code> must be greater than 1._</li>
</ul>
<h3 id="submitproposal">submitProposal<a class="headerlink" href="#submitproposal" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function submitProposal(struct RankifyInstanceGameMastersFacet.ProposalParams proposalData) public</code></pre>
<p>_Submits a proposal for a game. <code>proposalData</code> is the proposal data.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>proposalData.gameId</code> must exist.</li>
<li>The caller must be a game master of the game with <code>proposalData.gameId</code>._</li>
</ul>
<h3 id="endturn">endTurn<a class="headerlink" href="#endturn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function endTurn(uint256 gameId, uint256[][] votes, string[] newProposals, uint256[] proposerIndicies) public</code></pre>
<p>_Ends the current turn of a game with the provided game ID. <code>gameId</code> is the ID of the game. <code>votes</code> is the array of votes.
 <code>newProposals</code> is the array of new proposals for the upcoming voting round.
 <code>proposerIndicies</code> is the array of indices of the proposers in the previous voting round.</p>
<p>emits a <em>ProposalScore</em> event for each player if the turn is not the first.
emits a <em>TurnEnded</em> event.</p>
<p>Modifies:</p>
<ul>
<li>Calls the <code>_nextTurn</code> function with <code>gameId</code> and <code>newProposals</code>.</li>
<li>Resets the number of commitments of the game with <code>gameId</code> to 0.</li>
<li>Resets the proposal commitment hash and ongoing proposal of each player in the game with <code>gameId</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be a game master of the game with <code>gameId</code>.</li>
<li>The game with <code>gameId</code> must have started.</li>
<li>The game with <code>gameId</code> must not be over.</li>
<li>newProposals array MUST be sorted randomly to ensure privacy
votes and proposerIndicies MUST correspond to players array from game.getPlayers()_</li>
</ul>
<h2 id="zerovalue">ZeroValue<a class="headerlink" href="#zerovalue" title="Permanent link">#</a></h2>
<pre class="highlight"><code class="language-solidity">error ZeroValue()</code></pre>
<h2 id="wrongaddress">WrongAddress<a class="headerlink" href="#wrongaddress" title="Permanent link">#</a></h2>
<pre class="highlight"><code class="language-solidity">error WrongAddress()</code></pre>
<h2 id="outofbounds">OutOfBounds<a class="headerlink" href="#outofbounds" title="Permanent link">#</a></h2>
<pre class="highlight"><code class="language-solidity">error OutOfBounds()</code></pre>
<h2 id="rankifyinstancegameownersfacet">RankifyInstanceGameOwnersFacet<a class="headerlink" href="#rankifyinstancegameownersfacet" title="Permanent link">#</a></h2>
<h3 id="rinstancestorage">RInstanceStorage<a class="headerlink" href="#rinstancestorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog)</code></pre>
<h3 id="setgameprice">setGamePrice<a class="headerlink" href="#setgameprice" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setGamePrice(uint256 newPrice) external</code></pre>
<p>_Sets the game price. <code>newPrice</code> is the new game price.</p>
<p>Modifies:</p>
<ul>
<li>Sets the game price to <code>newPrice</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the contract owner._</li>
</ul>
<h3 id="setjoingameprice">setJoinGamePrice<a class="headerlink" href="#setjoingameprice" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setJoinGamePrice(uint256 newPrice) external</code></pre>
<p>_Sets the join game price. <code>newPrice</code> is the new join game price.</p>
<p>Modifies:</p>
<ul>
<li>Sets the join game price to <code>newPrice</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the contract owner._</li>
</ul>
<h3 id="setranktokenaddress">setRankTokenAddress<a class="headerlink" href="#setranktokenaddress" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setRankTokenAddress(address newRankToken) external</code></pre>
<p>_Sets the rank token address. <code>newRankToken</code> is the new rank token address.</p>
<p>Modifies:</p>
<ul>
<li>Sets the rank token address to <code>newRankToken</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the contract owner.</li>
<li><code>newRankToken</code> must not be the zero address.</li>
<li><code>newRankToken</code> must support the ERC1155 interface._</li>
</ul>
<h3 id="settimeperturn">setTimePerTurn<a class="headerlink" href="#settimeperturn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setTimePerTurn(uint256 newTimePerTurn) external</code></pre>
<p>_Sets the time per turn. <code>newTimePerTurn</code> is the new time per turn.</p>
<p>Modifies:</p>
<ul>
<li>Sets the time per turn to <code>newTimePerTurn</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the contract owner._</li>
</ul>
<h3 id="setmaxplayerssize">setMaxPlayersSize<a class="headerlink" href="#setmaxplayerssize" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setMaxPlayersSize(uint256 newMaxPlayersSize) external</code></pre>
<p>_Sets the maximum number of players in a game. <code>newMaxPlayersSize</code> is the new maximum number of players.</p>
<p>Modifies:</p>
<ul>
<li>Sets the maximum number of players to <code>newMaxPlayersSize</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the contract owner.</li>
<li><code>newMaxPlayersSize</code> must be greater than or equal to the minimum number of players._</li>
</ul>
<h3 id="setminplayerssize">setMinPlayersSize<a class="headerlink" href="#setminplayerssize" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setMinPlayersSize(uint256 newMinPlayersSize) external</code></pre>
<p>_Sets the minimum number of players in a game. <code>newMinPlayersSize</code> is the new minimum number of players.</p>
<p>Modifies:</p>
<ul>
<li>Sets the minimum number of players to <code>newMinPlayersSize</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the contract owner.</li>
<li><code>newMinPlayersSize</code> must be less than or equal to the maximum number of players._</li>
</ul>
<h3 id="settimetojoin">setTimeToJoin<a class="headerlink" href="#settimetojoin" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setTimeToJoin(uint256 newTimeToJoin) external</code></pre>
<p>_Sets the time to join a game. <code>newTimeToJoin</code> is the new time to join.</p>
<p>Modifies:</p>
<ul>
<li>Sets the time to join to <code>newTimeToJoin</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the contract owner.</li>
<li><code>newTimeToJoin</code> must not be zero._</li>
</ul>
<h3 id="setmaxturns">setMaxTurns<a class="headerlink" href="#setmaxturns" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setMaxTurns(uint256 newMaxTurns) external</code></pre>
<p>_Sets the maximum number of turns in a game. <code>newMaxTurns</code> is the new maximum number of turns.</p>
<p>Modifies:</p>
<ul>
<li>Sets the maximum number of turns to <code>newMaxTurns</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the contract owner.</li>
<li><code>newMaxTurns</code> must not be zero._</li>
</ul>
<h2 id="rankifyinstancemainfacet">RankifyInstanceMainFacet<a class="headerlink" href="#rankifyinstancemainfacet" title="Permanent link">#</a></h2>
<h3 id="rinstancestorage_1">RInstanceStorage<a class="headerlink" href="#rinstancestorage_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog)</code></pre>
<h3 id="creategame">createGame<a class="headerlink" href="#creategame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function createGame(address gameMaster, uint256 gameId, uint256 gameRank) public</code></pre>
<p>_Creates a new game with the provided game master, game ID, and game rank. Optionally, additional ranks can be provided. <code>gameMaster</code> is the address of the game master. <code>gameId</code> is the ID of the new game. <code>gameRank</code> is the rank of the new game. <code>additionalRanks</code> is the array of additional ranks.</p>
<p>emits a <em>GameCreated</em> event.</p>
<p>Requirements:
 There are some game price requirments that must be met under gameId.newGame function that are set during the contract initialization and refer to the contract maintainer benefits.</p>
<p>Modifies:</p>
<ul>
<li>Calls the <code>newGame</code> function with <code>gameMaster</code>, <code>gameRank</code>, and <code>msg.sender</code>.</li>
<li>Configures the coin vending with <code>gameId</code> and an empty configuration.</li>
<li>If <code>additionalRanks</code> is not empty, mints rank tokens for each additional rank and sets the additional ranks of the game with <code>gameId</code> to <code>additionalRanks</code>._</li>
</ul>
<h3 id="creategame_1">createGame<a class="headerlink" href="#creategame_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function createGame(address gameMaster, uint256 gameId, uint256 gameRank, address[] additionalRanks) public</code></pre>
<h3 id="creategame_2">createGame<a class="headerlink" href="#creategame_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function createGame(address gameMaster, uint256 gameRank) public</code></pre>
<h3 id="cancelgame">cancelGame<a class="headerlink" href="#cancelgame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function cancelGame(uint256 gameId) public</code></pre>
<p>_Cancels a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Modifies:</p>
<ul>
<li>Calls the <code>enforceIsGameCreator</code> function with <code>msg.sender</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the game creator of the game with <code>gameId</code>.</li>
<li>Game must not be started._</li>
</ul>
<h3 id="leavegame">leaveGame<a class="headerlink" href="#leavegame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function leaveGame(uint256 gameId) public</code></pre>
<p>_Allows a player to leave a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Modifies:</p>
<ul>
<li>Calls the <code>quitGame</code> function with <code>msg.sender</code>, <code>true</code>, and <code>onPlayerQuit</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be a player in the game with <code>gameId</code>.</li>
<li>Game must not be started._</li>
</ul>
<h3 id="openregistration">openRegistration<a class="headerlink" href="#openregistration" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function openRegistration(uint256 gameId) public</code></pre>
<p>_Opens registration for a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>emits a <em>RegistrationOpen</em> event.</p>
<p>Modifies:</p>
<ul>
<li>Calls the <code>enforceIsGameCreator</code> function with <code>msg.sender</code>.</li>
<li>Calls the <code>enforceIsPreRegistrationStage</code> function.</li>
<li>Calls the <code>openRegistration</code> function.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must be the game creator of the game with <code>gameId</code>.</li>
<li>The game with <code>gameId</code> must be in the pre-registration stage._</li>
</ul>
<h3 id="joingame">joinGame<a class="headerlink" href="#joingame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function joinGame(uint256 gameId) public payable</code></pre>
<p>_Allows a player to join a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>emits a <em>PlayerJoined</em> event.</p>
<p>Modifies:</p>
<ul>
<li>Calls the <code>joinGame</code> function with <code>msg.sender</code>.</li>
<li>Calls the <code>fund</code> function with <code>bytes32(gameId)</code>.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The caller must not be a player in the game with <code>gameId</code>.</li>
<li>Game phase must be registration.</li>
<li>Caller must be able to fulfill funding requirements._</li>
</ul>
<h3 id="startgame">startGame<a class="headerlink" href="#startgame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function startGame(uint256 gameId) public</code></pre>
<p>_Starts a game with the provided game ID early. <code>gameId</code> is the ID of the game.</p>
<p>emits a <em>GameStarted</em> event.</p>
<p>Modifies:</p>
<ul>
<li>Calls the <code>enforceGameExists</code> function.</li>
<li>Calls the <code>startGameEarly</code> function.</li>
</ul>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist._</li>
</ul>
<h3 id="onerc1155received">onERC1155Received<a class="headerlink" href="#onerc1155received" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function onERC1155Received(address operator, address, uint256, uint256, bytes) public view returns (bytes4)</code></pre>
<h3 id="onerc1155batchreceived">onERC1155BatchReceived<a class="headerlink" href="#onerc1155batchreceived" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function onERC1155BatchReceived(address operator, address, uint256[], uint256[], bytes) external view returns (bytes4)</code></pre>
<h3 id="onerc721received">onERC721Received<a class="headerlink" href="#onerc721received" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function onERC721Received(address operator, address, uint256, bytes) external view returns (bytes4)</code></pre>
<h3 id="getcontractstate_1">getContractState<a class="headerlink" href="#getcontractstate_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getContractState() public view returns (struct IRankifyInstanceCommons.RInstanceState)</code></pre>
<h3 id="getturn">getTurn<a class="headerlink" href="#getturn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getTurn(uint256 gameId) public view returns (uint256)</code></pre>
<h3 id="getgm">getGM<a class="headerlink" href="#getgm" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getGM(uint256 gameId) public view returns (address)</code></pre>
<h3 id="getscores">getScores<a class="headerlink" href="#getscores" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getScores(uint256 gameId) public view returns (address[], uint256[])</code></pre>
<h3 id="isovertime">isOvertime<a class="headerlink" href="#isovertime" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isOvertime(uint256 gameId) public view returns (bool)</code></pre>
<h3 id="isgameover">isGameOver<a class="headerlink" href="#isgameover" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isGameOver(uint256 gameId) public view returns (bool)</code></pre>
<h3 id="getplayersgame">getPlayersGame<a class="headerlink" href="#getplayersgame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPlayersGame(address player) public view returns (uint256)</code></pre>
<h3 id="islastturn">isLastTurn<a class="headerlink" href="#islastturn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isLastTurn(uint256 gameId) public view returns (bool)</code></pre>
<h3 id="isregistrationopen">isRegistrationOpen<a class="headerlink" href="#isregistrationopen" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isRegistrationOpen(uint256 gameId) public view returns (bool)</code></pre>
<h3 id="gamecreator">gameCreator<a class="headerlink" href="#gamecreator" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function gameCreator(uint256 gameId) public view returns (address)</code></pre>
<h3 id="getgamerank">getGameRank<a class="headerlink" href="#getgamerank" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getGameRank(uint256 gameId) public view returns (uint256)</code></pre>
<h3 id="getplayers">getPlayers<a class="headerlink" href="#getplayers" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPlayers(uint256 gameId) public view returns (address[])</code></pre>
<h3 id="canstartgame">canStartGame<a class="headerlink" href="#canstartgame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function canStartGame(uint256 gameId) public view returns (bool)</code></pre>
<h3 id="canendturn">canEndTurn<a class="headerlink" href="#canendturn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function canEndTurn(uint256 gameId) public view returns (bool)</code></pre>
<h3 id="isplayerturncomplete">isPlayerTurnComplete<a class="headerlink" href="#isplayerturncomplete" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isPlayerTurnComplete(uint256 gameId, address player) public view returns (bool)</code></pre>
<h3 id="getplayervotedarray">getPlayerVotedArray<a class="headerlink" href="#getplayervotedarray" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPlayerVotedArray(uint256 gameId) public view returns (bool[])</code></pre>
<h3 id="getplayersmoved">getPlayersMoved<a class="headerlink" href="#getplayersmoved" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPlayersMoved(uint256 gameId) public view returns (bool[], uint256)</code></pre>
<h2 id="rankifyinstancerequirementsfacet">RankifyInstanceRequirementsFacet<a class="headerlink" href="#rankifyinstancerequirementsfacet" title="Permanent link">#</a></h2>
<h3 id="requirementsconfigured">RequirementsConfigured<a class="headerlink" href="#requirementsconfigured" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event RequirementsConfigured(uint256 gameId, struct LibCoinVending.ConfigPosition config)</code></pre>
<h3 id="setjoinrequirements">setJoinRequirements<a class="headerlink" href="#setjoinrequirements" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setJoinRequirements(uint256 gameId, struct LibCoinVending.ConfigPosition config) public</code></pre>
<p><em>Sets the join requirements for a specific game.
Only the game creator can call this function.
The game must be in the pre-registration stage.</em></p>
<h4 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gameId</td>
<td>uint256</td>
<td>The ID of the game.</td>
</tr>
<tr>
<td>config</td>
<td>struct LibCoinVending.ConfigPosition</td>
<td>The configuration position for the join requirements.</td>
</tr>
</tbody>
</table>
<h3 id="getjoinrequirements">getJoinRequirements<a class="headerlink" href="#getjoinrequirements" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getJoinRequirements(uint256 gameId) public view returns (struct LibCoinVending.ConditionReturn)</code></pre>
<p><em>Retrieves the join requirements for a specific game.</em></p>
<h4 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gameId</td>
<td>uint256</td>
<td>The ID of the game.</td>
</tr>
</tbody>
</table>
<h4 id="return-values_4">Return Values<a class="headerlink" href="#return-values_4" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>struct LibCoinVending.ConditionReturn</td>
<td>The join requirements as a <code>LibCoinVending.ConditionReturn</code> struct.</td>
</tr>
</tbody>
</table>
<h3 id="getjoinrequirementsbytoken">getJoinRequirementsByToken<a class="headerlink" href="#getjoinrequirementsbytoken" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getJoinRequirementsByToken(uint256 gameId, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) public view returns (struct LibCoinVending.ContractCondition)</code></pre>
<p><em>Retrieves the join requirements for a specific token in a game.</em></p>
<h4 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gameId</td>
<td>uint256</td>
<td>The ID of the game.</td>
</tr>
<tr>
<td>contractAddress</td>
<td>address</td>
<td>The address of the contract.</td>
</tr>
<tr>
<td>contractId</td>
<td>uint256</td>
<td>The ID of the contract.</td>
</tr>
<tr>
<td>contractType</td>
<td>enum LibCoinVending.ContractTypes</td>
<td>The type of the contract.</td>
</tr>
</tbody>
</table>
<h4 id="return-values_5">Return Values<a class="headerlink" href="#return-values_5" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>struct LibCoinVending.ContractCondition</td>
<td>The join requirements for the specified token.</td>
</tr>
</tbody>
</table>
<h2 id="ierc1155receiver">IERC1155Receiver<a class="headerlink" href="#ierc1155receiver" title="Permanent link">#</a></h2>
<h3 id="onerc1155received_1">onERC1155Received<a class="headerlink" href="#onerc1155received_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes data) external returns (bytes4)</code></pre>
<p>validate receipt of ERC1155 transfer</p>
<h4 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>operator</td>
<td>address</td>
<td>executor of transfer</td>
</tr>
<tr>
<td>from</td>
<td>address</td>
<td>sender of tokens</td>
</tr>
<tr>
<td>id</td>
<td>uint256</td>
<td>token ID received</td>
</tr>
<tr>
<td>value</td>
<td>uint256</td>
<td>quantity of tokens received</td>
</tr>
<tr>
<td>data</td>
<td>bytes</td>
<td>data payload</td>
</tr>
</tbody>
</table>
<h4 id="return-values_6">Return Values<a class="headerlink" href="#return-values_6" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bytes4</td>
<td>function's own selector if transfer is accepted</td>
</tr>
</tbody>
</table>
<h3 id="onerc1155batchreceived_1">onERC1155BatchReceived<a class="headerlink" href="#onerc1155batchreceived_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function onERC1155BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data) external returns (bytes4)</code></pre>
<p>validate receipt of ERC1155 batch transfer</p>
<h4 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>operator</td>
<td>address</td>
<td>executor of transfer</td>
</tr>
<tr>
<td>from</td>
<td>address</td>
<td>sender of tokens</td>
</tr>
<tr>
<td>ids</td>
<td>uint256[]</td>
<td>token IDs received</td>
</tr>
<tr>
<td>values</td>
<td>uint256[]</td>
<td>quantities of tokens received</td>
</tr>
<tr>
<td>data</td>
<td>bytes</td>
<td>data payload</td>
</tr>
</tbody>
</table>
<h4 id="return-values_7">Return Values<a class="headerlink" href="#return-values_7" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>bytes4</td>
<td>function's own selector if transfer is accepted</td>
</tr>
</tbody>
</table>
<h2 id="ilockableerc1155">ILockableERC1155<a class="headerlink" href="#ilockableerc1155" title="Permanent link">#</a></h2>
<p><em>Interface for a lockable ERC1155 token contract.</em></p>
<h3 id="tokenslocked">TokensLocked<a class="headerlink" href="#tokenslocked" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event TokensLocked(address account, uint256 id, uint256 value)</code></pre>
<h3 id="tokensunlocked">TokensUnlocked<a class="headerlink" href="#tokensunlocked" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event TokensUnlocked(address account, uint256 id, uint256 value)</code></pre>
<h3 id="lock_1">lock<a class="headerlink" href="#lock_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function lock(address account, uint256 id, uint256 amount) external</code></pre>
<p>_Locks a specified amount of tokens for a given account and token ID. <code>account</code> is the address of the account to lock the tokens for. <code>id</code> is the ID of the token to lock. <code>amount</code> is the amount of tokens to lock.</p>
<p>emits a <em>TokensLocked</em> event._</p>
<h3 id="unlock_1">unlock<a class="headerlink" href="#unlock_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function unlock(address account, uint256 id, uint256 amount) external</code></pre>
<p>_Unlocks a specified amount of tokens for a given account and token ID. <code>account</code> is the address of the account to unlock the tokens for. <code>id</code> is the ID of the token to unlock. <code>amount</code> is the amount of tokens to unlock.</p>
<p>emits a <em>TokensUnlocked</em> event._</p>
<h3 id="unlockedbalanceof_1">unlockedBalanceOf<a class="headerlink" href="#unlockedbalanceof_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function unlockedBalanceOf(address account, uint256 id) external view returns (uint256)</code></pre>
<p>_Returns the unlocked balance of tokens for a given account and token ID. <code>account</code> is the address of the account to check the unlocked balance for. <code>id</code> is the ID of the token to check the unlocked balance for.</p>
<p>Returns:</p>
<ul>
<li>The unlocked balance of tokens._</li>
</ul>
<h2 id="imultipass">IMultipass<a class="headerlink" href="#imultipass" title="Permanent link">#</a></h2>
<h3 id="resolverecord_1">resolveRecord<a class="headerlink" href="#resolverecord_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function resolveRecord(struct LibMultipass.NameQuery query) external view returns (bool, struct LibMultipass.Record)</code></pre>
<h3 id="initializedomain_1">initializeDomain<a class="headerlink" href="#initializedomain_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) external</code></pre>
<p>_Initializes new LibMultipass.Domain and configures it's parameters</p>
<p>Requirements:
 registrar is not zero
 domainName is not empty
 domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names
 domainName does not exist yet
 onlyOwner
 referrerReward+referralDiscount cannot be larger than fee
 @param registrar address of registrar
 @param freeRegistrationsNumber number of registrations free of fee
 @param fee fee in base currency of network
 @param domainName name of LibMultipass.Domain
 @param referrerReward referral fee share in base currency of network
 @param referralDiscount referral discount in base currency of network</p>
<p>Emits an {InitializedDomain} event._</p>
<h3 id="activatedomain_1">activateDomain<a class="headerlink" href="#activatedomain_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function activateDomain(bytes32 domainName) external</code></pre>
<p>_Activates LibMultipass.Domain name</p>
<p>Requirements:
 msg.sender is Owner</p>
<p>Emits an {DomainActivated} event._</p>
<h3 id="deactivatedomain_1">deactivateDomain<a class="headerlink" href="#deactivatedomain_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function deactivateDomain(bytes32 domainName) external</code></pre>
<p>_Deactivates LibMultipass.Domain name</p>
<p>Deactivated LibMultipass.Domain cannot mutate names and will return zeros</p>
<p>Requirements:
 msg.sender is Owner OR registrar</p>
<p>Emits an {DomainDeactivated} event._</p>
<h3 id="changefee_1">changeFee<a class="headerlink" href="#changefee_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function changeFee(bytes32 domainName, uint256 fee) external</code></pre>
<p>_Changes registrar address</p>
<p>Requirements:
 msg.sender is Owner</p>
<p>Emits an {DomainFeeChanged} event._</p>
<h3 id="changeregistrar_1">changeRegistrar<a class="headerlink" href="#changeregistrar_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function changeRegistrar(bytes32 domainName, address newRegistrar) external</code></pre>
<p>_Changes registrar address</p>
<p>Requirements:
 msg.sender is Owner</p>
<p>Emits an {RegistrarChangeRequested} event._</p>
<h3 id="deletename_1">deleteName<a class="headerlink" href="#deletename_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function deleteName(struct LibMultipass.NameQuery query) external</code></pre>
<p>_deletes name</p>
<p>Requirements:
 msg.sender is Owner</p>
<p>Emits an {DomainTTLChangeRequested} event._</p>
<h3 id="changereferralprogram_1">changeReferralProgram<a class="headerlink" href="#changereferralprogram_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function changeReferralProgram(uint256 referrerFeeShare, uint256 referralDiscount, uint256 freeRegistrations, bytes32 domainName) external</code></pre>
<p>_executes all pending changes to LibMultipass.Domain that fulfill TTL</p>
<p>Requirements:
 domainName must be set
 referrerFeeShare+referralDiscount cannot be larger than 2^32</p>
<p>Emits an {ReferralProgramChangeRequested} event._</p>
<h3 id="register_1">register<a class="headerlink" href="#register_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) external payable</code></pre>
<p>_registers new name under LibMultipass.Domain</p>
<p>Requirements:
 all arguments must be set
 domainName must be active
resolveRecord for given arguments should return no LibMultipass.Record</p>
<p>Emits an {registered} event._</p>
<h3 id="modifyusername_1">modifyUserName<a class="headerlink" href="#modifyusername_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) external payable</code></pre>
<p>_modifies exsisting LibMultipass.Record</p>
<p>Requirements:
resolveRecord for given arguments should return valid LibMultipass.Record
LibMultipass.Domain must be active
newAddress and newName should be set and be unique in current LibMultipass.Domain_</p>
<h4 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>domainName</td>
<td>bytes32</td>
<td>LibMultipass.Domain</td>
</tr>
<tr>
<td>query</td>
<td>struct LibMultipass.NameQuery</td>
<td></td>
</tr>
<tr>
<td>newName</td>
<td>bytes32</td>
<td>new name  Emits an {Modified} event.</td>
</tr>
<tr>
<td>registrarSignature</td>
<td>bytes</td>
<td></td>
</tr>
<tr>
<td>signatureDeadline</td>
<td>uint256</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="getbalance_1">getBalance<a class="headerlink" href="#getbalance_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getBalance() external view returns (uint256)</code></pre>
<p><em>returns balance of this contract</em></p>
<h3 id="getdomainstate_1">getDomainState<a class="headerlink" href="#getdomainstate_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain)</code></pre>
<p><em>returns LibMultipass.Domain state variables</em></p>
<h4 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>domainName</td>
<td>bytes32</td>
<td>name of the LibMultipass.Domain</td>
</tr>
</tbody>
</table>
<h4 id="return-values_8">Return Values<a class="headerlink" href="#return-values_8" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>struct LibMultipass.Domain</td>
<td>(name,       fee,       freeRegistrationsNumber,        referrerReward,        referralDiscount,        isActive,        registrar,        ttl,         registerSize)</td>
</tr>
</tbody>
</table>
<h3 id="getcontractstate_2">getContractState<a class="headerlink" href="#getcontractstate_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getContractState() external view returns (uint256)</code></pre>
<p><em>returns contract state variables</em></p>
<h4 id="return-values_9">Return Values<a class="headerlink" href="#return-values_9" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0]</td>
<td>uint256</td>
<td>(s_numDomains)</td>
</tr>
</tbody>
</table>
<h3 id="withrawfunds_1">withrawFunds<a class="headerlink" href="#withrawfunds_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function withrawFunds(address to) external</code></pre>
<p>_Withraws funds stored in smart contract</p>
<p>Requirements:
 onlyOwner</p>
<p>Emits an {fundsWithdawn} event._</p>
<h3 id="getmodifyprice_1">getModifyPrice<a class="headerlink" href="#getmodifyprice_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getModifyPrice(struct LibMultipass.NameQuery query) external view returns (uint256)</code></pre>
<h3 id="fundswithdawn">fundsWithdawn<a class="headerlink" href="#fundswithdawn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event fundsWithdawn(uint256 amount, address account)</code></pre>
<h3 id="initializeddomain">InitializedDomain<a class="headerlink" href="#initializeddomain" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event InitializedDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount)</code></pre>
<h3 id="domainactivated">DomainActivated<a class="headerlink" href="#domainactivated" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event DomainActivated(bytes32 domainName)</code></pre>
<h3 id="domaindeactivated">DomainDeactivated<a class="headerlink" href="#domaindeactivated" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event DomainDeactivated(bytes32 domainName)</code></pre>
<h3 id="domainfeechanged">DomainFeeChanged<a class="headerlink" href="#domainfeechanged" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event DomainFeeChanged(bytes32 domainName, uint256 newFee)</code></pre>
<h3 id="freeregistrationschanged">FreeRegistrationsChanged<a class="headerlink" href="#freeregistrationschanged" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event FreeRegistrationsChanged(uint256 domainIndex, uint256 newAmount)</code></pre>
<h3 id="registrarchangerequested">RegistrarChangeRequested<a class="headerlink" href="#registrarchangerequested" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event RegistrarChangeRequested(bytes32 domainName, address registrar)</code></pre>
<h3 id="domainnamechangerequested">DomainNameChangeRequested<a class="headerlink" href="#domainnamechangerequested" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event DomainNameChangeRequested(uint256 domainIndex, bytes32 NewDomainName)</code></pre>
<h3 id="namedeleted">nameDeleted<a class="headerlink" href="#namedeleted" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event nameDeleted(bytes32 domainName, address wallet, bytes32 id, bytes32 name)</code></pre>
<h3 id="domainttlchangerequested">DomainTTLChangeRequested<a class="headerlink" href="#domainttlchangerequested" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event DomainTTLChangeRequested(bytes32 domainName, uint256 amount)</code></pre>
<h3 id="referralprogramchanged">ReferralProgramChanged<a class="headerlink" href="#referralprogramchanged" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event ReferralProgramChanged(bytes32 domainName, uint256 reward, uint256 discount, uint256 freeNumber)</code></pre>
<h3 id="domainchangesarelive">DomainChangesAreLive<a class="headerlink" href="#domainchangesarelive" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event DomainChangesAreLive(bytes32 domainName, bytes32[] changes)</code></pre>
<h3 id="changesqeuecanceled">changesQeueCanceled<a class="headerlink" href="#changesqeuecanceled" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event changesQeueCanceled(bytes32 domainName, bytes32[] changes)</code></pre>
<h3 id="registered">Registered<a class="headerlink" href="#registered" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event Registered(bytes32 domainName, struct LibMultipass.Record NewRecord)</code></pre>
<h3 id="referred">Referred<a class="headerlink" href="#referred" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event Referred(struct LibMultipass.Record refferrer, struct LibMultipass.Record newRecord, bytes32 domainName)</code></pre>
<h3 id="userrecordmodified">UserRecordModified<a class="headerlink" href="#userrecordmodified" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event UserRecordModified(struct LibMultipass.Record newRecord, bytes32 oldName, bytes32 domainName)</code></pre>
<h2 id="iranktoken">IRankToken<a class="headerlink" href="#iranktoken" title="Permanent link">#</a></h2>
<h3 id="rankinginstanceupdated">RankingInstanceUpdated<a class="headerlink" href="#rankinginstanceupdated" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event RankingInstanceUpdated(address newRankingInstance)</code></pre>
<h3 id="levelup">LevelUp<a class="headerlink" href="#levelup" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event LevelUp(address account, uint256 id)</code></pre>
<h3 id="mint">mint<a class="headerlink" href="#mint" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function mint(address to, uint256 amount, uint256 poolId, bytes data) external</code></pre>
<p><em>Mints a specified amount of tokens to an account. <code>to</code> is the address of the account to mint the tokens to. <code>amount</code> is the amount of tokens to mint. <code>poolId</code> is the ID of the pool. <code>data</code> is the additional data.</em></p>
<h3 id="batchmint">batchMint<a class="headerlink" href="#batchmint" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) external</code></pre>
<p><em>Mints specified amounts of tokens to an account. <code>to</code> is the address of the account to mint the tokens to. <code>ids</code> is the array of IDs of the tokens to mint. <code>amounts</code> is the array of amounts of tokens to mint. <code>data</code> is the additional data.</em></p>
<h3 id="levelup_1">levelUp<a class="headerlink" href="#levelup_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function levelUp(address to, uint256 id, bytes data) external</code></pre>
<p>_Levels up an account. <code>to</code> is the address of the account to level up. <code>id</code> is the ID of the token. <code>data</code> is the additional data.</p>
<p>emits a <em>LevelUp</em> event._</p>
<h3 id="updaterankinginstance">updateRankingInstance<a class="headerlink" href="#updaterankinginstance" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function updateRankingInstance(address newRankingInstance) external</code></pre>
<p>_Updates the ranking instance. <code>newRankingInstance</code> is the address of the new ranking instance.</p>
<p>emits a <em>RankingInstanceUpdated</em> event._</p>
<h3 id="getrankinginstance">getRankingInstance<a class="headerlink" href="#getrankinginstance" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getRankingInstance() external view returns (address)</code></pre>
<p>_Gets the ranking instance which can emit new rank updates and mint rank tokens.</p>
<p>Returns:</p>
<ul>
<li>The address of the ranking instance._</li>
</ul>
<h3 id="findnewrank">findNewRank<a class="headerlink" href="#findnewrank" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function findNewRank(address account, uint256 oldRank) external view returns (uint256)</code></pre>
<p>_Finds the new rank of an account. <code>account</code> is the address of the account. <code>oldRank</code> is the old rank of the account.
It checks the balance of the account and returns the new rank that can be upgraded to.</p>
<p>Returns:</p>
<ul>
<li>The new rank of the account._</li>
</ul>
<h3 id="getaccountrank">getAccountRank<a class="headerlink" href="#getaccountrank" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getAccountRank(address account) external view returns (uint256)</code></pre>
<p>_Gets the rank of an account. <code>account</code> is the address of the account.</p>
<p>Returns:</p>
<ul>
<li>The rank of the account._</li>
</ul>
<h2 id="irankifyinstancecommons">IRankifyInstanceCommons<a class="headerlink" href="#irankifyinstancecommons" title="Permanent link">#</a></h2>
<h3 id="score">Score<a class="headerlink" href="#score" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct Score {
  address participant;
  uint256 score;
}</code></pre>
<h3 id="rinstancesettings">RInstanceSettings<a class="headerlink" href="#rinstancesettings" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct RInstanceSettings {
  uint256 gamePrice;
  address gamePaymentToken;
  uint256 joinGamePrice;
  uint256 numGames;
  address rankTokenAddress;
  bool contractInitialized;
  struct LibQuadraticVoting.qVotingStruct voting;
}</code></pre>
<h3 id="rinstancestate">RInstanceState<a class="headerlink" href="#rinstancestate" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct RInstanceState {
  struct IRankifyInstanceCommons.RInstanceSettings BestOfState;
  struct LibTBG.GameSettings TBGSEttings;
}</code></pre>
<h3 id="votehidden">VoteHidden<a class="headerlink" href="#votehidden" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct VoteHidden {
  bytes32 hash;
  bytes proof;
}</code></pre>
<h3 id="rinstance">RInstance<a class="headerlink" href="#rinstance" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct RInstance {
  uint256 rank;
  address createdBy;
  mapping(uint256 =&gt; string) ongoingProposals;
  uint256 numOngoingProposals;
  uint256 numPrevProposals;
  mapping(address =&gt; bytes32) proposalCommitmentHashes;
  uint256 numCommitments;
  mapping(address =&gt; struct IRankifyInstanceCommons.VoteHidden) votesHidden;
  address[] additionalRanks;
  uint256 paymentsBalance;
  uint256 numVotesThisTurn;
  uint256 numVotesPrevTurn;
  mapping(address =&gt; bool) playerVoted;
}</code></pre>
<h3 id="registrationopen">RegistrationOpen<a class="headerlink" href="#registrationopen" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event RegistrationOpen(uint256 gameid)</code></pre>
<h3 id="playerjoined">PlayerJoined<a class="headerlink" href="#playerjoined" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event PlayerJoined(uint256 gameId, address participant)</code></pre>
<h3 id="gamestarted">GameStarted<a class="headerlink" href="#gamestarted" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event GameStarted(uint256 gameId)</code></pre>
<h3 id="gamecreated">gameCreated<a class="headerlink" href="#gamecreated" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event gameCreated(uint256 gameId, address gm, address creator, uint256 rank)</code></pre>
<h3 id="gameclosed">GameClosed<a class="headerlink" href="#gameclosed" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event GameClosed(uint256 gameId)</code></pre>
<h3 id="playerleft">PlayerLeft<a class="headerlink" href="#playerleft" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event PlayerLeft(uint256 gameId, address player)</code></pre>
<h2 id="libarray">LibArray<a class="headerlink" href="#libarray" title="Permanent link">#</a></h2>
<h3 id="quicksort">quickSort<a class="headerlink" href="#quicksort" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function quickSort(uint256[] arr, int256 left, int256 right) internal view</code></pre>
<p>_Sorts the elements of the array in ascending order using the quicksort algorithm.</p>
<p>Requirements:</p>
<ul>
<li>The array to be sorted must not be empty.</li>
<li>The starting and ending indices must be within the bounds of the array.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>The array is sorted in ascending order.</li>
</ul>
<p>Note:</p>
<ul>
<li>This function uses the in-place quicksort algorithm, which has an average-case complexity of O(n log n) and a worst-case complexity of O(n^2)._</li>
</ul>
<h2 id="libcoinvending">LibCoinVending<a class="headerlink" href="#libcoinvending" title="Permanent link">#</a></h2>
<p>_This library is used to simulate the vending machine coin acceptor state machine that:
 - Supports large number of positions; Each represents requirements to acess different goods of the virtual vending machine.
 - Accepts multiple assets of following types: Native (Eth), ERC20, ERC721, and ERC1155 tokens that can be stacked together.
 - Allows for each individual asset action promise can be one of following:
     - Lock: The asset is locked in the acceptor with promise that asset will be returned to the sender at release funds time.
     - Bet: The asset is locked in the acceptor with promise that asset will be awarded to benificiary at release funds time.
     - Pay: The asset is locked in the acceptor with promise that asset will be paid to payee at release funds time.
     - Burn: The asset is locked in the acceptor with promise that asset will be destroyed at release funds time.
 - Maintains each position balance, hence allowing multiple participants to line up for the same position.
 - Allows three actions:
     - Fund position with assets
     - Refund assets to user
     - Consume assets and provide goods to user
     - Consuming asset might take a form of
     - Transferring assets to payee
     - Burning assets
     - Awarding beneficiary with assets
     - Returning locked assets back to sender</p>
<p>This library DOES enforces that any position can only be refunded or processed only within amount funded boundaries
This library DOES NOT store the addresses of senders, nor benificiaries, nor payees.
This is to be stored within implementation contract.</p>
<p>!!!!! IMPORTANT !!!!!
This library does NOT invocates reentrancy guards. It is implementation contract's responsibility to enforce reentrancy guards.
Reentrancy guards MUST be implemented in an implementing contract.</p>
<p>Usage:</p>
<ol>
<li>Configure position via configure(...)</li>
<li>fund position with assets via fund(...)</li>
<li>release or refund assets via release(...) or refund(...)</li>
<li>repeat steps 1 and 2 as needed.
 Position can be recofigured at any time when it's effective balance is zero: <code>timesFunded - timesRefuned - timesReleased = 0</code></li>
</ol>
<p>Test state:
This library most functionality has been tested: see ../tests/LibCoinVending.ts and ../tests/report.md for details.</p>
<p>ERC721 token is checked only for "HAVE" condition since putting requirements on non fungable token id yet to be resolved.
(see ERC721 section in the code below)</p>
<p>This library has not been yet audited_</p>
<h3 id="condition">Condition<a class="headerlink" href="#condition" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct Condition {
  mapping(enum LibCoinVending.ContractTypes =&gt; mapping(address =&gt; mapping(uint256 =&gt; struct LibCoinVending.ContractCondition))) contracts;
  struct LibCoinVending.NumericCondition ethValues;
  uint256 timesRefunded;
  uint256 timesReleased;
  uint256 timesFunded;
  enum LibCoinVending.ContractTypes[] contractTypes;
  address[] contractAddresses;
  uint256[] contractIds;
  bool _isConfigured;
}</code></pre>
<h3 id="requirementtypes">RequirementTypes<a class="headerlink" href="#requirementtypes" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">enum RequirementTypes {
  HAVE,
  LOCK,
  BURN,
  BET,
  PAY
}</code></pre>
<h3 id="transactionproperties">TransactionProperties<a class="headerlink" href="#transactionproperties" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct TransactionProperties {
  bytes data;
  uint256 amount;
}</code></pre>
<h3 id="contractcondition">ContractCondition<a class="headerlink" href="#contractcondition" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct ContractCondition {
  struct LibCoinVending.TransactionProperties have;
  struct LibCoinVending.TransactionProperties lock;
  struct LibCoinVending.TransactionProperties burn;
  struct LibCoinVending.TransactionProperties pay;
  struct LibCoinVending.TransactionProperties bet;
}</code></pre>
<h3 id="numericcondition">NumericCondition<a class="headerlink" href="#numericcondition" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct NumericCondition {
  uint256 have;
  uint256 lock;
  uint256 burn;
  uint256 pay;
  uint256 bet;
}</code></pre>
<h3 id="transfertypes">TransferTypes<a class="headerlink" href="#transfertypes" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">enum TransferTypes {
  FUND,
  REFUND,
  RELEASE
}</code></pre>
<h3 id="conditionreturn">ConditionReturn<a class="headerlink" href="#conditionreturn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct ConditionReturn {
  struct LibCoinVending.NumericCondition ethValues;
  uint256 timesRefunded;
  uint256 timesReleased;
  uint256 timesFunded;
  address[] contractAddresses;
  uint256[] contractIds;
  enum LibCoinVending.ContractTypes[] contractTypes;
  bool _isConfigured;
}</code></pre>
<h3 id="configsmartrequirement">configSmartRequirement<a class="headerlink" href="#configsmartrequirement" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct configSmartRequirement {
  address contractAddress;
  uint256 contractId;
  enum LibCoinVending.ContractTypes contractType;
  struct LibCoinVending.ContractCondition contractRequirement;
}</code></pre>
<h3 id="configposition">ConfigPosition<a class="headerlink" href="#configposition" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct ConfigPosition {
  struct LibCoinVending.NumericCondition ethValues;
  struct LibCoinVending.configSmartRequirement[] contracts;
}</code></pre>
<h3 id="libcoinvendingstorage">LibCoinVendingStorage<a class="headerlink" href="#libcoinvendingstorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct LibCoinVendingStorage {
  mapping(bytes32 =&gt; struct LibCoinVending.Condition) positions;
  address beneficiary;
}</code></pre>
<h3 id="contracttypes">ContractTypes<a class="headerlink" href="#contracttypes" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">enum ContractTypes {
  ERC20,
  ERC1155,
  ERC721
}</code></pre>
<h3 id="coin_vending_storage_position">COIN_VENDING_STORAGE_POSITION<a class="headerlink" href="#coin_vending_storage_position" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 COIN_VENDING_STORAGE_POSITION</code></pre>
<h3 id="coinvendingposition">coinVendingPosition<a class="headerlink" href="#coinvendingposition" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function coinVendingPosition(bytes32 position) internal view returns (struct LibCoinVending.Condition)</code></pre>
<h3 id="coinvendingstorage">coinVendingStorage<a class="headerlink" href="#coinvendingstorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function coinVendingStorage() internal pure returns (struct LibCoinVending.LibCoinVendingStorage es)</code></pre>
<h3 id="refund">refund<a class="headerlink" href="#refund" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function refund(bytes32 position, address to) internal</code></pre>
<p>_Returns all position requirements back to fundee. <code>position</code> is the identifier of the condition. <code>to</code> is the address to refund the balance to.</p>
<p>Requirements:</p>
<ul>
<li>The sum of <code>timesRefunded</code> and <code>timesReleased</code> for the condition must be less than <code>timesFunded</code>.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Transfers the remaining balance of the condition to the <code>to</code> address.</li>
<li>Increments the <code>timesRefunded</code> counter for the condition._</li>
</ul>
<h3 id="batchrefund">batchRefund<a class="headerlink" href="#batchrefund" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function batchRefund(bytes32 position, address[] returnAddresses) internal</code></pre>
<p>_Returns all position requirements back to multiple fundees. <code>position</code> is the identifier of the condition. <code>returnAddresses</code> is an array of addresses to refund the balance to.</p>
<p>Requirements:</p>
<ul>
<li>The sum of <code>timesRefunded</code> and <code>timesReleased</code> for the condition must be less than <code>timesFunded</code>.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Transfers the remaining balance of the condition to each address in <code>returnAddresses</code>.</li>
<li>Increments the <code>timesRefunded</code> counter for the condition for each address in <code>returnAddresses</code>._</li>
</ul>
<h3 id="release">release<a class="headerlink" href="#release" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function release(bytes32 position, address payee, address beneficiary, address returnAddress) internal</code></pre>
<p>_Releases the funds from a coin vending position to the specified addresses. <code>position</code> is the identifier of the condition. <code>payee</code>, <code>beneficiary</code>, and <code>returnAddress</code> are the addresses to release the funds to.</p>
<p>Requirements:</p>
<ul>
<li>The sum of <code>timesRefunded</code> and <code>timesReleased</code> for the condition must be less than <code>timesFunded</code>.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Transfers the remaining balance of the condition to the <code>payee</code>, <code>beneficiary</code>, and <code>returnAddress</code>.</li>
<li>Increments the <code>timesReleased</code> counter for the condition._</li>
</ul>
<h3 id="batchrelease">batchRelease<a class="headerlink" href="#batchrelease" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function batchRelease(bytes32 position, address payee, address beneficiary, address[] returnAddresses) internal</code></pre>
<p>_Releases the funds from a coin vending position to multiple return addresses. <code>position</code> is the identifier of the condition. <code>payee</code>, <code>beneficiary</code>, and <code>returnAddresses</code> are the addresses to release the funds to.</p>
<p>Requirements:</p>
<ul>
<li>The sum of <code>timesRefunded</code> and <code>timesReleased</code> for the condition must be less than <code>timesFunded</code>.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Transfers the remaining balance of the condition to the <code>payee</code>, <code>beneficiary</code>, and each address in <code>returnAddresses</code>.</li>
<li>Increments the <code>timesReleased</code> counter for the condition for each address in <code>returnAddresses</code>._</li>
</ul>
<h3 id="fund">fund<a class="headerlink" href="#fund" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function fund(bytes32 position) internal</code></pre>
<p>_Funds the position by <code>msg.sender</code>. <code>position</code> is the identifier of the condition.</p>
<p>Requirements:</p>
<ul>
<li>The condition must be configured.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Transfers the funds from <code>msg.sender</code> to this contract.</li>
<li>Increments the <code>timesFunded</code> counter for the condition._</li>
</ul>
<h3 id="configure">configure<a class="headerlink" href="#configure" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function configure(bytes32 position, struct LibCoinVending.ConfigPosition configuration) internal</code></pre>
<p>_Configures the position. <code>position</code> is the identifier of the condition. <code>configuration</code> is the new configuration for the condition.</p>
<p>Requirements:</p>
<ul>
<li>The condition must not have a positive balance.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the configuration of the condition to <code>configuration</code>._</li>
</ul>
<h3 id="getposition">getPosition<a class="headerlink" href="#getposition" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPosition(bytes32 position) internal view returns (struct LibCoinVending.ConditionReturn)</code></pre>
<p>_Returns the condition associated with the given position. <code>position</code> is the identifier of the condition.</p>
<p>Returns:</p>
<ul>
<li>The condition associated with <code>position</code>._</li>
</ul>
<h3 id="getpositionbycontract">getPositionByContract<a class="headerlink" href="#getpositionbycontract" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPositionByContract(bytes32 position, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) internal view returns (struct LibCoinVending.ContractCondition)</code></pre>
<p>_Returns the contract condition associated with the given position, contract address, contract ID, and contract type. <code>position</code> is the identifier of the condition. <code>contractAddress</code> is the address of the contract. <code>contractId</code> is the ID of the contract. <code>contractType</code> is the type of the contract.</p>
<p>Returns:</p>
<ul>
<li>The contract condition associated with <code>position</code>, <code>contractAddress</code>, <code>contractId</code>, and <code>contractType</code>._</li>
</ul>
<h2 id="libeip712withstorage">LibEIP712WithStorage<a class="headerlink" href="#libeip712withstorage" title="Permanent link">#</a></h2>
<h3 id="eip712_storage_position">EIP712_STORAGE_POSITION<a class="headerlink" href="#eip712_storage_position" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 EIP712_STORAGE_POSITION</code></pre>
<h3 id="libeip712withstoragestorage">LibEIP712WithStorageStorage<a class="headerlink" href="#libeip712withstoragestorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct LibEIP712WithStorageStorage {
  bytes32 _CACHED_DOMAIN_SEPARATOR;
  uint256 _CACHED_CHAIN_ID;
  address _CACHED_THIS;
  bytes32 _HASHED_NAME;
  bytes32 _HASHED_VERSION;
  bytes32 _TYPE_HASH;
}</code></pre>
<h3 id="eip712withstorage">EIP712WithStorage<a class="headerlink" href="#eip712withstorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function EIP712WithStorage() internal pure returns (struct LibEIP712WithStorage.LibEIP712WithStorageStorage ds)</code></pre>
<h2 id="libmultipass">LibMultipass<a class="headerlink" href="#libmultipass" title="Permanent link">#</a></h2>
<h3 id="namequery">NameQuery<a class="headerlink" href="#namequery" title="Permanent link">#</a></h3>
<p><em>resolves user from any given argument
Requirements:
 domainName must be given and must be initialized
 id OR username OR address must be given
This method first tries to resolve by address, then by user id and finally by username</em></p>
<h4 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-solidity">struct NameQuery {
  bytes32 domainName;
  address wallet;
  bytes32 name;
  bytes32 id;
  bytes32 targetDomain;
}</code></pre>
<h3 id="domain">Domain<a class="headerlink" href="#domain" title="Permanent link">#</a></h3>
<p><em>The domain name of the registrar.</em></p>
<h4 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-solidity">struct Domain {
  bytes32 name;
  uint256 fee;
  uint256 freeRegistrationsNumber;
  uint256 referrerReward;
  uint256 referralDiscount;
  bool isActive;
  address registrar;
  uint24 ttl;
  uint256 registerSize;
}</code></pre>
<h3 id="record">Record<a class="headerlink" href="#record" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct Record {
  address wallet;
  bytes32 name;
  bytes32 id;
  uint96 nonce;
  bytes32 domainName;
}</code></pre>
<h3 id="multipass_storage_position">MULTIPASS_STORAGE_POSITION<a class="headerlink" href="#multipass_storage_position" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 MULTIPASS_STORAGE_POSITION</code></pre>
<h3 id="domainnameservice">DomainNameService<a class="headerlink" href="#domainnameservice" title="Permanent link">#</a></h3>
<p><em>The domain name of the registrar.</em></p>
<h4 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">#</a></h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-solidity">struct DomainNameService {
  struct LibMultipass.Domain properties;
  mapping(bytes32 =&gt; address) idToAddress;
  mapping(bytes32 =&gt; uint96) nonce;
  mapping(address =&gt; bytes32) addressToId;
  mapping(bytes32 =&gt; bytes32) nameToId;
  mapping(bytes32 =&gt; bytes32) idToName;
}</code></pre>
<h3 id="multipassstoragestruct">MultipassStorageStruct<a class="headerlink" href="#multipassstoragestruct" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct MultipassStorageStruct {
  mapping(uint256 =&gt; struct LibMultipass.DomainNameService) domains;
  mapping(bytes32 =&gt; uint256) domainNameToIndex;
  uint256 numDomains;
}</code></pre>
<h3 id="multipassstorage">MultipassStorage<a class="headerlink" href="#multipassstorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function MultipassStorage() internal pure returns (struct LibMultipass.MultipassStorageStruct es)</code></pre>
<h3 id="_typehash">_TYPEHASH<a class="headerlink" href="#_typehash" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 _TYPEHASH</code></pre>
<h3 id="_typehash_referral">_TYPEHASH_REFERRAL<a class="headerlink" href="#_typehash_referral" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 _TYPEHASH_REFERRAL</code></pre>
<h3 id="_checkstringfits32b">_checkStringFits32b<a class="headerlink" href="#_checkstringfits32b" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _checkStringFits32b(string value) internal pure returns (bool)</code></pre>
<h3 id="_checknotempty">_checkNotEmpty<a class="headerlink" href="#_checknotempty" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _checkNotEmpty(bytes32 value) internal pure returns (bool)</code></pre>
<h3 id="resolvedomainindex">resolveDomainIndex<a class="headerlink" href="#resolvedomainindex" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function resolveDomainIndex(bytes32 domainName) internal view returns (uint256)</code></pre>
<h3 id="_getdomainstorage">_getDomainStorage<a class="headerlink" href="#_getdomainstorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _getDomainStorage(bytes32 domainName) internal view returns (struct LibMultipass.DomainNameService)</code></pre>
<h3 id="_initializedomain">_initializeDomain<a class="headerlink" href="#_initializedomain" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) internal</code></pre>
<h3 id="_getmodifyprice">_getModifyPrice<a class="headerlink" href="#_getmodifyprice" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _getModifyPrice(struct LibMultipass.Record userRecord) internal view returns (uint256)</code></pre>
<h3 id="resolverecord_2">resolveRecord<a class="headerlink" href="#resolverecord_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function resolveRecord(struct LibMultipass.NameQuery query) internal view returns (bool, struct LibMultipass.Record)</code></pre>
<p><em>resolves Record of name query in to status and identity</em></p>
<h3 id="_setrecord">_setRecord<a class="headerlink" href="#_setrecord" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _setRecord(struct LibMultipass.DomainNameService domain, struct LibMultipass.Record record) internal</code></pre>
<p><em>this function bears no security checks, it will ignore nonce in arg and will increment
  nonce value stored in domain instread</em></p>
<h3 id="queryfromrecord">queryFromRecord<a class="headerlink" href="#queryfromrecord" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function queryFromRecord(struct LibMultipass.Record _record, bytes32 _domainName) internal pure returns (struct LibMultipass.NameQuery)</code></pre>
<h3 id="shouldregisterforfree">shouldRegisterForFree<a class="headerlink" href="#shouldregisterforfree" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function shouldRegisterForFree(struct LibMultipass.DomainNameService domain) internal view returns (bool)</code></pre>
<h3 id="_registernew">_registerNew<a class="headerlink" href="#_registernew" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _registerNew(struct LibMultipass.Record newRecord, struct LibMultipass.DomainNameService domain) internal</code></pre>
<h3 id="_getcontractstate">_getContractState<a class="headerlink" href="#_getcontractstate" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _getContractState() internal view returns (uint256)</code></pre>
<h3 id="_getdomainstoragebyidx">_getDomainStorageByIdx<a class="headerlink" href="#_getdomainstoragebyidx" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _getDomainStorageByIdx(uint256 index) internal view returns (struct LibMultipass.DomainNameService)</code></pre>
<h2 id="quadraticvotingerror">quadraticVotingError<a class="headerlink" href="#quadraticvotingerror" title="Permanent link">#</a></h2>
<pre class="highlight"><code class="language-solidity">error quadraticVotingError(string paramter, uint256 arg, uint256 arg2)</code></pre>
<h2 id="libquadraticvoting">LibQuadraticVoting<a class="headerlink" href="#libquadraticvoting" title="Permanent link">#</a></h2>
<p><em>A library for quadratic voting calculations.</em></p>
<h3 id="qvotingstruct">qVotingStruct<a class="headerlink" href="#qvotingstruct" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct qVotingStruct {
  uint256 voteCredits;
  uint256 maxQuadraticPoints;
  uint256 minQuadraticPositons;
}</code></pre>
<h3 id="precomputevalues">precomputeValues<a class="headerlink" href="#precomputevalues" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function precomputeValues(uint256 voteCredits, uint256 minExpectedVoteItems) internal pure returns (struct LibQuadraticVoting.qVotingStruct)</code></pre>
<p>_Precomputes the values for quadratic voting. <code>voteCredits</code> is the total number of vote credits. <code>minExpectedVoteItems</code> is the minimum expected number of vote items.</p>
<p>Returns:</p>
<ul>
<li>A <code>qVotingStruct</code> containing the precomputed values._</li>
</ul>
<h3 id="computescoresbyvpindex">computeScoresByVPIndex<a class="headerlink" href="#computescoresbyvpindex" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function computeScoresByVPIndex(struct LibQuadraticVoting.qVotingStruct q, uint256[][] VotersVotes, bool[] voterVoted, uint256 notVotedGivesEveyone, uint256 proposalsLength) internal pure returns (uint256[])</code></pre>
<p>_Computes the scores for each proposal by voter preference index. <code>q</code> is the precomputed quadratic voting values. <code>VotersVotes</code> is a 2D array of votes, where each row corresponds to a voter and each column corresponds to a proposal. <code>voterVoted</code> is an array indicating whether each voter has voted. <code>notVotedGivesEveyone</code> is the number of points to distribute to each proposal for each voter that did not vote. <code>proposalsLength</code> is the number of proposals.</p>
<p>Returns:</p>
<ul>
<li>An array of scores for each proposal._</li>
</ul>
<h2 id="librankify">LibRankify<a class="headerlink" href="#librankify" title="Permanent link">#</a></h2>
<h3 id="comparestrings">compareStrings<a class="headerlink" href="#comparestrings" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function compareStrings(string a, string b) internal pure returns (bool)</code></pre>
<p>_Compares two strings for equality. <code>a</code> and <code>b</code> are the strings to compare.</p>
<p>Returns:</p>
<ul>
<li><code>true</code> if the strings are equal, <code>false</code> otherwise._</li>
</ul>
<h3 id="getgamestorage">getGameStorage<a class="headerlink" href="#getgamestorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getGameStorage(uint256 gameId) internal view returns (struct IRankifyInstanceCommons.RInstance game)</code></pre>
<p>_Returns the game storage for the given game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>The game storage for <code>gameId</code>._</li>
</ul>
<h3 id="rinstancestorage_2">RInstanceStorage<a class="headerlink" href="#rinstancestorage_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog)</code></pre>
<p>_Returns the Rankify InstanceSettings storage.</p>
<p>Returns:</p>
<ul>
<li>The RInstanceSettings storage._</li>
</ul>
<h3 id="_proposal_proof_typehash">_PROPOSAL_PROOF_TYPEHASH<a class="headerlink" href="#_proposal_proof_typehash" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 _PROPOSAL_PROOF_TYPEHASH</code></pre>
<h3 id="_vote_proof_typehash">_VOTE_PROOF_TYPEHASH<a class="headerlink" href="#_vote_proof_typehash" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 _VOTE_PROOF_TYPEHASH</code></pre>
<h3 id="_vote_submit_proof_typehash">_VOTE_SUBMIT_PROOF_TYPEHASH<a class="headerlink" href="#_vote_submit_proof_typehash" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 _VOTE_SUBMIT_PROOF_TYPEHASH</code></pre>
<h3 id="enforceisinitialized">enforceIsInitialized<a class="headerlink" href="#enforceisinitialized" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function enforceIsInitialized() internal view</code></pre>
<p>_Ensures that the contract is initialized.</p>
<p>Requirements:</p>
<ul>
<li>The contract must be initialized._</li>
</ul>
<h3 id="enforcegameexists">enforceGameExists<a class="headerlink" href="#enforcegameexists" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function enforceGameExists(uint256 gameId) internal view</code></pre>
<p>_Ensures that the game with the given ID exists. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist._</li>
</ul>
<h3 id="newgame">newGame<a class="headerlink" href="#newgame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function newGame(uint256 gameId, address gameMaster, uint256 gameRank, address creator) internal</code></pre>
<p>_Creates a new game with the given parameters. <code>gameId</code> is the ID of the new game. <code>gameMaster</code> is the address of the game master. <code>gameRank</code> is the rank of the game. <code>creator</code> is the address of the creator of the game.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must not already exist.</li>
<li><code>gameRank</code> must not be 0.</li>
<li>If the game price is not 0, the <code>creator</code> must have approved this contract to transfer the game price amount of the game payment token on their behalf.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Creates a new game with <code>gameId</code>.</li>
<li>Transfers the game price amount of the game payment token from <code>creator</code> to this contract.</li>
<li>Sets the payments balance of the game to the game price.</li>
<li>Sets the creator of the game to <code>creator</code>.</li>
<li>Increments the number of games.</li>
<li>Sets the rank of the game to <code>gameRank</code>.</li>
<li>Mints new rank tokens._</li>
</ul>
<h3 id="enforceisgamecreator">enforceIsGameCreator<a class="headerlink" href="#enforceisgamecreator" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function enforceIsGameCreator(uint256 gameId, address candidate) internal view</code></pre>
<p>_Ensures that the candidate is the creator of the game with the given ID. <code>gameId</code> is the ID of the game. <code>candidate</code> is the address of the candidate.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
<li><code>candidate</code> must be the creator of the game._</li>
</ul>
<h3 id="enforceisgm">enforceIsGM<a class="headerlink" href="#enforceisgm" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function enforceIsGM(uint256 gameId, address candidate) internal view</code></pre>
<p>_Ensures that the candidate is the game master of the game with the given ID. <code>gameId</code> is the ID of the game. <code>candidate</code> is the address of the candidate.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
<li><code>candidate</code> must be the game master of the game._</li>
</ul>
<h3 id="joingame_1">joinGame<a class="headerlink" href="#joingame_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function joinGame(uint256 gameId, address player) internal</code></pre>
<p>_Allows a player to join a game. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
<li>If the join game price is not 0, the <code>player</code> must have approved this contract to transfer the join game price amount of the game payment token on their behalf.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Transfers the join game price amount of the game payment token from <code>player</code> to this contract.</li>
<li>Increases the payments balance of the game by the join game price.</li>
<li>Adds <code>player</code> to the game._</li>
</ul>
<h3 id="closegame">closeGame<a class="headerlink" href="#closegame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function closeGame(uint256 gameId, address beneficiary, function (uint256,address) playersGameEndedCallback) internal returns (uint256[])</code></pre>
<p>_Closes the game with the given ID and transfers the game's balance to the beneficiary. <code>gameId</code> is the ID of the game. <code>beneficiary</code> is the address to transfer the game's balance to. <code>playersGameEndedCallback</code> is a callback function to call for each player when the game ends.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Emits rank rewards for the game.</li>
<li>Removes and unlocks each player from the game.</li>
<li>Calls <code>playersGameEndedCallback</code> for each player.</li>
<li>Transfers the game's balance to <code>beneficiary</code>.</li>
</ul>
<p>Returns:</p>
<ul>
<li>The final scores of the game._</li>
</ul>
<h3 id="quitgame">quitGame<a class="headerlink" href="#quitgame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function quitGame(uint256 gameId, address player, bool slash, function (uint256,address) onPlayerLeftCallback) internal</code></pre>
<p>_Allows a player to quit a game. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player. <code>slash</code> is a boolean indicating whether to slash the player's payment refund. <code>onPlayerLeftCallback</code> is a callback function to call when the player leaves.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>If the join game price is not 0, transfers a refund to <code>player</code> and decreases the game's payments balance by the refund amount.</li>
<li>Removes and unlocks <code>player</code> from the game.</li>
<li>Calls <code>onPlayerLeftCallback</code> for <code>player</code>._</li>
</ul>
<h3 id="cancelgame_1">cancelGame<a class="headerlink" href="#cancelgame_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function cancelGame(uint256 gameId, function (uint256,address) onPlayerLeftCallback, address beneficiary) internal</code></pre>
<p>_Cancels the game with the given ID, refunds half of the game's payment to the game creator, and transfers the remaining balance to the beneficiary. <code>gameId</code> is the ID of the game. <code>onPlayerLeftCallback</code> is a callback function to call for each player when they leave. <code>beneficiary</code> is the address to transfer the remaining balance to.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Calls <code>quitGame</code> for each player in the game.</li>
<li>Transfers half of the game's payment to the game creator.</li>
<li>Decreases the game's payments balance by the refund amount.</li>
<li>Transfers the remaining balance of the game to <code>beneficiary</code>.</li>
<li>Deletes the game._</li>
</ul>
<h3 id="fulfillrankrq">fulfillRankRq<a class="headerlink" href="#fulfillrankrq" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function fulfillRankRq(uint256 gameId, address player) internal</code></pre>
<p>_Fulfills the rank requirement for a player to join a game. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player.</p>
<p>Modifies:</p>
<ul>
<li>Locks the rank token(s) of <code>player</code> in the rank token contract.</li>
<li>If the game has additional ranks, locks the additional ranks of <code>player</code> in the respective rank token contracts._</li>
</ul>
<h3 id="emitrankrewards">emitRankRewards<a class="headerlink" href="#emitrankrewards" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function emitRankRewards(uint256 gameId, address[] leaderboard) internal</code></pre>
<p>_Emits rank rewards to the top addresses in the leaderboard for each rank in the game. <code>gameId</code> is the ID of the game. <code>leaderboard</code> is an array of addresses representing the leaderboard.</p>
<p>Modifies:</p>
<ul>
<li>Calls <code>emitRankReward</code> for the main rank and each additional rank in the game._</li>
</ul>
<h3 id="removeandunlockplayer">removeAndUnlockPlayer<a class="headerlink" href="#removeandunlockplayer" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function removeAndUnlockPlayer(uint256 gameId, address player) internal</code></pre>
<p>_Removes a player from a game and unlocks their rank tokens. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player to be removed.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Removes <code>player</code> from the game.</li>
<li>If the game rank is greater than 1, unlocks the game rank token for <code>player</code> in the rank token contract and unlocks each additional rank token for <code>player</code> in the respective rank token contracts._</li>
</ul>
<h3 id="tryplayermove">tryPlayerMove<a class="headerlink" href="#tryplayermove" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function tryPlayerMove(uint256 gameId, address player) internal returns (bool)</code></pre>
<p>_Tries to make a move for a player in a game. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player.
The "move" is considered to be a state when player has made all actions he could in the given turn.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>If the player has not voted and a vote is expected, or if the player has not made a proposal and a proposal is expected, does not make a move and returns <code>false</code>.</li>
<li>Otherwise, makes a move for <code>player</code> and returns <code>true</code>._</li>
</ul>
<h3 id="calculatescoresquadratic">calculateScoresQuadratic<a class="headerlink" href="#calculatescoresquadratic" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function calculateScoresQuadratic(uint256 gameId, uint256[][] votesRevealed, uint256[] proposerIndicies) internal returns (uint256[], uint256[])</code></pre>
<p>_Calculates the scores using a quadratic formula based on the revealed votes and proposer indices. <code>gameId</code> is the ID of the game. <code>votesRevealed</code> is an array of revealed votes. <code>proposerIndicies</code> is an array of proposer indices that links proposals to index in getPlayers().</p>
<p>Returns:</p>
<ul>
<li>An array of updated scores for each player.</li>
<li>An array of scores calculated for the current round._</li>
</ul>
<h2 id="libreentrancyguard">LibReentrancyGuard<a class="headerlink" href="#libreentrancyguard" title="Permanent link">#</a></h2>
<h3 id="tbg_storage_position">TBG_STORAGE_POSITION<a class="headerlink" href="#tbg_storage_position" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 TBG_STORAGE_POSITION</code></pre>
<h3 id="reentrancyguardstruct">ReentrancyGuardStruct<a class="headerlink" href="#reentrancyguardstruct" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct ReentrancyGuardStruct {
  bool _entered;
}</code></pre>
<h3 id="reentrancyguardstorage">reentrancyGuardStorage<a class="headerlink" href="#reentrancyguardstorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function reentrancyGuardStorage() internal pure returns (struct LibReentrancyGuard.ReentrancyGuardStruct ds)</code></pre>
<h2 id="libtbg">LibTBG<a class="headerlink" href="#libtbg" title="Permanent link">#</a></h2>
<p>_Library for managing turn-based games.
It is designed to be used as a base library for games, and provides the following functionality:
- setting game settings such as time per turn, max players, min players, etc as well as perform score and leaderboard tracking</p>
<p>Limitations:
- It is assumed there is only one game per player
- It is assumed there is only on game master per game</p>
<p><strong><em>WARNING</em></strong> Some limitations:
- This library is still under development and its interfaces may change.
- getting game data (which has own storage assigement and can be encapsulated from library) however there is no storage slot collision checks in place_</p>
<h3 id="gamesettings">GameSettings<a class="headerlink" href="#gamesettings" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct GameSettings {
  uint256 timePerTurn;
  uint256 maxPlayersSize;
  uint256 minPlayersSize;
  uint256 timeToJoin;
  uint256 maxTurns;
  uint256 numWinners;
  uint256 voteCredits;
  string subject;
}</code></pre>
<h3 id="gameinstance">GameInstance<a class="headerlink" href="#gameinstance" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct GameInstance {
  address gameMaster;
  uint256 currentTurn;
  uint256 turnStartedAt;
  uint256 registrationOpenAt;
  bool hasStarted;
  bool hasEnded;
  struct EnumerableSet.AddressSet players;
  mapping(address =&gt; bool) madeMove;
  uint256 numPlayersMadeMove;
  mapping(address =&gt; uint256) score;
  bytes32 implemenationStoragePointer;
  bool isOvertime;
  address[] leaderboard;
}</code></pre>
<h3 id="tbgstoragestruct">TBGStorageStruct<a class="headerlink" href="#tbgstoragestruct" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">struct TBGStorageStruct {
  struct LibTBG.GameSettings settings;
  mapping(uint256 =&gt; struct LibTBG.GameInstance) games;
  mapping(address =&gt; uint256) playerInGame;
  uint256 totalGamesCreated;
}</code></pre>
<h3 id="tbg_storage_position_1">TBG_STORAGE_POSITION<a class="headerlink" href="#tbg_storage_position_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 TBG_STORAGE_POSITION</code></pre>
<h3 id="implementation_storage_position">IMPLEMENTATION_STORAGE_POSITION<a class="headerlink" href="#implementation_storage_position" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">bytes32 IMPLEMENTATION_STORAGE_POSITION</code></pre>
<h3 id="tbgstorage">TBGStorage<a class="headerlink" href="#tbgstorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function TBGStorage() internal pure returns (struct LibTBG.TBGStorageStruct es)</code></pre>
<h3 id="_getgame">_getGame<a class="headerlink" href="#_getgame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _getGame(uint256 gameId) internal view returns (struct LibTBG.GameInstance)</code></pre>
<h3 id="init">init<a class="headerlink" href="#init" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function init(struct LibTBG.GameSettings settings) internal</code></pre>
<p>_Initializes the game with the provided settings. <code>settings</code> is the settings for the game.</p>
<p>Requirements:</p>
<ul>
<li><code>settings.timePerTurn</code> must not be zero.</li>
<li><code>settings.maxPlayersSize</code> must not be zero.</li>
<li><code>settings.minPlayersSize</code> must be at least 2.</li>
<li><code>settings.maxTurns</code> must not be zero.</li>
<li><code>settings.numWinners</code> must not be zero and must be less than <code>settings.minPlayersSize</code>.</li>
<li><code>settings.timeToJoin</code> must not be zero.</li>
<li><code>settings.maxPlayersSize</code> must not be less than <code>settings.minPlayersSize</code>.</li>
<li><code>settings.subject</code> must not be an empty string.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the settings of the game to <code>settings</code>._</li>
</ul>
<h3 id="creategame_3">createGame<a class="headerlink" href="#creategame_3" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function createGame(uint256 gameId, address gm) internal</code></pre>
<p>_Creates a new game with the provided game ID and game master. <code>gameId</code> is the ID of the game. <code>gm</code> is the address of the game master.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must not already exist.</li>
<li><code>gm</code> must not be the zero address.</li>
<li><code>gameId</code> must not be zero.</li>
<li>The game master of the game with <code>gameId</code> must be the zero address.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the game master of the game with <code>gameId</code> to <code>gm</code>.</li>
<li>Increments the total number of games created._</li>
</ul>
<h3 id="deletegame">deleteGame<a class="headerlink" href="#deletegame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function deleteGame(uint256 gameId) internal</code></pre>
<p>_Deletes a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the game master, current turn, hasEnded, hasStarted,
  implementationStoragePointer, isOvertime, leaderboard, numPlayersMadeMove,
  players, registrationOpenAt, and turnStartedAt of the game with <code>gameId</code>
  to their initial values.</li>
<li>Sets the score and madeMove of each player in the game with <code>gameId</code>
  to their initial values._</li>
</ul>
<h3 id="canbejoined">canBeJoined<a class="headerlink" href="#canbejoined" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function canBeJoined(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if a game with the provided game ID can be joined. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the game can be joined._</li>
</ul>
<h3 id="addplayer">addPlayer<a class="headerlink" href="#addplayer" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function addPlayer(uint256 gameId, address participant) internal</code></pre>
<p>_Adds a player to a game with the provided game ID. <code>gameId</code> is the ID of the game. <code>participant</code> is the address of the player.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
<li><code>participant</code> must not already be in a game.</li>
<li>The number of players in the game with <code>gameId</code> must be less than the maximum number of players.</li>
<li>The game with <code>gameId</code> must be joinable.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Adds <code>participant</code> to the players of the game with <code>gameId</code>.</li>
<li>Sets the madeMove of <code>participant</code> in the game with <code>gameId</code> to false.</li>
<li>Sets the game of <code>participant</code> to <code>gameId</code>._</li>
</ul>
<h3 id="isplayeringame">isPlayerInGame<a class="headerlink" href="#isplayeringame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isPlayerInGame(uint256 gameId, address player) internal view returns (bool)</code></pre>
<p>_Checks if a player is in a game with the provided game ID. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the player is in the game._</li>
</ul>
<h3 id="removeplayer">removePlayer<a class="headerlink" href="#removeplayer" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function removePlayer(uint256 gameId, address participant) internal</code></pre>
<p>_Removes a player from a game with the provided game ID. <code>gameId</code> is the ID of the game. <code>participant</code> is the address of the player.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
<li><code>participant</code> must be in the game with <code>gameId</code>.</li>
<li>The game with <code>gameId</code> must not have started or must have ended.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the game of <code>participant</code> to 0.</li>
<li>Removes <code>participant</code> from the players of the game with <code>gameId</code>._</li>
</ul>
<h3 id="isturntimedout">isTurnTimedOut<a class="headerlink" href="#isturntimedout" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isTurnTimedOut(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if the current turn in a game with the provided game ID has timed out. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li><code>gameId</code> must not be zero.</li>
<li>The game with <code>gameId</code> must have started.</li>
</ul>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the current turn has timed out._</li>
</ul>
<h3 id="gameexists">gameExists<a class="headerlink" href="#gameexists" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function gameExists(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if a game with the provided game ID exists. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the game exists._</li>
</ul>
<h3 id="enforcehasstarted">enforceHasStarted<a class="headerlink" href="#enforcehasstarted" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function enforceHasStarted(uint256 gameId) internal view</code></pre>
<p>_Enforces that a game with the provided game ID has started. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li><code>gameId</code> must not be zero.</li>
<li>The game with <code>gameId</code> must have started._</li>
</ul>
<h3 id="canendturn_1">canEndTurn<a class="headerlink" href="#canendturn_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function canEndTurn(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Enforces that a game with the provided game ID has started. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li><code>gameId</code> must not be zero.</li>
<li>The game with <code>gameId</code> must have started._</li>
</ul>
<h3 id="canendturnearly">canEndTurnEarly<a class="headerlink" href="#canendturnearly" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function canEndTurnEarly(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if the current turn in a game with the provided game ID can end early. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the current turn can end early._</li>
</ul>
<h3 id="onlyinturntime">onlyInTurnTime<a class="headerlink" href="#onlyinturntime" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">modifier onlyInTurnTime(uint256 gameId)</code></pre>
<p>_Modifier that requires the current turn in a game with the provided game ID to be able to end. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li>The current turn in the game with <code>gameId</code> must be able to end._</li>
</ul>
<h3 id="onlywhenturncanend">onlyWhenTurnCanEnd<a class="headerlink" href="#onlywhenturncanend" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">modifier onlyWhenTurnCanEnd(uint256 gameId)</code></pre>
<h3 id="_clearcurrentmoves">_clearCurrentMoves<a class="headerlink" href="#_clearcurrentmoves" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _clearCurrentMoves(struct LibTBG.GameInstance game) internal</code></pre>
<p>_Clears the current moves in a game. <code>game</code> is the game.</p>
<p>Modifies:</p>
<ul>
<li>Sets the madeMove of each player in <code>game</code> to false._</li>
</ul>
<h3 id="_resetplayerstates">_resetPlayerStates<a class="headerlink" href="#_resetplayerstates" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _resetPlayerStates(struct LibTBG.GameInstance game) internal</code></pre>
<p>_Resets the states of the players in a game. <code>game</code> is the game.</p>
<p>Modifies:</p>
<ul>
<li>Sets the madeMove and score of each player in <code>game</code> to their initial values._</li>
</ul>
<h3 id="setscore">setScore<a class="headerlink" href="#setscore" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setScore(uint256 gameId, address player, uint256 value) internal</code></pre>
<p>_Sets the score of a player in a game with the provided game ID. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player. <code>value</code> is the score.</p>
<p>Requirements:</p>
<ul>
<li><code>player</code> must be in the game with <code>gameId</code>.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the score of <code>player</code> in the game with <code>gameId</code> to <code>value</code>._</li>
</ul>
<h3 id="getscore">getScore<a class="headerlink" href="#getscore" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getScore(uint256 gameId, address player) internal view returns (uint256)</code></pre>
<p>_Gets the score of a player in a game with the provided game ID. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player.</p>
<p>Returns:</p>
<ul>
<li>The score of <code>player</code> in the game with <code>gameId</code>._</li>
</ul>
<h3 id="getscores_1">getScores<a class="headerlink" href="#getscores_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getScores(uint256 gameId) internal view returns (address[], uint256[])</code></pre>
<p>_Gets the scores of the players in a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>An array of the addresses of the players in the game with <code>gameId</code>.</li>
<li>An array of the scores of the players in the game with <code>gameId</code>._</li>
</ul>
<h3 id="openregistration_1">openRegistration<a class="headerlink" href="#openregistration_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function openRegistration(uint256 gameId) internal</code></pre>
<p>_Opens registration for a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the registrationOpenAt of the game with <code>gameId</code> to the current block timestamp._</li>
</ul>
<h3 id="isregistrationopen_1">isRegistrationOpen<a class="headerlink" href="#isregistrationopen_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isRegistrationOpen(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if registration is open for a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether registration is open for the game._</li>
</ul>
<h3 id="canstart">canStart<a class="headerlink" href="#canstart" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function canStart(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if a game with the provided game ID can start. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the game can start._</li>
</ul>
<h3 id="canstartearly">canStartEarly<a class="headerlink" href="#canstartearly" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function canStartEarly(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if a game with the provided game ID can start early. <code>gameId</code> is the ID of the game.
By "early" it is assumed that time to join has not yet passed, but it's already cap players limit reached.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the game can start early._</li>
</ul>
<h3 id="startgameearly">startGameEarly<a class="headerlink" href="#startgameearly" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function startGameEarly(uint256 gameId) internal</code></pre>
<p>_Starts a game with the provided game ID early. <code>gameId</code> is the ID of the game.
By "early" it is assumed that time to join has not yet passed, but it's already cap players limit reached.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
<li>The game with <code>gameId</code> must not have started.</li>
<li>The game with <code>gameId</code> must have opened registration.</li>
<li>The number of players in the game with <code>gameId</code> must be greater than or equal to the minimum number of players.</li>
<li>The number of players in the game with <code>gameId</code> must be equal to the maximum number of players or the current block timestamp must be greater than the registration open time plus the time to join.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with <code>gameId</code> to their new values.</li>
<li>Resets the states of the players in the game with <code>gameId</code>._</li>
</ul>
<h3 id="startgame_1">startGame<a class="headerlink" href="#startgame_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function startGame(uint256 gameId) internal</code></pre>
<p>_Starts a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must exist.</li>
<li>The game with <code>gameId</code> must not have started.</li>
<li>The game with <code>gameId</code> must have opened registration.</li>
<li>The current block timestamp must be greater than the registration open time plus the time to join.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with <code>gameId</code> to their new values.</li>
<li>Resets the states of the players in the game with <code>gameId</code>._</li>
</ul>
<h3 id="getturn_1">getTurn<a class="headerlink" href="#getturn_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getTurn(uint256 gameId) internal view returns (uint256)</code></pre>
<p>_Gets the current turn of a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>The current turn of the game with <code>gameId</code>._</li>
</ul>
<h3 id="getgm_1">getGM<a class="headerlink" href="#getgm_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getGM(uint256 gameId) internal view returns (address)</code></pre>
<p>_Gets the game master of a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>The game master of the game with <code>gameId</code>._</li>
</ul>
<h3 id="islastturn_1">isLastTurn<a class="headerlink" href="#islastturn_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isLastTurn(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if the current turn is the last turn in a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the current turn is the last turn in the game._</li>
</ul>
<h3 id="isgameover_1">isGameOver<a class="headerlink" href="#isgameover_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isGameOver(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if a game with the provided game ID is over. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the game is over._</li>
</ul>
<h3 id="enforceisnotover">enforceIsNotOver<a class="headerlink" href="#enforceisnotover" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function enforceIsNotOver(uint256 gameId) internal view</code></pre>
<p>_Enforces that a game with the provided game ID is not over. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must not be over._</li>
</ul>
<h3 id="playermove">playerMove<a class="headerlink" href="#playermove" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function playerMove(uint256 gameId, address player) internal</code></pre>
<p>_Records a player's move in a game with the provided game ID. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must have started.</li>
<li>The game with <code>gameId</code> must not be over.</li>
<li><code>player</code> must not have made a move in the current turn of the game with <code>gameId</code>.</li>
<li><code>player</code> must be in the game with <code>gameId</code>.</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Sets the madeMove of <code>player</code> in the game with <code>gameId</code> to true.</li>
<li>Increments the numPlayersMadeMove of the game with <code>gameId</code>._</li>
</ul>
<h3 id="isplayerturncomplete_1">isPlayerTurnComplete<a class="headerlink" href="#isplayerturncomplete_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isPlayerTurnComplete(uint256 gameId, address player) internal view returns (bool)</code></pre>
<h3 id="enforceisplayinggame">enforceIsPlayingGame<a class="headerlink" href="#enforceisplayinggame" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function enforceIsPlayingGame(uint256 gameId, address player) internal view</code></pre>
<p>_Enforces that a player is in a game with the provided game ID. <code>gameId</code> is the ID of the game. <code>player</code> is the address of the player.</p>
<p>Requirements:</p>
<ul>
<li><code>player</code> must be in the game with <code>gameId</code>._</li>
</ul>
<h3 id="hasstarted">hasStarted<a class="headerlink" href="#hasstarted" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function hasStarted(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if a game with the provided game ID has started. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the game has started._</li>
</ul>
<h3 id="getleaderboard">getLeaderBoard<a class="headerlink" href="#getleaderboard" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getLeaderBoard(uint256 gameId) internal view returns (address[])</code></pre>
<p>_Gets the leaderboard of a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>An array of the addresses of the players in the game with <code>gameId</code>, sorted by score._</li>
</ul>
<h3 id="nextturn">nextTurn<a class="headerlink" href="#nextturn" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function nextTurn(uint256 gameId) internal returns (bool, bool, bool)</code></pre>
<p>_Advances to the next turn in a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li>The game with <code>gameId</code> must be able to end the current turn early. (all players have moved or the turn has timed out)</li>
</ul>
<p>Modifies:</p>
<ul>
<li>Clears the current moves in the game with <code>gameId</code>.</li>
<li>Increments the currentTurn of the game with <code>gameId</code>.</li>
<li>Sets the turnStartedAt of the game with <code>gameId</code> to the current block timestamp.</li>
<li>If the current turn is the last turn or the game with <code>gameId</code> is in overtime, checks if the game is a tie and sets the isOvertime of the game with <code>gameId</code> to the result.</li>
<li>Sets the hasEnded of the game with <code>gameId</code> to whether the game is over.</li>
</ul>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the current turn is the last turn.</li>
<li>A boolean indicating whether the game is a tie.</li>
<li>A boolean indicating whether the game is over._</li>
</ul>
<h3 id="getdatastorage">getDataStorage<a class="headerlink" href="#getdatastorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getDataStorage() internal pure returns (bytes32 pointer)</code></pre>
<p>_Gets the data storage pointer.</p>
<p>Returns:</p>
<ul>
<li>The data storage pointer._</li>
</ul>
<h3 id="getgamedatastorage">getGameDataStorage<a class="headerlink" href="#getgamedatastorage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getGameDataStorage(uint256 gameId) internal view returns (bytes32 pointer)</code></pre>
<p>_Gets the game data storage pointer of a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>The game data storage pointer of the game with <code>gameId</code>._</li>
</ul>
<h3 id="getplayersnumber">getPlayersNumber<a class="headerlink" href="#getplayersnumber" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPlayersNumber(uint256 gameId) internal view returns (uint256)</code></pre>
<p>_Gets the number of players in a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>The number of players in the game with <code>gameId</code>._</li>
</ul>
<h3 id="getplayers_1">getPlayers<a class="headerlink" href="#getplayers_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPlayers(uint256 gameId) internal view returns (address[])</code></pre>
<p>_Gets the players in a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>An array of the addresses of the players in the game with <code>gameId</code>._</li>
</ul>
<h3 id="getgamesettings">getGameSettings<a class="headerlink" href="#getgamesettings" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getGameSettings() internal view returns (struct LibTBG.GameSettings)</code></pre>
<p>_Gets the game settings.</p>
<p>Returns:</p>
<ul>
<li>The game settings._</li>
</ul>
<h3 id="enforceispreregistrationstage">enforceIsPreRegistrationStage<a class="headerlink" href="#enforceispreregistrationstage" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function enforceIsPreRegistrationStage(uint256 gameId) internal view</code></pre>
<p>_Enforces that a game with the provided game ID is in the pre-registration stage. <code>gameId</code> is the ID of the game.</p>
<p>Requirements:</p>
<ul>
<li>Registration must not be open for the game with <code>gameId</code>.</li>
<li>The game with <code>gameId</code> must not have started._</li>
</ul>
<h3 id="addovertime">addOvertime<a class="headerlink" href="#addovertime" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function addOvertime(uint256 gameId) internal</code></pre>
<p>_Adds overtime to a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Modifies:</p>
<ul>
<li>Sets the isOvertime of the game with <code>gameId</code> to true._</li>
</ul>
<h3 id="isovertime_1">isOvertime<a class="headerlink" href="#isovertime_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isOvertime(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if a game with the provided game ID is in overtime. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the game is in overtime._</li>
</ul>
<h3 id="resetovertime">resetOvertime<a class="headerlink" href="#resetovertime" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function resetOvertime(uint256 gameId) internal</code></pre>
<p>_Resets the overtime of a game with the provided game ID. <code>gameId</code> is the ID of the game.</p>
<p>Modifies:</p>
<ul>
<li>Sets the isOvertime of the game with <code>gameId</code> to false._</li>
</ul>
<h3 id="istie">isTie<a class="headerlink" href="#istie" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function isTie(uint256 gameId) internal view returns (bool)</code></pre>
<p>_Checks if a game with the provided game ID is a tie. <code>gameId</code> is the ID of the game.
Tie being defined as at least two of the top <code>numWinners</code> players having the same score.</p>
<p>Returns:</p>
<ul>
<li>A boolean indicating whether the game is a tie._</li>
</ul>
<h3 id="getplayersgame_1">getPlayersGame<a class="headerlink" href="#getplayersgame_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getPlayersGame(address player) internal view returns (uint256)</code></pre>
<p>_Gets the game ID of the game a player is in. <code>player</code> is the address of the player.</p>
<p>Returns:</p>
<ul>
<li>The game ID of the game <code>player</code> is in._</li>
</ul>
<h3 id="sortbyscore">sortByScore<a class="headerlink" href="#sortbyscore" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function sortByScore(uint256 gameId) internal view returns (address[], uint256[])</code></pre>
<p>_Sorts the players in a game with the provided game ID by score in descending order. <code>gameId</code> is the ID of the game.</p>
<p>Returns:</p>
<ul>
<li>An array of the addresses of the players in the game with <code>gameId</code>, sorted by score.</li>
<li>An array of the scores of the players in the game with <code>gameId</code>, sorted in descending order._</li>
</ul>
<h2 id="ranktoken">RankToken<a class="headerlink" href="#ranktoken" title="Permanent link">#</a></h2>
<h3 id="rank">rank<a class="headerlink" href="#rank" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">mapping(address =&gt; uint256) rank</code></pre>
<h3 id="toprank">topRank<a class="headerlink" href="#toprank" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">uint256 topRank</code></pre>
<h3 id="_levelupthreshold">_levelUpThreshold<a class="headerlink" href="#_levelupthreshold" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">uint256 _levelUpThreshold</code></pre>
<h3 id="onlyrankinginstance">onlyRankingInstance<a class="headerlink" href="#onlyrankinginstance" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">modifier onlyRankingInstance()</code></pre>
<h3 id="constructor_2">constructor<a class="headerlink" href="#constructor_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">constructor(string uri_, address owner_, string cURI, uint256 levelUpThreshold, address[] components, uint256[] componentWeights) public</code></pre>
<h3 id="getrankinginstance_1">getRankingInstance<a class="headerlink" href="#getrankinginstance_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getRankingInstance() public view returns (address)</code></pre>
<p>_Gets the ranking instance which can emit new rank updates and mint rank tokens.</p>
<p>Returns:</p>
<ul>
<li>The address of the ranking instance._</li>
</ul>
<h3 id="contracturi">contractURI<a class="headerlink" href="#contracturi" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function contractURI() public view returns (string)</code></pre>
<h3 id="seturi">setURI<a class="headerlink" href="#seturi" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setURI(string uri_) public</code></pre>
<h3 id="setcontracturi">setContractURI<a class="headerlink" href="#setcontracturi" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function setContractURI(string uri_) public</code></pre>
<h3 id="leader">Leader<a class="headerlink" href="#leader" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event Leader(address account, uint256 rank)</code></pre>
<h3 id="mint_1">mint<a class="headerlink" href="#mint_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function mint(address to, uint256 amount, uint256 level, bytes data) public</code></pre>
<h3 id="updaterankinginstance_1">updateRankingInstance<a class="headerlink" href="#updaterankinginstance_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function updateRankingInstance(address newRankingInstance) public</code></pre>
<p>_Updates the ranking instance. <code>newRankingInstance</code> is the address of the new ranking instance.</p>
<p>emits a <em>RankingInstanceUpdated</em> event._</p>
<h3 id="lock_2">lock<a class="headerlink" href="#lock_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function lock(address account, uint256 id, uint256 amount) public</code></pre>
<h3 id="unlock_2">unlock<a class="headerlink" href="#unlock_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function unlock(address account, uint256 id, uint256 amount) public</code></pre>
<h3 id="batchmint_1">batchMint<a class="headerlink" href="#batchmint_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) public</code></pre>
<p><em>Mints specified amounts of tokens to an account. <code>to</code> is the address of the account to mint the tokens to. <code>ids</code> is the array of IDs of the tokens to mint. <code>amounts</code> is the array of amounts of tokens to mint. <code>data</code> is the additional data.</em></p>
<h3 id="levelup_2">levelUp<a class="headerlink" href="#levelup_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function levelUp(address to, uint256 level, bytes data) public</code></pre>
<h3 id="findnewrank_1">findNewRank<a class="headerlink" href="#findnewrank_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function findNewRank(address account, uint256 oldRank) public view returns (uint256)</code></pre>
<p>_Finds the new rank of an account. <code>account</code> is the address of the account. <code>oldRank</code> is the old rank of the account.
It checks the balance of the account and returns the new rank that can be upgraded to.</p>
<p>Returns:</p>
<ul>
<li>The new rank of the account._</li>
</ul>
<h3 id="rankupdated">RankUpdated<a class="headerlink" href="#rankupdated" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">event RankUpdated(address account, uint256 rank)</code></pre>
<h3 id="_aftertokentransfer">_afterTokenTransfer<a class="headerlink" href="#_aftertokentransfer" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function _afterTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal</code></pre>
<p>_Hook that is called after any token transfer. This includes minting
and burning, as well as batched variants.</p>
<p>The same hook is called on both single and batched variants. For single
transfers, the length of the <code>id</code> and <code>amount</code> arrays will be 1.</p>
<p>Calling conditions (for each <code>id</code> and <code>amount</code> pair):</p>
<ul>
<li>When <code>from</code> and <code>to</code> are both non-zero, <code>amount</code> of <code>from</code>'s tokens
of token type <code>id</code> will be  transferred to <code>to</code>.</li>
<li>When <code>from</code> is zero, <code>amount</code> tokens of token type <code>id</code> will be minted
for <code>to</code>.</li>
<li>when <code>to</code> is zero, <code>amount</code> of <code>from</code>'s tokens of token type <code>id</code>
will be burned.</li>
<li><code>from</code> and <code>to</code> are never both zero.</li>
<li><code>ids</code> and <code>amounts</code> have the same, non-zero length.</li>
</ul>
<p>To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]._</p>
<h3 id="getaccountrank_1">getAccountRank<a class="headerlink" href="#getaccountrank_1" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function getAccountRank(address account) external view returns (uint256)</code></pre>
<p>_Gets the rank of an account. <code>account</code> is the address of the account.</p>
<p>Returns:</p>
<ul>
<li>The rank of the account._</li>
</ul>
<h3 id="supportsinterface">supportsInterface<a class="headerlink" href="#supportsinterface" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)</code></pre>
<h2 id="rankify">Rankify<a class="headerlink" href="#rankify" title="Permanent link">#</a></h2>
<h3 id="numtokens">numTokens<a class="headerlink" href="#numtokens" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">uint256 numTokens</code></pre>
<h3 id="constructor_3">constructor<a class="headerlink" href="#constructor_3" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">constructor(address owner) public</code></pre>
<h3 id="mint_2">mint<a class="headerlink" href="#mint_2" title="Permanent link">#</a></h3>
<pre class="highlight"><code class="language-solidity">function mint(address to, uint256 amount) public</code></pre>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/rankify-it" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
