{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Welcome/","text":"Rankify Basics # Project Overview # This project is implementation of the \"Continuous Voting\" protocol. Participants engage over extended periods in a series of rounds and instances, aiming to create a ladder where winners are selected based on their ability to propose ideas that their group accepts through blind voting. The goal is to develop a system that can be played indefinitely, fostering continuous engagement and idea generation.","title":"Rankify Basics"},{"location":"Welcome/#rankify-basics","text":"","title":"Rankify Basics"},{"location":"Welcome/#project-overview","text":"This project is implementation of the \"Continuous Voting\" protocol. Participants engage over extended periods in a series of rounds and instances, aiming to create a ladder where winners are selected based on their ability to propose ideas that their group accepts through blind voting. The goal is to develop a system that can be played indefinitely, fostering continuous engagement and idea generation.","title":"Project Overview"},{"location":"Welcome/governance/","text":"","title":"Governance"},{"location":"Welcome/tokens/","text":"Token types #","title":"Token types"},{"location":"Welcome/tokens/#token-types","text":"","title":"Token types"},{"location":"architecure/","text":"Smart contract infrastructure # The Rankify smart contract infrastructure is built upon a modular design, emphasizing trustless operations to facilitate progressive decentralization within organizations as well as mitigate some roadblocks on wider adoption of decentralized governance. Adhering to systems theory principles, the architecture can be understood as a black box, responding to stimuli inputs with defined output reactions, while its key feature is the support for recursive patterns, enabling iterative processes on both input and output levels. Including governing body, infrastructure as consisting of two main pieces: App Store : Registry of different ranking system applications that may be installed on cells Cell infrastructures : Dimensions for ranking that participants produce. The rankify community governing DAO and multi-sig in the image above can be seen as an instance of Cell infrastructure. Cells # A single cell is an autonomous governance unit, structured as an NxM matrix of inputs and outputs connected to a multisig-wallet. Each cell, representing a specific topic or workgroup, leverages a modular and customizable infrastructure consisting of: Rank NFT : A semi-fungible ERC1155 token signifying the bearer's rank within the subject. Governance Token : An ERC20 token used for governance, minted by exchanging Rank NFTs. DAO contract : OSx DAO Contract governed entirely by holders of the governance token. App Instance : Ranking app, implements the autonomous competence identification protocol. Multisig Wallet : A wallet adhering to the Gnosis ISafe , connecting governing bodies and facilitating decision-making. Protocol is modular and trends to support already existing multi-sig infrastructure as well as experimentation hence protocol deployed, established, and modified cells, that are referred as Primordial , Generated , and Mutated accordingly. Above diagram describes infrastructure Generated cells adhere, while diagram involving governing body (green blocks) on top of this page describes primordial cell, which yet has no Rank NFT asset to complete it, as well as it is not listed in any auto-generation registries. App store infrastructure # Rankify goal is to provide as generic and permissions approach as possible with yet a security guarantees between different DAO members that are translated trough curating own application infrastructure. Application infrastructure consist of: Repository Factory : Provides ability for applications to have versioned control. Repositories : Each repository contains access to versioned installers of an application. Registry : Source of trust that Rankify DAO puts attestations for repositories it supports. Factory # The App Factory serves as a source for app installations, guaranteeing deterministic logic source in deployed applications. This enables the creation of interconnected ecosystems where trust is built on a shared understanding of app functionality. Every app listed on any repositories must undergo Rankify curation, however other entities or individuals are welcome to start their own Factories as well. It follows the standards set by the OSx PluginFactory , while generalizing it in IVRepoFactory it preserves ability for seamless integration and compatibility within the broader ecosystem. Repositories # plantuml source=\"basic.puml\" '' This code is appended to the contents of basic.puml Goofy -> MickeyMouse: calls Goofy <-- MickeyMouse: responds The App Repositories are built upon the IRepository interface, which mirrors the functionality of the OSx IPluginRepo . It provides a secure versioned repository for versioned application implementations. Users of that repository can be sure that every time they request specific application version, same address will be returned. Registry # Unlike immutable Repositories, the Registry is a mutable source of trust, allowing external applications to verify attestations from Rankify on ENS . While developers can deploy their own Repository contracts freely, the DAO curates it's attestations, listing its own resources and community-approved third-party applications. Installer # To maximize flexibility for both users and developers, we anticipate that applications installed within organizations will often require internal separation. For instance, an organization might need to run two instances of the same application for different tournaments in different time zones. To accommodate this, a single application repository can support multiple instances. This instance creation process should be streamlined, even allowing community members to create instances independently without undergoing a formal voting process. To facilitate this, a specialized \"Installer\" application is provided. This application, authorized by the DAO, maintains a list of approved registries for instantiation, which can only be modified by the DAO. This simplifies the process for users to launch whitelisted applications, acting as a proxy between instances and the DAO contract.","title":"Smart contract infrastructure"},{"location":"architecure/#smart-contract-infrastructure","text":"The Rankify smart contract infrastructure is built upon a modular design, emphasizing trustless operations to facilitate progressive decentralization within organizations as well as mitigate some roadblocks on wider adoption of decentralized governance. Adhering to systems theory principles, the architecture can be understood as a black box, responding to stimuli inputs with defined output reactions, while its key feature is the support for recursive patterns, enabling iterative processes on both input and output levels. Including governing body, infrastructure as consisting of two main pieces: App Store : Registry of different ranking system applications that may be installed on cells Cell infrastructures : Dimensions for ranking that participants produce. The rankify community governing DAO and multi-sig in the image above can be seen as an instance of Cell infrastructure.","title":"Smart contract infrastructure"},{"location":"architecure/#cells","text":"A single cell is an autonomous governance unit, structured as an NxM matrix of inputs and outputs connected to a multisig-wallet. Each cell, representing a specific topic or workgroup, leverages a modular and customizable infrastructure consisting of: Rank NFT : A semi-fungible ERC1155 token signifying the bearer's rank within the subject. Governance Token : An ERC20 token used for governance, minted by exchanging Rank NFTs. DAO contract : OSx DAO Contract governed entirely by holders of the governance token. App Instance : Ranking app, implements the autonomous competence identification protocol. Multisig Wallet : A wallet adhering to the Gnosis ISafe , connecting governing bodies and facilitating decision-making. Protocol is modular and trends to support already existing multi-sig infrastructure as well as experimentation hence protocol deployed, established, and modified cells, that are referred as Primordial , Generated , and Mutated accordingly. Above diagram describes infrastructure Generated cells adhere, while diagram involving governing body (green blocks) on top of this page describes primordial cell, which yet has no Rank NFT asset to complete it, as well as it is not listed in any auto-generation registries.","title":"Cells"},{"location":"architecure/#app-store-infrastructure","text":"Rankify goal is to provide as generic and permissions approach as possible with yet a security guarantees between different DAO members that are translated trough curating own application infrastructure. Application infrastructure consist of: Repository Factory : Provides ability for applications to have versioned control. Repositories : Each repository contains access to versioned installers of an application. Registry : Source of trust that Rankify DAO puts attestations for repositories it supports.","title":"App store infrastructure"},{"location":"architecure/#factory","text":"The App Factory serves as a source for app installations, guaranteeing deterministic logic source in deployed applications. This enables the creation of interconnected ecosystems where trust is built on a shared understanding of app functionality. Every app listed on any repositories must undergo Rankify curation, however other entities or individuals are welcome to start their own Factories as well. It follows the standards set by the OSx PluginFactory , while generalizing it in IVRepoFactory it preserves ability for seamless integration and compatibility within the broader ecosystem.","title":"Factory"},{"location":"architecure/#repositories","text":"plantuml source=\"basic.puml\" '' This code is appended to the contents of basic.puml Goofy -> MickeyMouse: calls Goofy <-- MickeyMouse: responds The App Repositories are built upon the IRepository interface, which mirrors the functionality of the OSx IPluginRepo . It provides a secure versioned repository for versioned application implementations. Users of that repository can be sure that every time they request specific application version, same address will be returned.","title":"Repositories"},{"location":"architecure/#registry","text":"Unlike immutable Repositories, the Registry is a mutable source of trust, allowing external applications to verify attestations from Rankify on ENS . While developers can deploy their own Repository contracts freely, the DAO curates it's attestations, listing its own resources and community-approved third-party applications.","title":"Registry"},{"location":"architecure/#installer","text":"To maximize flexibility for both users and developers, we anticipate that applications installed within organizations will often require internal separation. For instance, an organization might need to run two instances of the same application for different tournaments in different time zones. To accommodate this, a single application repository can support multiple instances. This instance creation process should be streamlined, even allowing community members to create instances independently without undergoing a formal voting process. To facilitate this, a specialized \"Installer\" application is provided. This application, authorized by the DAO, maintains a list of approved registries for instantiation, which can only be modified by the DAO. This simplifies the process for users to launch whitelisted applications, acting as a proxy between instances and the DAO contract.","title":"Installer"},{"location":"architecure/specifications/","text":"Specifications # This document outlines the detailed specifications for our project. Each section in this document corresponds to a different component of the system and is further divided into two categories: Functional Requirements and Security Requirements. Functional Requirements : define the functionality that a system or system component must be able to perform. They describe what the system should do and include specifications for features, capabilities, and operational constraints. Security Requirements : define the measures that are needed to protect the system from potential threats. They often involve access control, data protection, and system integrity. Security requirements are given per implementation given the context of the implementations as these requirements are not universal. Functional requirements # Repositories # Functional interface requirements are described in IRepository , functionality must fulfill following unit tests: It emits VersionCreated when createVersion is called successfully It reverts with InvalidReleaseIncrement if a release number is incremented by more than one It reverts with ReleaseZeroNotAllowed if a release number is set to zero in createVersion When no release nor version exists: It reverts with VersionHashDoesNotExist if getVersion is called It reverts with ReleaseDoesNotExist if updateReleaseMetadata is called It returns zero if latestRelease is called on repository with no releases It returns zero if buildCount is called on repository with no releases It reverts with VersionHashDoesNotExist if called getLatestVersion(address) It reverts with ReleaseDoesNotExist if called getLatestVersion(uint8) When version and release exists: It reverts with AlreadyInPreviousRelease if createVersion if the same source address It returns correct release count for given major version upon calling buildCount It returns correct Version if getVersion is called with valid major and minor version It returns correct Version if getLatestVersion(address) is called It returns correct Version if getLatestVersion(uint8) is called It emits ReleaseMetadataUpdated when updateReleaseMetadata is called successfully Registry [TBD] # Cells [TBD] # Rank NFT # Must implement OpenSea compatible uri format that can resolve to title, Description and image Must allow only owner to modify metadata May implement additional IRankToken interface Governance Token [TBD] # App Instances # Installer # installer must implement IRepoInstaller interface, functionality must fulfill following unit tests: it emits RepositoryAdded if addRepository is called successfully. it emits Instantiated if instantiate is called successfully. it reverts with RepositoryDoesNotExist if instantiate is called with non-existing repository. it reverts with VersionDoesNotMatchRequirement if instantiate version does not match. it emits Repositor Removed when removeRepository` is called successfully. it emits Instantiated if instantiateLatest is called successfully. it reverts with RepositoryDoesNotExist if instantiateLatest is called with non-existing repository. when repository already exists: it emits RepositoryRequirementUpdated if addRepository is called successfully with already existing repository. when RepositoryRequirementUpdated was emitted: it reverts with VersionDoesNotMatchRequirement if instance version does not match requirement anymore. it emits Upgraded if upgrade is called successfully. it reverts with VersionDoesNotMatchRequirement if upgrade is called with version that does not match the required version. It returns correct Repository if getRepository is called with valid instance address It returns all instances of a repository if getInstances is called with valid repository address It returns all active repositories if getRepositories is called It returns version tag if getVersion is called with valid instance address It returns VersionRequirement if getVersionRequirement is called with valid instance address It reverts with InstanceDoesNotExist if getVersionRequirement is called with non-existing instance address It reverts with InstanceDoesNotExist if getVersion is called with non-existing instance address It reverts with RepositoryDoesNotExist if getRepository is called with non-existing instance address It reverts with RepositoryDoesNotExist if getInstances is called with non-existing repository address Instance [TBD] # Security requirements # Security specifications outlined per contract instance are implementation agnostic. They are meant to be implemented in a way that is most suitable for the given context. Following definitions extend ERC-2119 definitions: Access point : A function or method that is part of the protected contract's interface. WHITELIST : Set of addresses that are explicitly allowed on certain access points. BLACKLIST : Set addresses that are explicitly disallowed on certain access points. RESTRICTED : An access point that MUST enforce WHITELIST. UNRESTRICTED : An access point that MAY enforce BLACKLIST. DAO Owned Repository # DAO controlled functional Repository must fulfill following security requirements: All non-read methods are RESTRICTED, where only WHITELIST member is Rankify Multisig Rankify Multisig MAY assign WHITELIST members to each access point individually Rankify Multisig MAY revoke WHITELIST members from each access point individually All read methods are UNRESTRICTED, with no BLACKLIST members No one may modify security settings except Rankify Multisig Rankify Multisig MAY transfer it's privileges to another account Rankify Multisig # Multisig controlled functional Safe Wallet Initially deployed with a single signer and 1-of-1, Rankify DAO signer Rankify DAO signer MAY add or remove signers Rankify DAO signer MAY change the threshold Rankify DAO signer MAY revoke it's own signer status App Instances # Installer [TBD] #","title":"Specifications"},{"location":"architecure/specifications/#specifications","text":"This document outlines the detailed specifications for our project. Each section in this document corresponds to a different component of the system and is further divided into two categories: Functional Requirements and Security Requirements. Functional Requirements : define the functionality that a system or system component must be able to perform. They describe what the system should do and include specifications for features, capabilities, and operational constraints. Security Requirements : define the measures that are needed to protect the system from potential threats. They often involve access control, data protection, and system integrity. Security requirements are given per implementation given the context of the implementations as these requirements are not universal.","title":"Specifications"},{"location":"architecure/specifications/#functional-requirements","text":"","title":"Functional requirements"},{"location":"architecure/specifications/#repositories","text":"Functional interface requirements are described in IRepository , functionality must fulfill following unit tests: It emits VersionCreated when createVersion is called successfully It reverts with InvalidReleaseIncrement if a release number is incremented by more than one It reverts with ReleaseZeroNotAllowed if a release number is set to zero in createVersion When no release nor version exists: It reverts with VersionHashDoesNotExist if getVersion is called It reverts with ReleaseDoesNotExist if updateReleaseMetadata is called It returns zero if latestRelease is called on repository with no releases It returns zero if buildCount is called on repository with no releases It reverts with VersionHashDoesNotExist if called getLatestVersion(address) It reverts with ReleaseDoesNotExist if called getLatestVersion(uint8) When version and release exists: It reverts with AlreadyInPreviousRelease if createVersion if the same source address It returns correct release count for given major version upon calling buildCount It returns correct Version if getVersion is called with valid major and minor version It returns correct Version if getLatestVersion(address) is called It returns correct Version if getLatestVersion(uint8) is called It emits ReleaseMetadataUpdated when updateReleaseMetadata is called successfully","title":"Repositories"},{"location":"architecure/specifications/#registry-tbd","text":"","title":"Registry [TBD]"},{"location":"architecure/specifications/#cells-tbd","text":"","title":"Cells [TBD]"},{"location":"architecure/specifications/#rank-nft","text":"Must implement OpenSea compatible uri format that can resolve to title, Description and image Must allow only owner to modify metadata May implement additional IRankToken interface","title":"Rank NFT"},{"location":"architecure/specifications/#governance-token-tbd","text":"","title":"Governance Token [TBD]"},{"location":"architecure/specifications/#app-instances","text":"","title":"App Instances"},{"location":"architecure/specifications/#installer","text":"installer must implement IRepoInstaller interface, functionality must fulfill following unit tests: it emits RepositoryAdded if addRepository is called successfully. it emits Instantiated if instantiate is called successfully. it reverts with RepositoryDoesNotExist if instantiate is called with non-existing repository. it reverts with VersionDoesNotMatchRequirement if instantiate version does not match. it emits Repositor Removed when removeRepository` is called successfully. it emits Instantiated if instantiateLatest is called successfully. it reverts with RepositoryDoesNotExist if instantiateLatest is called with non-existing repository. when repository already exists: it emits RepositoryRequirementUpdated if addRepository is called successfully with already existing repository. when RepositoryRequirementUpdated was emitted: it reverts with VersionDoesNotMatchRequirement if instance version does not match requirement anymore. it emits Upgraded if upgrade is called successfully. it reverts with VersionDoesNotMatchRequirement if upgrade is called with version that does not match the required version. It returns correct Repository if getRepository is called with valid instance address It returns all instances of a repository if getInstances is called with valid repository address It returns all active repositories if getRepositories is called It returns version tag if getVersion is called with valid instance address It returns VersionRequirement if getVersionRequirement is called with valid instance address It reverts with InstanceDoesNotExist if getVersionRequirement is called with non-existing instance address It reverts with InstanceDoesNotExist if getVersion is called with non-existing instance address It reverts with RepositoryDoesNotExist if getRepository is called with non-existing instance address It reverts with RepositoryDoesNotExist if getInstances is called with non-existing repository address","title":"Installer"},{"location":"architecure/specifications/#instance-tbd","text":"","title":"Instance [TBD]"},{"location":"architecure/specifications/#security-requirements","text":"Security specifications outlined per contract instance are implementation agnostic. They are meant to be implemented in a way that is most suitable for the given context. Following definitions extend ERC-2119 definitions: Access point : A function or method that is part of the protected contract's interface. WHITELIST : Set of addresses that are explicitly allowed on certain access points. BLACKLIST : Set addresses that are explicitly disallowed on certain access points. RESTRICTED : An access point that MUST enforce WHITELIST. UNRESTRICTED : An access point that MAY enforce BLACKLIST.","title":"Security requirements"},{"location":"architecure/specifications/#dao-owned-repository","text":"DAO controlled functional Repository must fulfill following security requirements: All non-read methods are RESTRICTED, where only WHITELIST member is Rankify Multisig Rankify Multisig MAY assign WHITELIST members to each access point individually Rankify Multisig MAY revoke WHITELIST members from each access point individually All read methods are UNRESTRICTED, with no BLACKLIST members No one may modify security settings except Rankify Multisig Rankify Multisig MAY transfer it's privileges to another account","title":"DAO Owned Repository"},{"location":"architecure/specifications/#rankify-multisig","text":"Multisig controlled functional Safe Wallet Initially deployed with a single signer and 1-of-1, Rankify DAO signer Rankify DAO signer MAY add or remove signers Rankify DAO signer MAY change the threshold Rankify DAO signer MAY revoke it's own signer status","title":"Rankify Multisig"},{"location":"architecure/specifications/#app-instances_1","text":"","title":"App Instances"},{"location":"architecure/specifications/#installer-tbd","text":"","title":"Installer [TBD]"},{"location":"interfaces/solidity-api/","text":"Solidity API # CompositeERC1155 # An abstract contract that extends LockableERC1155 and provides functionality for composite ERC1155 tokens. Composite tokens can be \"composed\" from multiple underlying assets, which however do not change their owner and in contrast to that use LockableERC1155 standard, which allows to read locked asset BalanceOf, OwnerOf methods correctly constructor # constructor(string uri_, address[] dimensionTokens, uint256[] tokenWeights) internal _mint # function _mint(address to, uint256 tokenId, uint256 value, bytes data) internal virtual _burn # function _burn(address from, uint256 id, uint256 amount) internal _Destroys amount tokens of token type id from from Emits a {TransferSingle} event. Requirements: from cannot be the zero address. from must have at least amount tokens of token type id ._ decompose # function decompose(address from, uint256 id, uint256 amount) public virtual Decomposes a composite ERC1155 token into its individual components. This function unlocks the specified amount of the composite token from each dimension, and then burns the specified amount of the composite token from the caller's balance. Parameters # Name Type Description from address The address from which the composite token is being decomposed. id uint256 The ID of the composite token being decomposed. amount uint256 The amount of the composite token to decompose. burn # function burn(address account, uint256 id, uint256 value) public virtual _Burns a specified amount of tokens from the given account. This will burn all underlying (composite) assets Requirements: - account must be the token owner or an approved operator. - id and value must be valid token ID and amount to burn. - All underlying \"composite\" assets implement burn as well_ Parameters # Name Type Description account address The address of the token owner. id uint256 The ID of the token to burn. value uint256 The amount of tokens to burn. getComponents # function getComponents() public virtual returns (address[], uint256[]) Retrieves the components of the CompositeERC1155 contract. Return Values # Name Type Description [0] address[] An array of component addresses and an array of component weights. [1] uint256[] DiamondReentrancyGuard # nonReentrant # modifier nonReentrant() insufficient # error insufficient(uint256 id, uint256 balance, uint256 required) LockableERC1155 # This is an abstract contract that extends the ERC1155 token contract and implements the ILockableERC1155 interface. It provides functionality to lock and unlock token amounts for specific accounts and IDs. lockedAmounts # mapping(address => mapping(uint256 => uint256)) lockedAmounts lock # function lock(address account, uint256 id, uint256 amount) public virtual Locks a specified amount of tokens for a given account and token ID. If the account does not have enough balance to lock the specified amount, the function will revert with an \"insufficient\" error message. Emits a TokensLocked event after successfully locking the tokens. Parameters # Name Type Description account address The address of the account to lock tokens for. id uint256 The ID of the token to lock. amount uint256 The amount of tokens to lock. unlock # function unlock(address account, uint256 id, uint256 amount) public virtual Unlocks a specified amount of tokens for a given account and token ID. If the locked amount is less than the specified amount, it reverts with an \"insufficient\" error message. Emits a TokensUnlocked event after unlocking the tokens. Parameters # Name Type Description account address The address of the account to unlock tokens for. id uint256 The ID of the token to unlock. amount uint256 The amount of tokens to unlock. unlockedBalanceOf # function unlockedBalanceOf(address account, uint256 id) public view returns (uint256) Returns the unlocked balance of a specific ERC1155 token for an account. The unlocked balance is calculated by subtracting the locked amount from the total balance. Parameters # Name Type Description account address The address of the account. id uint256 The ID of the ERC1155 token. Return Values # Name Type Description [0] uint256 The unlocked balance of the ERC1155 token for the account. _beforeTokenTransfer # function _beforeTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal virtual Hook function that is called before any token transfer. It checks if the transfer is allowed based on the locked amounts of the tokens. If the transfer is not allowed, it reverts with an error message. Parameters # Name Type Description operator address The address performing the token transfer. from address The address from which the tokens are being transferred. to address The address to which the tokens are being transferred. ids uint256[] An array of token IDs being transferred. amounts uint256[] An array of token amounts being transferred. data bytes Additional data attached to the transfer. EIP712 # _https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data. The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible, thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in their contracts using a combination of abi.encode and keccak256 . This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA ({_hashTypedDataV4}). The implementation of the domain separator was designed to be as efficient as possible while still properly updating the chain id to protect against replay attacks on an eventual fork of the chain. NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method https://docs.metamask.io/guide/signing-data.html[ eth_signTypedDataV4 in MetaMask]. _Available since v3.4.__ constructor # constructor() internal _Initializes the domain separator and parameter caches. The meaning of name and version is specified in https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]: name : the user readable name of the signing domain, i.e. the name of the DApp or the protocol. version : the current major version of the signing domain. NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart contract upgrade]._ _domainSeparatorV4 # function _domainSeparatorV4() internal view returns (bytes32) Returns the domain separator for the current chain. _hashTypedDataV4 # function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) _Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this function returns the hash of the fully encoded EIP712 message for this domain. This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example: bytes32 digest = _hashTypedDataV4(keccak256(abi.encode( keccak256(\"Mail(address to,string contents)\"), mailTo, keccak256(bytes(mailContents)) ))); address signer = ECDSA.recover(digest, signature); ```_ ## DNSFacet ### _isValidSignature ```solidity function _isValidSignature(bytes message, bytes signature, address account) internal view returns (bool) initializeDomain # function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) public _Initializes new LibMultipass.Domain and configures it's parameters Requirements: registrar is not zero domainName is not empty domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names domainName does not exist yet onlyOwner referrerReward+referralDiscount cannot be larger than fee @param registrar address of registrar @param freeRegistrationsNumber number of registrations free of fee @param fee fee in base currency of network @param domainName name of LibMultipass.Domain @param referrerReward referral fee share in base currency of network @param referralDiscount referral discount in base currency of network Emits an {InitializedDomain} event._ activateDomain # function activateDomain(bytes32 domainName) public _Activates LibMultipass.Domain name Requirements: msg.sender is Owner Emits an {DomainActivated} event._ deactivateDomain # function deactivateDomain(bytes32 domainName) public _Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements: msg.sender is Owner OR registrar Emits an {DomainDeactivated} event._ changeFee # function changeFee(bytes32 domainName, uint256 fee) public _Changes registrar address Requirements: msg.sender is Owner Emits an {DomainFeeChanged} event._ changeRegistrar # function changeRegistrar(bytes32 domainName, address newRegistrar) public _Changes registrar address Requirements: msg.sender is Owner Emits an {RegistrarChangeRequested} event._ deleteName # function deleteName(struct LibMultipass.NameQuery query) public _deletes name Requirements: msg.sender is Owner Emits an {DomainTTLChangeRequested} event._ changeReferralProgram # function changeReferralProgram(uint256 referrerReward, uint256 freeRegistrations, uint256 referralDiscount, bytes32 domainName) public resolveRecord # function resolveRecord(struct LibMultipass.NameQuery query) public view returns (bool, struct LibMultipass.Record) resolves LibMultipass.Record of name query in to status and identity register # function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) public payable _registers new name under LibMultipass.Domain Requirements: all arguments must be set domainName must be active resolveRecord for given arguments should return no LibMultipass.Record Emits an {registered} event._ getModifyPrice # function getModifyPrice(struct LibMultipass.NameQuery query) public view returns (uint256) modifyUserName # function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) public payable _modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain_ Parameters # Name Type Description domainName bytes32 LibMultipass.Domain query struct LibMultipass.NameQuery newName bytes32 new name Emits an {Modified} event. registrarSignature bytes signatureDeadline uint256 getBalance # function getBalance() external view returns (uint256) returns balance of this contract getDomainState # function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain) returns LibMultipass.Domain state variables Parameters # Name Type Description domainName bytes32 name of the LibMultipass.Domain Return Values # Name Type Description [0] struct LibMultipass.Domain (name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize) getDomainStateByIdx # function getDomainStateByIdx(uint256 index) external view returns (struct LibMultipass.Domain) getContractState # function getContractState() external view returns (uint256) returns contract state variables Return Values # Name Type Description [0] uint256 (s_numDomains) withrawFunds # function withrawFunds(address to) public _Withraws funds stored in smart contract Requirements: onlyOwner Emits an {fundsWithdawn} event._ EIP712InspectorFacet # inspectEIP712Hashes # function inspectEIP712Hashes() public view returns (bytes32 _CACHED_DOMAIN_SEPARATOR, uint256 _CACHED_CHAIN_ID, address _CACHED_THIS, bytes32 _HASHED_NAME, bytes32 _HASHED_VERSION, bytes32 _TYPE_HASH) currentChainId # function currentChainId() public view returns (uint256) RankifyInstanceGameMastersFacet # OverTime # event OverTime(uint256 gameId) LastTurn # event LastTurn(uint256 gameId) ProposalScore # event ProposalScore(uint256 gameId, uint256 turn, string proposalHash, string proposal, uint256 score) TurnEnded # event TurnEnded(uint256 gameId, uint256 turn, address[] players, uint256[] scores, string[] newProposals, uint256[] proposerIndicies, uint256[][] votes) GameOver # event GameOver(uint256 gameId, address[] players, uint256[] scores) ProposalSubmitted # event ProposalSubmitted(uint256 gameId, uint256 turn, address proposer, bytes32 commitmentHash, string proposalEncryptedByGM) ProposalParams # struct ProposalParams { uint256 gameId; string encryptedProposal; bytes32 commitmentHash; address proposer; } VoteSubmitted # event VoteSubmitted(uint256 gameId, uint256 turn, address player, string votesHidden) submitVote # function submitVote(uint256 gameId, string encryptedVotes, address voter) public _Submits a vote for a game. gameId is the ID of the game. encryptedVotes is the encrypted votes. voter is the address of the voter. Emits a VoteSubmitted event. Requirements: The caller must be a game master of the game with gameId . The game with gameId must exist. The game with gameId must have started. The game with gameId must not be over. voter must be in the game with gameId . The current turn of the game with gameId must be greater than 1._ submitProposal # function submitProposal(struct RankifyInstanceGameMastersFacet.ProposalParams proposalData) public _Submits a proposal for a game. proposalData is the proposal data. Requirements: The game with proposalData.gameId must exist. The caller must be a game master of the game with proposalData.gameId ._ endTurn # function endTurn(uint256 gameId, uint256[][] votes, string[] newProposals, uint256[] proposerIndicies) public _Ends the current turn of a game with the provided game ID. gameId is the ID of the game. votes is the array of votes. newProposals is the array of new proposals for the upcoming voting round. proposerIndicies is the array of indices of the proposers in the previous voting round. emits a ProposalScore event for each player if the turn is not the first. emits a TurnEnded event. Modifies: Calls the _nextTurn function with gameId and newProposals . Resets the number of commitments of the game with gameId to 0. Resets the proposal commitment hash and ongoing proposal of each player in the game with gameId . Requirements: The caller must be a game master of the game with gameId . The game with gameId must have started. The game with gameId must not be over. newProposals array MUST be sorted randomly to ensure privacy votes and proposerIndicies MUST correspond to players array from game.getPlayers()_ ZeroValue # error ZeroValue() WrongAddress # error WrongAddress() OutOfBounds # error OutOfBounds() RankifyInstanceGameOwnersFacet # RInstanceStorage # function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog) setGamePrice # function setGamePrice(uint256 newPrice) external _Sets the game price. newPrice is the new game price. Modifies: Sets the game price to newPrice . Requirements: The caller must be the contract owner._ setJoinGamePrice # function setJoinGamePrice(uint256 newPrice) external _Sets the join game price. newPrice is the new join game price. Modifies: Sets the join game price to newPrice . Requirements: The caller must be the contract owner._ setRankTokenAddress # function setRankTokenAddress(address newRankToken) external _Sets the rank token address. newRankToken is the new rank token address. Modifies: Sets the rank token address to newRankToken . Requirements: The caller must be the contract owner. newRankToken must not be the zero address. newRankToken must support the ERC1155 interface._ setTimePerTurn # function setTimePerTurn(uint256 newTimePerTurn) external _Sets the time per turn. newTimePerTurn is the new time per turn. Modifies: Sets the time per turn to newTimePerTurn . Requirements: The caller must be the contract owner._ setMaxPlayersSize # function setMaxPlayersSize(uint256 newMaxPlayersSize) external _Sets the maximum number of players in a game. newMaxPlayersSize is the new maximum number of players. Modifies: Sets the maximum number of players to newMaxPlayersSize . Requirements: The caller must be the contract owner. newMaxPlayersSize must be greater than or equal to the minimum number of players._ setMinPlayersSize # function setMinPlayersSize(uint256 newMinPlayersSize) external _Sets the minimum number of players in a game. newMinPlayersSize is the new minimum number of players. Modifies: Sets the minimum number of players to newMinPlayersSize . Requirements: The caller must be the contract owner. newMinPlayersSize must be less than or equal to the maximum number of players._ setTimeToJoin # function setTimeToJoin(uint256 newTimeToJoin) external _Sets the time to join a game. newTimeToJoin is the new time to join. Modifies: Sets the time to join to newTimeToJoin . Requirements: The caller must be the contract owner. newTimeToJoin must not be zero._ setMaxTurns # function setMaxTurns(uint256 newMaxTurns) external _Sets the maximum number of turns in a game. newMaxTurns is the new maximum number of turns. Modifies: Sets the maximum number of turns to newMaxTurns . Requirements: The caller must be the contract owner. newMaxTurns must not be zero._ RankifyInstanceMainFacet # RInstanceStorage # function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog) createGame # function createGame(address gameMaster, uint256 gameId, uint256 gameRank) public _Creates a new game with the provided game master, game ID, and game rank. Optionally, additional ranks can be provided. gameMaster is the address of the game master. gameId is the ID of the new game. gameRank is the rank of the new game. additionalRanks is the array of additional ranks. emits a GameCreated event. Requirements: There are some game price requirments that must be met under gameId.newGame function that are set during the contract initialization and refer to the contract maintainer benefits. Modifies: Calls the newGame function with gameMaster , gameRank , and msg.sender . Configures the coin vending with gameId and an empty configuration. If additionalRanks is not empty, mints rank tokens for each additional rank and sets the additional ranks of the game with gameId to additionalRanks ._ createGame # function createGame(address gameMaster, uint256 gameId, uint256 gameRank, address[] additionalRanks) public createGame # function createGame(address gameMaster, uint256 gameRank) public cancelGame # function cancelGame(uint256 gameId) public _Cancels a game with the provided game ID. gameId is the ID of the game. Modifies: Calls the enforceIsGameCreator function with msg.sender . Requirements: The caller must be the game creator of the game with gameId . Game must not be started._ leaveGame # function leaveGame(uint256 gameId) public _Allows a player to leave a game with the provided game ID. gameId is the ID of the game. Modifies: Calls the quitGame function with msg.sender , true , and onPlayerQuit . Requirements: The caller must be a player in the game with gameId . Game must not be started._ openRegistration # function openRegistration(uint256 gameId) public _Opens registration for a game with the provided game ID. gameId is the ID of the game. emits a RegistrationOpen event. Modifies: Calls the enforceIsGameCreator function with msg.sender . Calls the enforceIsPreRegistrationStage function. Calls the openRegistration function. Requirements: The caller must be the game creator of the game with gameId . The game with gameId must be in the pre-registration stage._ joinGame # function joinGame(uint256 gameId) public payable _Allows a player to join a game with the provided game ID. gameId is the ID of the game. emits a PlayerJoined event. Modifies: Calls the joinGame function with msg.sender . Calls the fund function with bytes32(gameId) . Requirements: The caller must not be a player in the game with gameId . Game phase must be registration. Caller must be able to fulfill funding requirements._ startGame # function startGame(uint256 gameId) public _Starts a game with the provided game ID early. gameId is the ID of the game. emits a GameStarted event. Modifies: Calls the enforceGameExists function. Calls the startGameEarly function. Requirements: The game with gameId must exist._ onERC1155Received # function onERC1155Received(address operator, address, uint256, uint256, bytes) public view returns (bytes4) onERC1155BatchReceived # function onERC1155BatchReceived(address operator, address, uint256[], uint256[], bytes) external view returns (bytes4) onERC721Received # function onERC721Received(address operator, address, uint256, bytes) external view returns (bytes4) getContractState # function getContractState() public view returns (struct IRankifyInstanceCommons.RInstanceState) getTurn # function getTurn(uint256 gameId) public view returns (uint256) getGM # function getGM(uint256 gameId) public view returns (address) getScores # function getScores(uint256 gameId) public view returns (address[], uint256[]) isOvertime # function isOvertime(uint256 gameId) public view returns (bool) isGameOver # function isGameOver(uint256 gameId) public view returns (bool) getPlayersGame # function getPlayersGame(address player) public view returns (uint256) isLastTurn # function isLastTurn(uint256 gameId) public view returns (bool) isRegistrationOpen # function isRegistrationOpen(uint256 gameId) public view returns (bool) gameCreator # function gameCreator(uint256 gameId) public view returns (address) getGameRank # function getGameRank(uint256 gameId) public view returns (uint256) getPlayers # function getPlayers(uint256 gameId) public view returns (address[]) canStartGame # function canStartGame(uint256 gameId) public view returns (bool) canEndTurn # function canEndTurn(uint256 gameId) public view returns (bool) isPlayerTurnComplete # function isPlayerTurnComplete(uint256 gameId, address player) public view returns (bool) getPlayerVotedArray # function getPlayerVotedArray(uint256 gameId) public view returns (bool[]) getPlayersMoved # function getPlayersMoved(uint256 gameId) public view returns (bool[], uint256) RankifyInstanceRequirementsFacet # RequirementsConfigured # event RequirementsConfigured(uint256 gameId, struct LibCoinVending.ConfigPosition config) setJoinRequirements # function setJoinRequirements(uint256 gameId, struct LibCoinVending.ConfigPosition config) public Sets the join requirements for a specific game. Only the game creator can call this function. The game must be in the pre-registration stage. Parameters # Name Type Description gameId uint256 The ID of the game. config struct LibCoinVending.ConfigPosition The configuration position for the join requirements. getJoinRequirements # function getJoinRequirements(uint256 gameId) public view returns (struct LibCoinVending.ConditionReturn) Retrieves the join requirements for a specific game. Parameters # Name Type Description gameId uint256 The ID of the game. Return Values # Name Type Description [0] struct LibCoinVending.ConditionReturn The join requirements as a LibCoinVending.ConditionReturn struct. getJoinRequirementsByToken # function getJoinRequirementsByToken(uint256 gameId, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) public view returns (struct LibCoinVending.ContractCondition) Retrieves the join requirements for a specific token in a game. Parameters # Name Type Description gameId uint256 The ID of the game. contractAddress address The address of the contract. contractId uint256 The ID of the contract. contractType enum LibCoinVending.ContractTypes The type of the contract. Return Values # Name Type Description [0] struct LibCoinVending.ContractCondition The join requirements for the specified token. IERC1155Receiver # onERC1155Received # function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes data) external returns (bytes4) validate receipt of ERC1155 transfer Parameters # Name Type Description operator address executor of transfer from address sender of tokens id uint256 token ID received value uint256 quantity of tokens received data bytes data payload Return Values # Name Type Description [0] bytes4 function's own selector if transfer is accepted onERC1155BatchReceived # function onERC1155BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data) external returns (bytes4) validate receipt of ERC1155 batch transfer Parameters # Name Type Description operator address executor of transfer from address sender of tokens ids uint256[] token IDs received values uint256[] quantities of tokens received data bytes data payload Return Values # Name Type Description [0] bytes4 function's own selector if transfer is accepted ILockableERC1155 # Interface for a lockable ERC1155 token contract. TokensLocked # event TokensLocked(address account, uint256 id, uint256 value) TokensUnlocked # event TokensUnlocked(address account, uint256 id, uint256 value) lock # function lock(address account, uint256 id, uint256 amount) external _Locks a specified amount of tokens for a given account and token ID. account is the address of the account to lock the tokens for. id is the ID of the token to lock. amount is the amount of tokens to lock. emits a TokensLocked event._ unlock # function unlock(address account, uint256 id, uint256 amount) external _Unlocks a specified amount of tokens for a given account and token ID. account is the address of the account to unlock the tokens for. id is the ID of the token to unlock. amount is the amount of tokens to unlock. emits a TokensUnlocked event._ unlockedBalanceOf # function unlockedBalanceOf(address account, uint256 id) external view returns (uint256) _Returns the unlocked balance of tokens for a given account and token ID. account is the address of the account to check the unlocked balance for. id is the ID of the token to check the unlocked balance for. Returns: The unlocked balance of tokens._ IMultipass # resolveRecord # function resolveRecord(struct LibMultipass.NameQuery query) external view returns (bool, struct LibMultipass.Record) initializeDomain # function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) external _Initializes new LibMultipass.Domain and configures it's parameters Requirements: registrar is not zero domainName is not empty domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names domainName does not exist yet onlyOwner referrerReward+referralDiscount cannot be larger than fee @param registrar address of registrar @param freeRegistrationsNumber number of registrations free of fee @param fee fee in base currency of network @param domainName name of LibMultipass.Domain @param referrerReward referral fee share in base currency of network @param referralDiscount referral discount in base currency of network Emits an {InitializedDomain} event._ activateDomain # function activateDomain(bytes32 domainName) external _Activates LibMultipass.Domain name Requirements: msg.sender is Owner Emits an {DomainActivated} event._ deactivateDomain # function deactivateDomain(bytes32 domainName) external _Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements: msg.sender is Owner OR registrar Emits an {DomainDeactivated} event._ changeFee # function changeFee(bytes32 domainName, uint256 fee) external _Changes registrar address Requirements: msg.sender is Owner Emits an {DomainFeeChanged} event._ changeRegistrar # function changeRegistrar(bytes32 domainName, address newRegistrar) external _Changes registrar address Requirements: msg.sender is Owner Emits an {RegistrarChangeRequested} event._ deleteName # function deleteName(struct LibMultipass.NameQuery query) external _deletes name Requirements: msg.sender is Owner Emits an {DomainTTLChangeRequested} event._ changeReferralProgram # function changeReferralProgram(uint256 referrerFeeShare, uint256 referralDiscount, uint256 freeRegistrations, bytes32 domainName) external _executes all pending changes to LibMultipass.Domain that fulfill TTL Requirements: domainName must be set referrerFeeShare+referralDiscount cannot be larger than 2^32 Emits an {ReferralProgramChangeRequested} event._ register # function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) external payable _registers new name under LibMultipass.Domain Requirements: all arguments must be set domainName must be active resolveRecord for given arguments should return no LibMultipass.Record Emits an {registered} event._ modifyUserName # function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) external payable _modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain_ Parameters # Name Type Description domainName bytes32 LibMultipass.Domain query struct LibMultipass.NameQuery newName bytes32 new name Emits an {Modified} event. registrarSignature bytes signatureDeadline uint256 getBalance # function getBalance() external view returns (uint256) returns balance of this contract getDomainState # function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain) returns LibMultipass.Domain state variables Parameters # Name Type Description domainName bytes32 name of the LibMultipass.Domain Return Values # Name Type Description [0] struct LibMultipass.Domain (name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize) getContractState # function getContractState() external view returns (uint256) returns contract state variables Return Values # Name Type Description [0] uint256 (s_numDomains) withrawFunds # function withrawFunds(address to) external _Withraws funds stored in smart contract Requirements: onlyOwner Emits an {fundsWithdawn} event._ getModifyPrice # function getModifyPrice(struct LibMultipass.NameQuery query) external view returns (uint256) fundsWithdawn # event fundsWithdawn(uint256 amount, address account) InitializedDomain # event InitializedDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) DomainActivated # event DomainActivated(bytes32 domainName) DomainDeactivated # event DomainDeactivated(bytes32 domainName) DomainFeeChanged # event DomainFeeChanged(bytes32 domainName, uint256 newFee) FreeRegistrationsChanged # event FreeRegistrationsChanged(uint256 domainIndex, uint256 newAmount) RegistrarChangeRequested # event RegistrarChangeRequested(bytes32 domainName, address registrar) DomainNameChangeRequested # event DomainNameChangeRequested(uint256 domainIndex, bytes32 NewDomainName) nameDeleted # event nameDeleted(bytes32 domainName, address wallet, bytes32 id, bytes32 name) DomainTTLChangeRequested # event DomainTTLChangeRequested(bytes32 domainName, uint256 amount) ReferralProgramChanged # event ReferralProgramChanged(bytes32 domainName, uint256 reward, uint256 discount, uint256 freeNumber) DomainChangesAreLive # event DomainChangesAreLive(bytes32 domainName, bytes32[] changes) changesQeueCanceled # event changesQeueCanceled(bytes32 domainName, bytes32[] changes) Registered # event Registered(bytes32 domainName, struct LibMultipass.Record NewRecord) Referred # event Referred(struct LibMultipass.Record refferrer, struct LibMultipass.Record newRecord, bytes32 domainName) UserRecordModified # event UserRecordModified(struct LibMultipass.Record newRecord, bytes32 oldName, bytes32 domainName) IRankToken # RankingInstanceUpdated # event RankingInstanceUpdated(address newRankingInstance) LevelUp # event LevelUp(address account, uint256 id) mint # function mint(address to, uint256 amount, uint256 poolId, bytes data) external Mints a specified amount of tokens to an account. to is the address of the account to mint the tokens to. amount is the amount of tokens to mint. poolId is the ID of the pool. data is the additional data. batchMint # function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) external Mints specified amounts of tokens to an account. to is the address of the account to mint the tokens to. ids is the array of IDs of the tokens to mint. amounts is the array of amounts of tokens to mint. data is the additional data. levelUp # function levelUp(address to, uint256 id, bytes data) external _Levels up an account. to is the address of the account to level up. id is the ID of the token. data is the additional data. emits a LevelUp event._ updateRankingInstance # function updateRankingInstance(address newRankingInstance) external _Updates the ranking instance. newRankingInstance is the address of the new ranking instance. emits a RankingInstanceUpdated event._ getRankingInstance # function getRankingInstance() external view returns (address) _Gets the ranking instance which can emit new rank updates and mint rank tokens. Returns: The address of the ranking instance._ findNewRank # function findNewRank(address account, uint256 oldRank) external view returns (uint256) _Finds the new rank of an account. account is the address of the account. oldRank is the old rank of the account. It checks the balance of the account and returns the new rank that can be upgraded to. Returns: The new rank of the account._ getAccountRank # function getAccountRank(address account) external view returns (uint256) _Gets the rank of an account. account is the address of the account. Returns: The rank of the account._ IRankifyInstanceCommons # Score # struct Score { address participant; uint256 score; } RInstanceSettings # struct RInstanceSettings { uint256 gamePrice; address gamePaymentToken; uint256 joinGamePrice; uint256 numGames; address rankTokenAddress; bool contractInitialized; struct LibQuadraticVoting.qVotingStruct voting; } RInstanceState # struct RInstanceState { struct IRankifyInstanceCommons.RInstanceSettings BestOfState; struct LibTBG.GameSettings TBGSEttings; } VoteHidden # struct VoteHidden { bytes32 hash; bytes proof; } RInstance # struct RInstance { uint256 rank; address createdBy; mapping(uint256 => string) ongoingProposals; uint256 numOngoingProposals; uint256 numPrevProposals; mapping(address => bytes32) proposalCommitmentHashes; uint256 numCommitments; mapping(address => struct IRankifyInstanceCommons.VoteHidden) votesHidden; address[] additionalRanks; uint256 paymentsBalance; uint256 numVotesThisTurn; uint256 numVotesPrevTurn; mapping(address => bool) playerVoted; } RegistrationOpen # event RegistrationOpen(uint256 gameid) PlayerJoined # event PlayerJoined(uint256 gameId, address participant) GameStarted # event GameStarted(uint256 gameId) gameCreated # event gameCreated(uint256 gameId, address gm, address creator, uint256 rank) GameClosed # event GameClosed(uint256 gameId) PlayerLeft # event PlayerLeft(uint256 gameId, address player) LibArray # quickSort # function quickSort(uint256[] arr, int256 left, int256 right) internal view _Sorts the elements of the array in ascending order using the quicksort algorithm. Requirements: The array to be sorted must not be empty. The starting and ending indices must be within the bounds of the array. Modifies: The array is sorted in ascending order. Note: This function uses the in-place quicksort algorithm, which has an average-case complexity of O(n log n) and a worst-case complexity of O(n^2)._ LibCoinVending # _This library is used to simulate the vending machine coin acceptor state machine that: - Supports large number of positions; Each represents requirements to acess different goods of the virtual vending machine. - Accepts multiple assets of following types: Native (Eth), ERC20, ERC721, and ERC1155 tokens that can be stacked together. - Allows for each individual asset action promise can be one of following: - Lock: The asset is locked in the acceptor with promise that asset will be returned to the sender at release funds time. - Bet: The asset is locked in the acceptor with promise that asset will be awarded to benificiary at release funds time. - Pay: The asset is locked in the acceptor with promise that asset will be paid to payee at release funds time. - Burn: The asset is locked in the acceptor with promise that asset will be destroyed at release funds time. - Maintains each position balance, hence allowing multiple participants to line up for the same position. - Allows three actions: - Fund position with assets - Refund assets to user - Consume assets and provide goods to user - Consuming asset might take a form of - Transferring assets to payee - Burning assets - Awarding beneficiary with assets - Returning locked assets back to sender This library DOES enforces that any position can only be refunded or processed only within amount funded boundaries This library DOES NOT store the addresses of senders, nor benificiaries, nor payees. This is to be stored within implementation contract. !!!!! IMPORTANT !!!!! This library does NOT invocates reentrancy guards. It is implementation contract's responsibility to enforce reentrancy guards. Reentrancy guards MUST be implemented in an implementing contract. Usage: Configure position via configure(...) fund position with assets via fund(...) release or refund assets via release(...) or refund(...) repeat steps 1 and 2 as needed. Position can be recofigured at any time when it's effective balance is zero: timesFunded - timesRefuned - timesReleased = 0 Test state: This library most functionality has been tested: see ../tests/LibCoinVending.ts and ../tests/report.md for details. ERC721 token is checked only for \"HAVE\" condition since putting requirements on non fungable token id yet to be resolved. (see ERC721 section in the code below) This library has not been yet audited_ Condition # struct Condition { mapping(enum LibCoinVending.ContractTypes => mapping(address => mapping(uint256 => struct LibCoinVending.ContractCondition))) contracts; struct LibCoinVending.NumericCondition ethValues; uint256 timesRefunded; uint256 timesReleased; uint256 timesFunded; enum LibCoinVending.ContractTypes[] contractTypes; address[] contractAddresses; uint256[] contractIds; bool _isConfigured; } RequirementTypes # enum RequirementTypes { HAVE, LOCK, BURN, BET, PAY } TransactionProperties # struct TransactionProperties { bytes data; uint256 amount; } ContractCondition # struct ContractCondition { struct LibCoinVending.TransactionProperties have; struct LibCoinVending.TransactionProperties lock; struct LibCoinVending.TransactionProperties burn; struct LibCoinVending.TransactionProperties pay; struct LibCoinVending.TransactionProperties bet; } NumericCondition # struct NumericCondition { uint256 have; uint256 lock; uint256 burn; uint256 pay; uint256 bet; } TransferTypes # enum TransferTypes { FUND, REFUND, RELEASE } ConditionReturn # struct ConditionReturn { struct LibCoinVending.NumericCondition ethValues; uint256 timesRefunded; uint256 timesReleased; uint256 timesFunded; address[] contractAddresses; uint256[] contractIds; enum LibCoinVending.ContractTypes[] contractTypes; bool _isConfigured; } configSmartRequirement # struct configSmartRequirement { address contractAddress; uint256 contractId; enum LibCoinVending.ContractTypes contractType; struct LibCoinVending.ContractCondition contractRequirement; } ConfigPosition # struct ConfigPosition { struct LibCoinVending.NumericCondition ethValues; struct LibCoinVending.configSmartRequirement[] contracts; } LibCoinVendingStorage # struct LibCoinVendingStorage { mapping(bytes32 => struct LibCoinVending.Condition) positions; address beneficiary; } ContractTypes # enum ContractTypes { ERC20, ERC1155, ERC721 } COIN_VENDING_STORAGE_POSITION # bytes32 COIN_VENDING_STORAGE_POSITION coinVendingPosition # function coinVendingPosition(bytes32 position) internal view returns (struct LibCoinVending.Condition) coinVendingStorage # function coinVendingStorage() internal pure returns (struct LibCoinVending.LibCoinVendingStorage es) refund # function refund(bytes32 position, address to) internal _Returns all position requirements back to fundee. position is the identifier of the condition. to is the address to refund the balance to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the to address. Increments the timesRefunded counter for the condition._ batchRefund # function batchRefund(bytes32 position, address[] returnAddresses) internal _Returns all position requirements back to multiple fundees. position is the identifier of the condition. returnAddresses is an array of addresses to refund the balance to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to each address in returnAddresses . Increments the timesRefunded counter for the condition for each address in returnAddresses ._ release # function release(bytes32 position, address payee, address beneficiary, address returnAddress) internal _Releases the funds from a coin vending position to the specified addresses. position is the identifier of the condition. payee , beneficiary , and returnAddress are the addresses to release the funds to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the payee , beneficiary , and returnAddress . Increments the timesReleased counter for the condition._ batchRelease # function batchRelease(bytes32 position, address payee, address beneficiary, address[] returnAddresses) internal _Releases the funds from a coin vending position to multiple return addresses. position is the identifier of the condition. payee , beneficiary , and returnAddresses are the addresses to release the funds to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the payee , beneficiary , and each address in returnAddresses . Increments the timesReleased counter for the condition for each address in returnAddresses ._ fund # function fund(bytes32 position) internal _Funds the position by msg.sender . position is the identifier of the condition. Requirements: The condition must be configured. Modifies: Transfers the funds from msg.sender to this contract. Increments the timesFunded counter for the condition._ configure # function configure(bytes32 position, struct LibCoinVending.ConfigPosition configuration) internal _Configures the position. position is the identifier of the condition. configuration is the new configuration for the condition. Requirements: The condition must not have a positive balance. Modifies: Sets the configuration of the condition to configuration ._ getPosition # function getPosition(bytes32 position) internal view returns (struct LibCoinVending.ConditionReturn) _Returns the condition associated with the given position. position is the identifier of the condition. Returns: The condition associated with position ._ getPositionByContract # function getPositionByContract(bytes32 position, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) internal view returns (struct LibCoinVending.ContractCondition) _Returns the contract condition associated with the given position, contract address, contract ID, and contract type. position is the identifier of the condition. contractAddress is the address of the contract. contractId is the ID of the contract. contractType is the type of the contract. Returns: The contract condition associated with position , contractAddress , contractId , and contractType ._ LibEIP712WithStorage # EIP712_STORAGE_POSITION # bytes32 EIP712_STORAGE_POSITION LibEIP712WithStorageStorage # struct LibEIP712WithStorageStorage { bytes32 _CACHED_DOMAIN_SEPARATOR; uint256 _CACHED_CHAIN_ID; address _CACHED_THIS; bytes32 _HASHED_NAME; bytes32 _HASHED_VERSION; bytes32 _TYPE_HASH; } EIP712WithStorage # function EIP712WithStorage() internal pure returns (struct LibEIP712WithStorage.LibEIP712WithStorageStorage ds) LibMultipass # NameQuery # resolves user from any given argument Requirements: domainName must be given and must be initialized id OR username OR address must be given This method first tries to resolve by address, then by user id and finally by username Parameters # Name Type Description struct NameQuery { bytes32 domainName; address wallet; bytes32 name; bytes32 id; bytes32 targetDomain; } Domain # The domain name of the registrar. Parameters # Name Type Description struct Domain { bytes32 name; uint256 fee; uint256 freeRegistrationsNumber; uint256 referrerReward; uint256 referralDiscount; bool isActive; address registrar; uint24 ttl; uint256 registerSize; } Record # struct Record { address wallet; bytes32 name; bytes32 id; uint96 nonce; bytes32 domainName; } MULTIPASS_STORAGE_POSITION # bytes32 MULTIPASS_STORAGE_POSITION DomainNameService # The domain name of the registrar. Parameters # Name Type Description struct DomainNameService { struct LibMultipass.Domain properties; mapping(bytes32 => address) idToAddress; mapping(bytes32 => uint96) nonce; mapping(address => bytes32) addressToId; mapping(bytes32 => bytes32) nameToId; mapping(bytes32 => bytes32) idToName; } MultipassStorageStruct # struct MultipassStorageStruct { mapping(uint256 => struct LibMultipass.DomainNameService) domains; mapping(bytes32 => uint256) domainNameToIndex; uint256 numDomains; } MultipassStorage # function MultipassStorage() internal pure returns (struct LibMultipass.MultipassStorageStruct es) _TYPEHASH # bytes32 _TYPEHASH _TYPEHASH_REFERRAL # bytes32 _TYPEHASH_REFERRAL _checkStringFits32b # function _checkStringFits32b(string value) internal pure returns (bool) _checkNotEmpty # function _checkNotEmpty(bytes32 value) internal pure returns (bool) resolveDomainIndex # function resolveDomainIndex(bytes32 domainName) internal view returns (uint256) _getDomainStorage # function _getDomainStorage(bytes32 domainName) internal view returns (struct LibMultipass.DomainNameService) _initializeDomain # function _initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) internal _getModifyPrice # function _getModifyPrice(struct LibMultipass.Record userRecord) internal view returns (uint256) resolveRecord # function resolveRecord(struct LibMultipass.NameQuery query) internal view returns (bool, struct LibMultipass.Record) resolves Record of name query in to status and identity _setRecord # function _setRecord(struct LibMultipass.DomainNameService domain, struct LibMultipass.Record record) internal this function bears no security checks, it will ignore nonce in arg and will increment nonce value stored in domain instread queryFromRecord # function queryFromRecord(struct LibMultipass.Record _record, bytes32 _domainName) internal pure returns (struct LibMultipass.NameQuery) shouldRegisterForFree # function shouldRegisterForFree(struct LibMultipass.DomainNameService domain) internal view returns (bool) _registerNew # function _registerNew(struct LibMultipass.Record newRecord, struct LibMultipass.DomainNameService domain) internal _getContractState # function _getContractState() internal view returns (uint256) _getDomainStorageByIdx # function _getDomainStorageByIdx(uint256 index) internal view returns (struct LibMultipass.DomainNameService) quadraticVotingError # error quadraticVotingError(string paramter, uint256 arg, uint256 arg2) LibQuadraticVoting # A library for quadratic voting calculations. qVotingStruct # struct qVotingStruct { uint256 voteCredits; uint256 maxQuadraticPoints; uint256 minQuadraticPositons; } precomputeValues # function precomputeValues(uint256 voteCredits, uint256 minExpectedVoteItems) internal pure returns (struct LibQuadraticVoting.qVotingStruct) _Precomputes the values for quadratic voting. voteCredits is the total number of vote credits. minExpectedVoteItems is the minimum expected number of vote items. Returns: A qVotingStruct containing the precomputed values._ computeScoresByVPIndex # function computeScoresByVPIndex(struct LibQuadraticVoting.qVotingStruct q, uint256[][] VotersVotes, bool[] voterVoted, uint256 notVotedGivesEveyone, uint256 proposalsLength) internal pure returns (uint256[]) _Computes the scores for each proposal by voter preference index. q is the precomputed quadratic voting values. VotersVotes is a 2D array of votes, where each row corresponds to a voter and each column corresponds to a proposal. voterVoted is an array indicating whether each voter has voted. notVotedGivesEveyone is the number of points to distribute to each proposal for each voter that did not vote. proposalsLength is the number of proposals. Returns: An array of scores for each proposal._ LibRankify # compareStrings # function compareStrings(string a, string b) internal pure returns (bool) _Compares two strings for equality. a and b are the strings to compare. Returns: true if the strings are equal, false otherwise._ getGameStorage # function getGameStorage(uint256 gameId) internal view returns (struct IRankifyInstanceCommons.RInstance game) _Returns the game storage for the given game ID. gameId is the ID of the game. Returns: The game storage for gameId ._ RInstanceStorage # function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog) _Returns the Rankify InstanceSettings storage. Returns: The RInstanceSettings storage._ _PROPOSAL_PROOF_TYPEHASH # bytes32 _PROPOSAL_PROOF_TYPEHASH _VOTE_PROOF_TYPEHASH # bytes32 _VOTE_PROOF_TYPEHASH _VOTE_SUBMIT_PROOF_TYPEHASH # bytes32 _VOTE_SUBMIT_PROOF_TYPEHASH enforceIsInitialized # function enforceIsInitialized() internal view _Ensures that the contract is initialized. Requirements: The contract must be initialized._ enforceGameExists # function enforceGameExists(uint256 gameId) internal view _Ensures that the game with the given ID exists. gameId is the ID of the game. Requirements: The game with gameId must exist._ newGame # function newGame(uint256 gameId, address gameMaster, uint256 gameRank, address creator) internal _Creates a new game with the given parameters. gameId is the ID of the new game. gameMaster is the address of the game master. gameRank is the rank of the game. creator is the address of the creator of the game. Requirements: The game with gameId must not already exist. gameRank must not be 0. If the game price is not 0, the creator must have approved this contract to transfer the game price amount of the game payment token on their behalf. Modifies: Creates a new game with gameId . Transfers the game price amount of the game payment token from creator to this contract. Sets the payments balance of the game to the game price. Sets the creator of the game to creator . Increments the number of games. Sets the rank of the game to gameRank . Mints new rank tokens._ enforceIsGameCreator # function enforceIsGameCreator(uint256 gameId, address candidate) internal view _Ensures that the candidate is the creator of the game with the given ID. gameId is the ID of the game. candidate is the address of the candidate. Requirements: The game with gameId must exist. candidate must be the creator of the game._ enforceIsGM # function enforceIsGM(uint256 gameId, address candidate) internal view _Ensures that the candidate is the game master of the game with the given ID. gameId is the ID of the game. candidate is the address of the candidate. Requirements: The game with gameId must exist. candidate must be the game master of the game._ joinGame # function joinGame(uint256 gameId, address player) internal _Allows a player to join a game. gameId is the ID of the game. player is the address of the player. Requirements: The game with gameId must exist. If the join game price is not 0, the player must have approved this contract to transfer the join game price amount of the game payment token on their behalf. Modifies: Transfers the join game price amount of the game payment token from player to this contract. Increases the payments balance of the game by the join game price. Adds player to the game._ closeGame # function closeGame(uint256 gameId, address beneficiary, function (uint256,address) playersGameEndedCallback) internal returns (uint256[]) _Closes the game with the given ID and transfers the game's balance to the beneficiary. gameId is the ID of the game. beneficiary is the address to transfer the game's balance to. playersGameEndedCallback is a callback function to call for each player when the game ends. Requirements: The game with gameId must exist. Modifies: Emits rank rewards for the game. Removes and unlocks each player from the game. Calls playersGameEndedCallback for each player. Transfers the game's balance to beneficiary . Returns: The final scores of the game._ quitGame # function quitGame(uint256 gameId, address player, bool slash, function (uint256,address) onPlayerLeftCallback) internal _Allows a player to quit a game. gameId is the ID of the game. player is the address of the player. slash is a boolean indicating whether to slash the player's payment refund. onPlayerLeftCallback is a callback function to call when the player leaves. Requirements: The game with gameId must exist. Modifies: If the join game price is not 0, transfers a refund to player and decreases the game's payments balance by the refund amount. Removes and unlocks player from the game. Calls onPlayerLeftCallback for player ._ cancelGame # function cancelGame(uint256 gameId, function (uint256,address) onPlayerLeftCallback, address beneficiary) internal _Cancels the game with the given ID, refunds half of the game's payment to the game creator, and transfers the remaining balance to the beneficiary. gameId is the ID of the game. onPlayerLeftCallback is a callback function to call for each player when they leave. beneficiary is the address to transfer the remaining balance to. Requirements: The game with gameId must exist. Modifies: Calls quitGame for each player in the game. Transfers half of the game's payment to the game creator. Decreases the game's payments balance by the refund amount. Transfers the remaining balance of the game to beneficiary . Deletes the game._ fulfillRankRq # function fulfillRankRq(uint256 gameId, address player) internal _Fulfills the rank requirement for a player to join a game. gameId is the ID of the game. player is the address of the player. Modifies: Locks the rank token(s) of player in the rank token contract. If the game has additional ranks, locks the additional ranks of player in the respective rank token contracts._ emitRankRewards # function emitRankRewards(uint256 gameId, address[] leaderboard) internal _Emits rank rewards to the top addresses in the leaderboard for each rank in the game. gameId is the ID of the game. leaderboard is an array of addresses representing the leaderboard. Modifies: Calls emitRankReward for the main rank and each additional rank in the game._ removeAndUnlockPlayer # function removeAndUnlockPlayer(uint256 gameId, address player) internal _Removes a player from a game and unlocks their rank tokens. gameId is the ID of the game. player is the address of the player to be removed. Requirements: The game with gameId must exist. Modifies: Removes player from the game. If the game rank is greater than 1, unlocks the game rank token for player in the rank token contract and unlocks each additional rank token for player in the respective rank token contracts._ tryPlayerMove # function tryPlayerMove(uint256 gameId, address player) internal returns (bool) _Tries to make a move for a player in a game. gameId is the ID of the game. player is the address of the player. The \"move\" is considered to be a state when player has made all actions he could in the given turn. Requirements: The game with gameId must exist. Modifies: If the player has not voted and a vote is expected, or if the player has not made a proposal and a proposal is expected, does not make a move and returns false . Otherwise, makes a move for player and returns true ._ calculateScoresQuadratic # function calculateScoresQuadratic(uint256 gameId, uint256[][] votesRevealed, uint256[] proposerIndicies) internal returns (uint256[], uint256[]) _Calculates the scores using a quadratic formula based on the revealed votes and proposer indices. gameId is the ID of the game. votesRevealed is an array of revealed votes. proposerIndicies is an array of proposer indices that links proposals to index in getPlayers(). Returns: An array of updated scores for each player. An array of scores calculated for the current round._ LibReentrancyGuard # TBG_STORAGE_POSITION # bytes32 TBG_STORAGE_POSITION ReentrancyGuardStruct # struct ReentrancyGuardStruct { bool _entered; } reentrancyGuardStorage # function reentrancyGuardStorage() internal pure returns (struct LibReentrancyGuard.ReentrancyGuardStruct ds) LibTBG # _Library for managing turn-based games. It is designed to be used as a base library for games, and provides the following functionality: - setting game settings such as time per turn, max players, min players, etc as well as perform score and leaderboard tracking Limitations: - It is assumed there is only one game per player - It is assumed there is only on game master per game WARNING Some limitations: - This library is still under development and its interfaces may change. - getting game data (which has own storage assigement and can be encapsulated from library) however there is no storage slot collision checks in place_ GameSettings # struct GameSettings { uint256 timePerTurn; uint256 maxPlayersSize; uint256 minPlayersSize; uint256 timeToJoin; uint256 maxTurns; uint256 numWinners; uint256 voteCredits; string subject; } GameInstance # struct GameInstance { address gameMaster; uint256 currentTurn; uint256 turnStartedAt; uint256 registrationOpenAt; bool hasStarted; bool hasEnded; struct EnumerableSet.AddressSet players; mapping(address => bool) madeMove; uint256 numPlayersMadeMove; mapping(address => uint256) score; bytes32 implemenationStoragePointer; bool isOvertime; address[] leaderboard; } TBGStorageStruct # struct TBGStorageStruct { struct LibTBG.GameSettings settings; mapping(uint256 => struct LibTBG.GameInstance) games; mapping(address => uint256) playerInGame; uint256 totalGamesCreated; } TBG_STORAGE_POSITION # bytes32 TBG_STORAGE_POSITION IMPLEMENTATION_STORAGE_POSITION # bytes32 IMPLEMENTATION_STORAGE_POSITION TBGStorage # function TBGStorage() internal pure returns (struct LibTBG.TBGStorageStruct es) _getGame # function _getGame(uint256 gameId) internal view returns (struct LibTBG.GameInstance) init # function init(struct LibTBG.GameSettings settings) internal _Initializes the game with the provided settings. settings is the settings for the game. Requirements: settings.timePerTurn must not be zero. settings.maxPlayersSize must not be zero. settings.minPlayersSize must be at least 2. settings.maxTurns must not be zero. settings.numWinners must not be zero and must be less than settings.minPlayersSize . settings.timeToJoin must not be zero. settings.maxPlayersSize must not be less than settings.minPlayersSize . settings.subject must not be an empty string. Modifies: Sets the settings of the game to settings ._ createGame # function createGame(uint256 gameId, address gm) internal _Creates a new game with the provided game ID and game master. gameId is the ID of the game. gm is the address of the game master. Requirements: The game with gameId must not already exist. gm must not be the zero address. gameId must not be zero. The game master of the game with gameId must be the zero address. Modifies: Sets the game master of the game with gameId to gm . Increments the total number of games created._ deleteGame # function deleteGame(uint256 gameId) internal _Deletes a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. Modifies: Sets the game master, current turn, hasEnded, hasStarted, implementationStoragePointer, isOvertime, leaderboard, numPlayersMadeMove, players, registrationOpenAt, and turnStartedAt of the game with gameId to their initial values. Sets the score and madeMove of each player in the game with gameId to their initial values._ canBeJoined # function canBeJoined(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID can be joined. gameId is the ID of the game. Returns: A boolean indicating whether the game can be joined._ addPlayer # function addPlayer(uint256 gameId, address participant) internal _Adds a player to a game with the provided game ID. gameId is the ID of the game. participant is the address of the player. Requirements: The game with gameId must exist. participant must not already be in a game. The number of players in the game with gameId must be less than the maximum number of players. The game with gameId must be joinable. Modifies: Adds participant to the players of the game with gameId . Sets the madeMove of participant in the game with gameId to false. Sets the game of participant to gameId ._ isPlayerInGame # function isPlayerInGame(uint256 gameId, address player) internal view returns (bool) _Checks if a player is in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Returns: A boolean indicating whether the player is in the game._ removePlayer # function removePlayer(uint256 gameId, address participant) internal _Removes a player from a game with the provided game ID. gameId is the ID of the game. participant is the address of the player. Requirements: The game with gameId must exist. participant must be in the game with gameId . The game with gameId must not have started or must have ended. Modifies: Sets the game of participant to 0. Removes participant from the players of the game with gameId ._ isTurnTimedOut # function isTurnTimedOut(uint256 gameId) internal view returns (bool) _Checks if the current turn in a game with the provided game ID has timed out. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started. Returns: A boolean indicating whether the current turn has timed out._ gameExists # function gameExists(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID exists. gameId is the ID of the game. Returns: A boolean indicating whether the game exists._ enforceHasStarted # function enforceHasStarted(uint256 gameId) internal view _Enforces that a game with the provided game ID has started. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started._ canEndTurn # function canEndTurn(uint256 gameId) internal view returns (bool) _Enforces that a game with the provided game ID has started. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started._ canEndTurnEarly # function canEndTurnEarly(uint256 gameId) internal view returns (bool) _Checks if the current turn in a game with the provided game ID can end early. gameId is the ID of the game. Returns: A boolean indicating whether the current turn can end early._ onlyInTurnTime # modifier onlyInTurnTime(uint256 gameId) _Modifier that requires the current turn in a game with the provided game ID to be able to end. gameId is the ID of the game. Requirements: The current turn in the game with gameId must be able to end._ onlyWhenTurnCanEnd # modifier onlyWhenTurnCanEnd(uint256 gameId) _clearCurrentMoves # function _clearCurrentMoves(struct LibTBG.GameInstance game) internal _Clears the current moves in a game. game is the game. Modifies: Sets the madeMove of each player in game to false._ _resetPlayerStates # function _resetPlayerStates(struct LibTBG.GameInstance game) internal _Resets the states of the players in a game. game is the game. Modifies: Sets the madeMove and score of each player in game to their initial values._ setScore # function setScore(uint256 gameId, address player, uint256 value) internal _Sets the score of a player in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. value is the score. Requirements: player must be in the game with gameId . Modifies: Sets the score of player in the game with gameId to value ._ getScore # function getScore(uint256 gameId, address player) internal view returns (uint256) _Gets the score of a player in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Returns: The score of player in the game with gameId ._ getScores # function getScores(uint256 gameId) internal view returns (address[], uint256[]) _Gets the scores of the players in a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId . An array of the scores of the players in the game with gameId ._ openRegistration # function openRegistration(uint256 gameId) internal _Opens registration for a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. Modifies: Sets the registrationOpenAt of the game with gameId to the current block timestamp._ isRegistrationOpen # function isRegistrationOpen(uint256 gameId) internal view returns (bool) _Checks if registration is open for a game with the provided game ID. gameId is the ID of the game. Returns: A boolean indicating whether registration is open for the game._ canStart # function canStart(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID can start. gameId is the ID of the game. Returns: A boolean indicating whether the game can start._ canStartEarly # function canStartEarly(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID can start early. gameId is the ID of the game. By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached. Returns: A boolean indicating whether the game can start early._ startGameEarly # function startGameEarly(uint256 gameId) internal _Starts a game with the provided game ID early. gameId is the ID of the game. By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached. Requirements: The game with gameId must exist. The game with gameId must not have started. The game with gameId must have opened registration. The number of players in the game with gameId must be greater than or equal to the minimum number of players. The number of players in the game with gameId must be equal to the maximum number of players or the current block timestamp must be greater than the registration open time plus the time to join. Modifies: Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with gameId to their new values. Resets the states of the players in the game with gameId ._ startGame # function startGame(uint256 gameId) internal _Starts a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. The game with gameId must not have started. The game with gameId must have opened registration. The current block timestamp must be greater than the registration open time plus the time to join. Modifies: Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with gameId to their new values. Resets the states of the players in the game with gameId ._ getTurn # function getTurn(uint256 gameId) internal view returns (uint256) _Gets the current turn of a game with the provided game ID. gameId is the ID of the game. Returns: The current turn of the game with gameId ._ getGM # function getGM(uint256 gameId) internal view returns (address) _Gets the game master of a game with the provided game ID. gameId is the ID of the game. Returns: The game master of the game with gameId ._ isLastTurn # function isLastTurn(uint256 gameId) internal view returns (bool) _Checks if the current turn is the last turn in a game with the provided game ID. gameId is the ID of the game. Returns: A boolean indicating whether the current turn is the last turn in the game._ isGameOver # function isGameOver(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID is over. gameId is the ID of the game. Returns: A boolean indicating whether the game is over._ enforceIsNotOver # function enforceIsNotOver(uint256 gameId) internal view _Enforces that a game with the provided game ID is not over. gameId is the ID of the game. Requirements: The game with gameId must not be over._ playerMove # function playerMove(uint256 gameId, address player) internal _Records a player's move in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Requirements: The game with gameId must have started. The game with gameId must not be over. player must not have made a move in the current turn of the game with gameId . player must be in the game with gameId . Modifies: Sets the madeMove of player in the game with gameId to true. Increments the numPlayersMadeMove of the game with gameId ._ isPlayerTurnComplete # function isPlayerTurnComplete(uint256 gameId, address player) internal view returns (bool) enforceIsPlayingGame # function enforceIsPlayingGame(uint256 gameId, address player) internal view _Enforces that a player is in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Requirements: player must be in the game with gameId ._ hasStarted # function hasStarted(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID has started. gameId is the ID of the game. Returns: A boolean indicating whether the game has started._ getLeaderBoard # function getLeaderBoard(uint256 gameId) internal view returns (address[]) _Gets the leaderboard of a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId , sorted by score._ nextTurn # function nextTurn(uint256 gameId) internal returns (bool, bool, bool) _Advances to the next turn in a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must be able to end the current turn early. (all players have moved or the turn has timed out) Modifies: Clears the current moves in the game with gameId . Increments the currentTurn of the game with gameId . Sets the turnStartedAt of the game with gameId to the current block timestamp. If the current turn is the last turn or the game with gameId is in overtime, checks if the game is a tie and sets the isOvertime of the game with gameId to the result. Sets the hasEnded of the game with gameId to whether the game is over. Returns: A boolean indicating whether the current turn is the last turn. A boolean indicating whether the game is a tie. A boolean indicating whether the game is over._ getDataStorage # function getDataStorage() internal pure returns (bytes32 pointer) _Gets the data storage pointer. Returns: The data storage pointer._ getGameDataStorage # function getGameDataStorage(uint256 gameId) internal view returns (bytes32 pointer) _Gets the game data storage pointer of a game with the provided game ID. gameId is the ID of the game. Returns: The game data storage pointer of the game with gameId ._ getPlayersNumber # function getPlayersNumber(uint256 gameId) internal view returns (uint256) _Gets the number of players in a game with the provided game ID. gameId is the ID of the game. Returns: The number of players in the game with gameId ._ getPlayers # function getPlayers(uint256 gameId) internal view returns (address[]) _Gets the players in a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId ._ getGameSettings # function getGameSettings() internal view returns (struct LibTBG.GameSettings) _Gets the game settings. Returns: The game settings._ enforceIsPreRegistrationStage # function enforceIsPreRegistrationStage(uint256 gameId) internal view _Enforces that a game with the provided game ID is in the pre-registration stage. gameId is the ID of the game. Requirements: Registration must not be open for the game with gameId . The game with gameId must not have started._ addOvertime # function addOvertime(uint256 gameId) internal _Adds overtime to a game with the provided game ID. gameId is the ID of the game. Modifies: Sets the isOvertime of the game with gameId to true._ isOvertime # function isOvertime(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID is in overtime. gameId is the ID of the game. Returns: A boolean indicating whether the game is in overtime._ resetOvertime # function resetOvertime(uint256 gameId) internal _Resets the overtime of a game with the provided game ID. gameId is the ID of the game. Modifies: Sets the isOvertime of the game with gameId to false._ isTie # function isTie(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID is a tie. gameId is the ID of the game. Tie being defined as at least two of the top numWinners players having the same score. Returns: A boolean indicating whether the game is a tie._ getPlayersGame # function getPlayersGame(address player) internal view returns (uint256) _Gets the game ID of the game a player is in. player is the address of the player. Returns: The game ID of the game player is in._ sortByScore # function sortByScore(uint256 gameId) internal view returns (address[], uint256[]) _Sorts the players in a game with the provided game ID by score in descending order. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId , sorted by score. An array of the scores of the players in the game with gameId , sorted in descending order._ RankToken # rank # mapping(address => uint256) rank topRank # uint256 topRank _levelUpThreshold # uint256 _levelUpThreshold onlyRankingInstance # modifier onlyRankingInstance() constructor # constructor(string uri_, address owner_, string cURI, uint256 levelUpThreshold, address[] components, uint256[] componentWeights) public getRankingInstance # function getRankingInstance() public view returns (address) _Gets the ranking instance which can emit new rank updates and mint rank tokens. Returns: The address of the ranking instance._ contractURI # function contractURI() public view returns (string) setURI # function setURI(string uri_) public setContractURI # function setContractURI(string uri_) public Leader # event Leader(address account, uint256 rank) mint # function mint(address to, uint256 amount, uint256 level, bytes data) public updateRankingInstance # function updateRankingInstance(address newRankingInstance) public _Updates the ranking instance. newRankingInstance is the address of the new ranking instance. emits a RankingInstanceUpdated event._ lock # function lock(address account, uint256 id, uint256 amount) public unlock # function unlock(address account, uint256 id, uint256 amount) public batchMint # function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) public Mints specified amounts of tokens to an account. to is the address of the account to mint the tokens to. ids is the array of IDs of the tokens to mint. amounts is the array of amounts of tokens to mint. data is the additional data. levelUp # function levelUp(address to, uint256 level, bytes data) public findNewRank # function findNewRank(address account, uint256 oldRank) public view returns (uint256) _Finds the new rank of an account. account is the address of the account. oldRank is the old rank of the account. It checks the balance of the account and returns the new rank that can be upgraded to. Returns: The new rank of the account._ RankUpdated # event RankUpdated(address account, uint256 rank) _afterTokenTransfer # function _afterTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal _Hook that is called after any token transfer. This includes minting and burning, as well as batched variants. The same hook is called on both single and batched variants. For single transfers, the length of the id and amount arrays will be 1. Calling conditions (for each id and amount pair): When from and to are both non-zero, amount of from 's tokens of token type id will be transferred to to . When from is zero, amount tokens of token type id will be minted for to . when to is zero, amount of from 's tokens of token type id will be burned. from and to are never both zero. ids and amounts have the same, non-zero length. To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]._ getAccountRank # function getAccountRank(address account) external view returns (uint256) _Gets the rank of an account. account is the address of the account. Returns: The rank of the account._ supportsInterface # function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) Rankify # numTokens # uint256 numTokens constructor # constructor(address owner) public mint # function mint(address to, uint256 amount) public","title":"Solidity API"},{"location":"interfaces/solidity-api/#solidity-api","text":"","title":"Solidity API"},{"location":"interfaces/solidity-api/#compositeerc1155","text":"An abstract contract that extends LockableERC1155 and provides functionality for composite ERC1155 tokens. Composite tokens can be \"composed\" from multiple underlying assets, which however do not change their owner and in contrast to that use LockableERC1155 standard, which allows to read locked asset BalanceOf, OwnerOf methods correctly","title":"CompositeERC1155"},{"location":"interfaces/solidity-api/#constructor","text":"constructor(string uri_, address[] dimensionTokens, uint256[] tokenWeights) internal","title":"constructor"},{"location":"interfaces/solidity-api/#_mint","text":"function _mint(address to, uint256 tokenId, uint256 value, bytes data) internal virtual","title":"_mint"},{"location":"interfaces/solidity-api/#_burn","text":"function _burn(address from, uint256 id, uint256 amount) internal _Destroys amount tokens of token type id from from Emits a {TransferSingle} event. Requirements: from cannot be the zero address. from must have at least amount tokens of token type id ._","title":"_burn"},{"location":"interfaces/solidity-api/#decompose","text":"function decompose(address from, uint256 id, uint256 amount) public virtual Decomposes a composite ERC1155 token into its individual components. This function unlocks the specified amount of the composite token from each dimension, and then burns the specified amount of the composite token from the caller's balance.","title":"decompose"},{"location":"interfaces/solidity-api/#parameters","text":"Name Type Description from address The address from which the composite token is being decomposed. id uint256 The ID of the composite token being decomposed. amount uint256 The amount of the composite token to decompose.","title":"Parameters"},{"location":"interfaces/solidity-api/#burn","text":"function burn(address account, uint256 id, uint256 value) public virtual _Burns a specified amount of tokens from the given account. This will burn all underlying (composite) assets Requirements: - account must be the token owner or an approved operator. - id and value must be valid token ID and amount to burn. - All underlying \"composite\" assets implement burn as well_","title":"burn"},{"location":"interfaces/solidity-api/#parameters_1","text":"Name Type Description account address The address of the token owner. id uint256 The ID of the token to burn. value uint256 The amount of tokens to burn.","title":"Parameters"},{"location":"interfaces/solidity-api/#getcomponents","text":"function getComponents() public virtual returns (address[], uint256[]) Retrieves the components of the CompositeERC1155 contract.","title":"getComponents"},{"location":"interfaces/solidity-api/#return-values","text":"Name Type Description [0] address[] An array of component addresses and an array of component weights. [1] uint256[]","title":"Return Values"},{"location":"interfaces/solidity-api/#diamondreentrancyguard","text":"","title":"DiamondReentrancyGuard"},{"location":"interfaces/solidity-api/#nonreentrant","text":"modifier nonReentrant()","title":"nonReentrant"},{"location":"interfaces/solidity-api/#insufficient","text":"error insufficient(uint256 id, uint256 balance, uint256 required)","title":"insufficient"},{"location":"interfaces/solidity-api/#lockableerc1155","text":"This is an abstract contract that extends the ERC1155 token contract and implements the ILockableERC1155 interface. It provides functionality to lock and unlock token amounts for specific accounts and IDs.","title":"LockableERC1155"},{"location":"interfaces/solidity-api/#lockedamounts","text":"mapping(address => mapping(uint256 => uint256)) lockedAmounts","title":"lockedAmounts"},{"location":"interfaces/solidity-api/#lock","text":"function lock(address account, uint256 id, uint256 amount) public virtual Locks a specified amount of tokens for a given account and token ID. If the account does not have enough balance to lock the specified amount, the function will revert with an \"insufficient\" error message. Emits a TokensLocked event after successfully locking the tokens.","title":"lock"},{"location":"interfaces/solidity-api/#parameters_2","text":"Name Type Description account address The address of the account to lock tokens for. id uint256 The ID of the token to lock. amount uint256 The amount of tokens to lock.","title":"Parameters"},{"location":"interfaces/solidity-api/#unlock","text":"function unlock(address account, uint256 id, uint256 amount) public virtual Unlocks a specified amount of tokens for a given account and token ID. If the locked amount is less than the specified amount, it reverts with an \"insufficient\" error message. Emits a TokensUnlocked event after unlocking the tokens.","title":"unlock"},{"location":"interfaces/solidity-api/#parameters_3","text":"Name Type Description account address The address of the account to unlock tokens for. id uint256 The ID of the token to unlock. amount uint256 The amount of tokens to unlock.","title":"Parameters"},{"location":"interfaces/solidity-api/#unlockedbalanceof","text":"function unlockedBalanceOf(address account, uint256 id) public view returns (uint256) Returns the unlocked balance of a specific ERC1155 token for an account. The unlocked balance is calculated by subtracting the locked amount from the total balance.","title":"unlockedBalanceOf"},{"location":"interfaces/solidity-api/#parameters_4","text":"Name Type Description account address The address of the account. id uint256 The ID of the ERC1155 token.","title":"Parameters"},{"location":"interfaces/solidity-api/#return-values_1","text":"Name Type Description [0] uint256 The unlocked balance of the ERC1155 token for the account.","title":"Return Values"},{"location":"interfaces/solidity-api/#_beforetokentransfer","text":"function _beforeTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal virtual Hook function that is called before any token transfer. It checks if the transfer is allowed based on the locked amounts of the tokens. If the transfer is not allowed, it reverts with an error message.","title":"_beforeTokenTransfer"},{"location":"interfaces/solidity-api/#parameters_5","text":"Name Type Description operator address The address performing the token transfer. from address The address from which the tokens are being transferred. to address The address to which the tokens are being transferred. ids uint256[] An array of token IDs being transferred. amounts uint256[] An array of token amounts being transferred. data bytes Additional data attached to the transfer.","title":"Parameters"},{"location":"interfaces/solidity-api/#eip712","text":"_https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data. The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible, thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in their contracts using a combination of abi.encode and keccak256 . This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA ({_hashTypedDataV4}). The implementation of the domain separator was designed to be as efficient as possible while still properly updating the chain id to protect against replay attacks on an eventual fork of the chain. NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method https://docs.metamask.io/guide/signing-data.html[ eth_signTypedDataV4 in MetaMask]. _Available since v3.4.__","title":"EIP712"},{"location":"interfaces/solidity-api/#constructor_1","text":"constructor() internal _Initializes the domain separator and parameter caches. The meaning of name and version is specified in https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]: name : the user readable name of the signing domain, i.e. the name of the DApp or the protocol. version : the current major version of the signing domain. NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart contract upgrade]._","title":"constructor"},{"location":"interfaces/solidity-api/#_domainseparatorv4","text":"function _domainSeparatorV4() internal view returns (bytes32) Returns the domain separator for the current chain.","title":"_domainSeparatorV4"},{"location":"interfaces/solidity-api/#_hashtypeddatav4","text":"function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) _Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this function returns the hash of the fully encoded EIP712 message for this domain. This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example: bytes32 digest = _hashTypedDataV4(keccak256(abi.encode( keccak256(\"Mail(address to,string contents)\"), mailTo, keccak256(bytes(mailContents)) ))); address signer = ECDSA.recover(digest, signature); ```_ ## DNSFacet ### _isValidSignature ```solidity function _isValidSignature(bytes message, bytes signature, address account) internal view returns (bool)","title":"_hashTypedDataV4"},{"location":"interfaces/solidity-api/#initializedomain","text":"function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) public _Initializes new LibMultipass.Domain and configures it's parameters Requirements: registrar is not zero domainName is not empty domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names domainName does not exist yet onlyOwner referrerReward+referralDiscount cannot be larger than fee @param registrar address of registrar @param freeRegistrationsNumber number of registrations free of fee @param fee fee in base currency of network @param domainName name of LibMultipass.Domain @param referrerReward referral fee share in base currency of network @param referralDiscount referral discount in base currency of network Emits an {InitializedDomain} event._","title":"initializeDomain"},{"location":"interfaces/solidity-api/#activatedomain","text":"function activateDomain(bytes32 domainName) public _Activates LibMultipass.Domain name Requirements: msg.sender is Owner Emits an {DomainActivated} event._","title":"activateDomain"},{"location":"interfaces/solidity-api/#deactivatedomain","text":"function deactivateDomain(bytes32 domainName) public _Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements: msg.sender is Owner OR registrar Emits an {DomainDeactivated} event._","title":"deactivateDomain"},{"location":"interfaces/solidity-api/#changefee","text":"function changeFee(bytes32 domainName, uint256 fee) public _Changes registrar address Requirements: msg.sender is Owner Emits an {DomainFeeChanged} event._","title":"changeFee"},{"location":"interfaces/solidity-api/#changeregistrar","text":"function changeRegistrar(bytes32 domainName, address newRegistrar) public _Changes registrar address Requirements: msg.sender is Owner Emits an {RegistrarChangeRequested} event._","title":"changeRegistrar"},{"location":"interfaces/solidity-api/#deletename","text":"function deleteName(struct LibMultipass.NameQuery query) public _deletes name Requirements: msg.sender is Owner Emits an {DomainTTLChangeRequested} event._","title":"deleteName"},{"location":"interfaces/solidity-api/#changereferralprogram","text":"function changeReferralProgram(uint256 referrerReward, uint256 freeRegistrations, uint256 referralDiscount, bytes32 domainName) public","title":"changeReferralProgram"},{"location":"interfaces/solidity-api/#resolverecord","text":"function resolveRecord(struct LibMultipass.NameQuery query) public view returns (bool, struct LibMultipass.Record) resolves LibMultipass.Record of name query in to status and identity","title":"resolveRecord"},{"location":"interfaces/solidity-api/#register","text":"function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) public payable _registers new name under LibMultipass.Domain Requirements: all arguments must be set domainName must be active resolveRecord for given arguments should return no LibMultipass.Record Emits an {registered} event._","title":"register"},{"location":"interfaces/solidity-api/#getmodifyprice","text":"function getModifyPrice(struct LibMultipass.NameQuery query) public view returns (uint256)","title":"getModifyPrice"},{"location":"interfaces/solidity-api/#modifyusername","text":"function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) public payable _modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain_","title":"modifyUserName"},{"location":"interfaces/solidity-api/#parameters_6","text":"Name Type Description domainName bytes32 LibMultipass.Domain query struct LibMultipass.NameQuery newName bytes32 new name Emits an {Modified} event. registrarSignature bytes signatureDeadline uint256","title":"Parameters"},{"location":"interfaces/solidity-api/#getbalance","text":"function getBalance() external view returns (uint256) returns balance of this contract","title":"getBalance"},{"location":"interfaces/solidity-api/#getdomainstate","text":"function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain) returns LibMultipass.Domain state variables","title":"getDomainState"},{"location":"interfaces/solidity-api/#parameters_7","text":"Name Type Description domainName bytes32 name of the LibMultipass.Domain","title":"Parameters"},{"location":"interfaces/solidity-api/#return-values_2","text":"Name Type Description [0] struct LibMultipass.Domain (name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize)","title":"Return Values"},{"location":"interfaces/solidity-api/#getdomainstatebyidx","text":"function getDomainStateByIdx(uint256 index) external view returns (struct LibMultipass.Domain)","title":"getDomainStateByIdx"},{"location":"interfaces/solidity-api/#getcontractstate","text":"function getContractState() external view returns (uint256) returns contract state variables","title":"getContractState"},{"location":"interfaces/solidity-api/#return-values_3","text":"Name Type Description [0] uint256 (s_numDomains)","title":"Return Values"},{"location":"interfaces/solidity-api/#withrawfunds","text":"function withrawFunds(address to) public _Withraws funds stored in smart contract Requirements: onlyOwner Emits an {fundsWithdawn} event._","title":"withrawFunds"},{"location":"interfaces/solidity-api/#eip712inspectorfacet","text":"","title":"EIP712InspectorFacet"},{"location":"interfaces/solidity-api/#inspecteip712hashes","text":"function inspectEIP712Hashes() public view returns (bytes32 _CACHED_DOMAIN_SEPARATOR, uint256 _CACHED_CHAIN_ID, address _CACHED_THIS, bytes32 _HASHED_NAME, bytes32 _HASHED_VERSION, bytes32 _TYPE_HASH)","title":"inspectEIP712Hashes"},{"location":"interfaces/solidity-api/#currentchainid","text":"function currentChainId() public view returns (uint256)","title":"currentChainId"},{"location":"interfaces/solidity-api/#rankifyinstancegamemastersfacet","text":"","title":"RankifyInstanceGameMastersFacet"},{"location":"interfaces/solidity-api/#overtime","text":"event OverTime(uint256 gameId)","title":"OverTime"},{"location":"interfaces/solidity-api/#lastturn","text":"event LastTurn(uint256 gameId)","title":"LastTurn"},{"location":"interfaces/solidity-api/#proposalscore","text":"event ProposalScore(uint256 gameId, uint256 turn, string proposalHash, string proposal, uint256 score)","title":"ProposalScore"},{"location":"interfaces/solidity-api/#turnended","text":"event TurnEnded(uint256 gameId, uint256 turn, address[] players, uint256[] scores, string[] newProposals, uint256[] proposerIndicies, uint256[][] votes)","title":"TurnEnded"},{"location":"interfaces/solidity-api/#gameover","text":"event GameOver(uint256 gameId, address[] players, uint256[] scores)","title":"GameOver"},{"location":"interfaces/solidity-api/#proposalsubmitted","text":"event ProposalSubmitted(uint256 gameId, uint256 turn, address proposer, bytes32 commitmentHash, string proposalEncryptedByGM)","title":"ProposalSubmitted"},{"location":"interfaces/solidity-api/#proposalparams","text":"struct ProposalParams { uint256 gameId; string encryptedProposal; bytes32 commitmentHash; address proposer; }","title":"ProposalParams"},{"location":"interfaces/solidity-api/#votesubmitted","text":"event VoteSubmitted(uint256 gameId, uint256 turn, address player, string votesHidden)","title":"VoteSubmitted"},{"location":"interfaces/solidity-api/#submitvote","text":"function submitVote(uint256 gameId, string encryptedVotes, address voter) public _Submits a vote for a game. gameId is the ID of the game. encryptedVotes is the encrypted votes. voter is the address of the voter. Emits a VoteSubmitted event. Requirements: The caller must be a game master of the game with gameId . The game with gameId must exist. The game with gameId must have started. The game with gameId must not be over. voter must be in the game with gameId . The current turn of the game with gameId must be greater than 1._","title":"submitVote"},{"location":"interfaces/solidity-api/#submitproposal","text":"function submitProposal(struct RankifyInstanceGameMastersFacet.ProposalParams proposalData) public _Submits a proposal for a game. proposalData is the proposal data. Requirements: The game with proposalData.gameId must exist. The caller must be a game master of the game with proposalData.gameId ._","title":"submitProposal"},{"location":"interfaces/solidity-api/#endturn","text":"function endTurn(uint256 gameId, uint256[][] votes, string[] newProposals, uint256[] proposerIndicies) public _Ends the current turn of a game with the provided game ID. gameId is the ID of the game. votes is the array of votes. newProposals is the array of new proposals for the upcoming voting round. proposerIndicies is the array of indices of the proposers in the previous voting round. emits a ProposalScore event for each player if the turn is not the first. emits a TurnEnded event. Modifies: Calls the _nextTurn function with gameId and newProposals . Resets the number of commitments of the game with gameId to 0. Resets the proposal commitment hash and ongoing proposal of each player in the game with gameId . Requirements: The caller must be a game master of the game with gameId . The game with gameId must have started. The game with gameId must not be over. newProposals array MUST be sorted randomly to ensure privacy votes and proposerIndicies MUST correspond to players array from game.getPlayers()_","title":"endTurn"},{"location":"interfaces/solidity-api/#zerovalue","text":"error ZeroValue()","title":"ZeroValue"},{"location":"interfaces/solidity-api/#wrongaddress","text":"error WrongAddress()","title":"WrongAddress"},{"location":"interfaces/solidity-api/#outofbounds","text":"error OutOfBounds()","title":"OutOfBounds"},{"location":"interfaces/solidity-api/#rankifyinstancegameownersfacet","text":"","title":"RankifyInstanceGameOwnersFacet"},{"location":"interfaces/solidity-api/#rinstancestorage","text":"function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog)","title":"RInstanceStorage"},{"location":"interfaces/solidity-api/#setgameprice","text":"function setGamePrice(uint256 newPrice) external _Sets the game price. newPrice is the new game price. Modifies: Sets the game price to newPrice . Requirements: The caller must be the contract owner._","title":"setGamePrice"},{"location":"interfaces/solidity-api/#setjoingameprice","text":"function setJoinGamePrice(uint256 newPrice) external _Sets the join game price. newPrice is the new join game price. Modifies: Sets the join game price to newPrice . Requirements: The caller must be the contract owner._","title":"setJoinGamePrice"},{"location":"interfaces/solidity-api/#setranktokenaddress","text":"function setRankTokenAddress(address newRankToken) external _Sets the rank token address. newRankToken is the new rank token address. Modifies: Sets the rank token address to newRankToken . Requirements: The caller must be the contract owner. newRankToken must not be the zero address. newRankToken must support the ERC1155 interface._","title":"setRankTokenAddress"},{"location":"interfaces/solidity-api/#settimeperturn","text":"function setTimePerTurn(uint256 newTimePerTurn) external _Sets the time per turn. newTimePerTurn is the new time per turn. Modifies: Sets the time per turn to newTimePerTurn . Requirements: The caller must be the contract owner._","title":"setTimePerTurn"},{"location":"interfaces/solidity-api/#setmaxplayerssize","text":"function setMaxPlayersSize(uint256 newMaxPlayersSize) external _Sets the maximum number of players in a game. newMaxPlayersSize is the new maximum number of players. Modifies: Sets the maximum number of players to newMaxPlayersSize . Requirements: The caller must be the contract owner. newMaxPlayersSize must be greater than or equal to the minimum number of players._","title":"setMaxPlayersSize"},{"location":"interfaces/solidity-api/#setminplayerssize","text":"function setMinPlayersSize(uint256 newMinPlayersSize) external _Sets the minimum number of players in a game. newMinPlayersSize is the new minimum number of players. Modifies: Sets the minimum number of players to newMinPlayersSize . Requirements: The caller must be the contract owner. newMinPlayersSize must be less than or equal to the maximum number of players._","title":"setMinPlayersSize"},{"location":"interfaces/solidity-api/#settimetojoin","text":"function setTimeToJoin(uint256 newTimeToJoin) external _Sets the time to join a game. newTimeToJoin is the new time to join. Modifies: Sets the time to join to newTimeToJoin . Requirements: The caller must be the contract owner. newTimeToJoin must not be zero._","title":"setTimeToJoin"},{"location":"interfaces/solidity-api/#setmaxturns","text":"function setMaxTurns(uint256 newMaxTurns) external _Sets the maximum number of turns in a game. newMaxTurns is the new maximum number of turns. Modifies: Sets the maximum number of turns to newMaxTurns . Requirements: The caller must be the contract owner. newMaxTurns must not be zero._","title":"setMaxTurns"},{"location":"interfaces/solidity-api/#rankifyinstancemainfacet","text":"","title":"RankifyInstanceMainFacet"},{"location":"interfaces/solidity-api/#rinstancestorage_1","text":"function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog)","title":"RInstanceStorage"},{"location":"interfaces/solidity-api/#creategame","text":"function createGame(address gameMaster, uint256 gameId, uint256 gameRank) public _Creates a new game with the provided game master, game ID, and game rank. Optionally, additional ranks can be provided. gameMaster is the address of the game master. gameId is the ID of the new game. gameRank is the rank of the new game. additionalRanks is the array of additional ranks. emits a GameCreated event. Requirements: There are some game price requirments that must be met under gameId.newGame function that are set during the contract initialization and refer to the contract maintainer benefits. Modifies: Calls the newGame function with gameMaster , gameRank , and msg.sender . Configures the coin vending with gameId and an empty configuration. If additionalRanks is not empty, mints rank tokens for each additional rank and sets the additional ranks of the game with gameId to additionalRanks ._","title":"createGame"},{"location":"interfaces/solidity-api/#creategame_1","text":"function createGame(address gameMaster, uint256 gameId, uint256 gameRank, address[] additionalRanks) public","title":"createGame"},{"location":"interfaces/solidity-api/#creategame_2","text":"function createGame(address gameMaster, uint256 gameRank) public","title":"createGame"},{"location":"interfaces/solidity-api/#cancelgame","text":"function cancelGame(uint256 gameId) public _Cancels a game with the provided game ID. gameId is the ID of the game. Modifies: Calls the enforceIsGameCreator function with msg.sender . Requirements: The caller must be the game creator of the game with gameId . Game must not be started._","title":"cancelGame"},{"location":"interfaces/solidity-api/#leavegame","text":"function leaveGame(uint256 gameId) public _Allows a player to leave a game with the provided game ID. gameId is the ID of the game. Modifies: Calls the quitGame function with msg.sender , true , and onPlayerQuit . Requirements: The caller must be a player in the game with gameId . Game must not be started._","title":"leaveGame"},{"location":"interfaces/solidity-api/#openregistration","text":"function openRegistration(uint256 gameId) public _Opens registration for a game with the provided game ID. gameId is the ID of the game. emits a RegistrationOpen event. Modifies: Calls the enforceIsGameCreator function with msg.sender . Calls the enforceIsPreRegistrationStage function. Calls the openRegistration function. Requirements: The caller must be the game creator of the game with gameId . The game with gameId must be in the pre-registration stage._","title":"openRegistration"},{"location":"interfaces/solidity-api/#joingame","text":"function joinGame(uint256 gameId) public payable _Allows a player to join a game with the provided game ID. gameId is the ID of the game. emits a PlayerJoined event. Modifies: Calls the joinGame function with msg.sender . Calls the fund function with bytes32(gameId) . Requirements: The caller must not be a player in the game with gameId . Game phase must be registration. Caller must be able to fulfill funding requirements._","title":"joinGame"},{"location":"interfaces/solidity-api/#startgame","text":"function startGame(uint256 gameId) public _Starts a game with the provided game ID early. gameId is the ID of the game. emits a GameStarted event. Modifies: Calls the enforceGameExists function. Calls the startGameEarly function. Requirements: The game with gameId must exist._","title":"startGame"},{"location":"interfaces/solidity-api/#onerc1155received","text":"function onERC1155Received(address operator, address, uint256, uint256, bytes) public view returns (bytes4)","title":"onERC1155Received"},{"location":"interfaces/solidity-api/#onerc1155batchreceived","text":"function onERC1155BatchReceived(address operator, address, uint256[], uint256[], bytes) external view returns (bytes4)","title":"onERC1155BatchReceived"},{"location":"interfaces/solidity-api/#onerc721received","text":"function onERC721Received(address operator, address, uint256, bytes) external view returns (bytes4)","title":"onERC721Received"},{"location":"interfaces/solidity-api/#getcontractstate_1","text":"function getContractState() public view returns (struct IRankifyInstanceCommons.RInstanceState)","title":"getContractState"},{"location":"interfaces/solidity-api/#getturn","text":"function getTurn(uint256 gameId) public view returns (uint256)","title":"getTurn"},{"location":"interfaces/solidity-api/#getgm","text":"function getGM(uint256 gameId) public view returns (address)","title":"getGM"},{"location":"interfaces/solidity-api/#getscores","text":"function getScores(uint256 gameId) public view returns (address[], uint256[])","title":"getScores"},{"location":"interfaces/solidity-api/#isovertime","text":"function isOvertime(uint256 gameId) public view returns (bool)","title":"isOvertime"},{"location":"interfaces/solidity-api/#isgameover","text":"function isGameOver(uint256 gameId) public view returns (bool)","title":"isGameOver"},{"location":"interfaces/solidity-api/#getplayersgame","text":"function getPlayersGame(address player) public view returns (uint256)","title":"getPlayersGame"},{"location":"interfaces/solidity-api/#islastturn","text":"function isLastTurn(uint256 gameId) public view returns (bool)","title":"isLastTurn"},{"location":"interfaces/solidity-api/#isregistrationopen","text":"function isRegistrationOpen(uint256 gameId) public view returns (bool)","title":"isRegistrationOpen"},{"location":"interfaces/solidity-api/#gamecreator","text":"function gameCreator(uint256 gameId) public view returns (address)","title":"gameCreator"},{"location":"interfaces/solidity-api/#getgamerank","text":"function getGameRank(uint256 gameId) public view returns (uint256)","title":"getGameRank"},{"location":"interfaces/solidity-api/#getplayers","text":"function getPlayers(uint256 gameId) public view returns (address[])","title":"getPlayers"},{"location":"interfaces/solidity-api/#canstartgame","text":"function canStartGame(uint256 gameId) public view returns (bool)","title":"canStartGame"},{"location":"interfaces/solidity-api/#canendturn","text":"function canEndTurn(uint256 gameId) public view returns (bool)","title":"canEndTurn"},{"location":"interfaces/solidity-api/#isplayerturncomplete","text":"function isPlayerTurnComplete(uint256 gameId, address player) public view returns (bool)","title":"isPlayerTurnComplete"},{"location":"interfaces/solidity-api/#getplayervotedarray","text":"function getPlayerVotedArray(uint256 gameId) public view returns (bool[])","title":"getPlayerVotedArray"},{"location":"interfaces/solidity-api/#getplayersmoved","text":"function getPlayersMoved(uint256 gameId) public view returns (bool[], uint256)","title":"getPlayersMoved"},{"location":"interfaces/solidity-api/#rankifyinstancerequirementsfacet","text":"","title":"RankifyInstanceRequirementsFacet"},{"location":"interfaces/solidity-api/#requirementsconfigured","text":"event RequirementsConfigured(uint256 gameId, struct LibCoinVending.ConfigPosition config)","title":"RequirementsConfigured"},{"location":"interfaces/solidity-api/#setjoinrequirements","text":"function setJoinRequirements(uint256 gameId, struct LibCoinVending.ConfigPosition config) public Sets the join requirements for a specific game. Only the game creator can call this function. The game must be in the pre-registration stage.","title":"setJoinRequirements"},{"location":"interfaces/solidity-api/#parameters_8","text":"Name Type Description gameId uint256 The ID of the game. config struct LibCoinVending.ConfigPosition The configuration position for the join requirements.","title":"Parameters"},{"location":"interfaces/solidity-api/#getjoinrequirements","text":"function getJoinRequirements(uint256 gameId) public view returns (struct LibCoinVending.ConditionReturn) Retrieves the join requirements for a specific game.","title":"getJoinRequirements"},{"location":"interfaces/solidity-api/#parameters_9","text":"Name Type Description gameId uint256 The ID of the game.","title":"Parameters"},{"location":"interfaces/solidity-api/#return-values_4","text":"Name Type Description [0] struct LibCoinVending.ConditionReturn The join requirements as a LibCoinVending.ConditionReturn struct.","title":"Return Values"},{"location":"interfaces/solidity-api/#getjoinrequirementsbytoken","text":"function getJoinRequirementsByToken(uint256 gameId, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) public view returns (struct LibCoinVending.ContractCondition) Retrieves the join requirements for a specific token in a game.","title":"getJoinRequirementsByToken"},{"location":"interfaces/solidity-api/#parameters_10","text":"Name Type Description gameId uint256 The ID of the game. contractAddress address The address of the contract. contractId uint256 The ID of the contract. contractType enum LibCoinVending.ContractTypes The type of the contract.","title":"Parameters"},{"location":"interfaces/solidity-api/#return-values_5","text":"Name Type Description [0] struct LibCoinVending.ContractCondition The join requirements for the specified token.","title":"Return Values"},{"location":"interfaces/solidity-api/#ierc1155receiver","text":"","title":"IERC1155Receiver"},{"location":"interfaces/solidity-api/#onerc1155received_1","text":"function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes data) external returns (bytes4) validate receipt of ERC1155 transfer","title":"onERC1155Received"},{"location":"interfaces/solidity-api/#parameters_11","text":"Name Type Description operator address executor of transfer from address sender of tokens id uint256 token ID received value uint256 quantity of tokens received data bytes data payload","title":"Parameters"},{"location":"interfaces/solidity-api/#return-values_6","text":"Name Type Description [0] bytes4 function's own selector if transfer is accepted","title":"Return Values"},{"location":"interfaces/solidity-api/#onerc1155batchreceived_1","text":"function onERC1155BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data) external returns (bytes4) validate receipt of ERC1155 batch transfer","title":"onERC1155BatchReceived"},{"location":"interfaces/solidity-api/#parameters_12","text":"Name Type Description operator address executor of transfer from address sender of tokens ids uint256[] token IDs received values uint256[] quantities of tokens received data bytes data payload","title":"Parameters"},{"location":"interfaces/solidity-api/#return-values_7","text":"Name Type Description [0] bytes4 function's own selector if transfer is accepted","title":"Return Values"},{"location":"interfaces/solidity-api/#ilockableerc1155","text":"Interface for a lockable ERC1155 token contract.","title":"ILockableERC1155"},{"location":"interfaces/solidity-api/#tokenslocked","text":"event TokensLocked(address account, uint256 id, uint256 value)","title":"TokensLocked"},{"location":"interfaces/solidity-api/#tokensunlocked","text":"event TokensUnlocked(address account, uint256 id, uint256 value)","title":"TokensUnlocked"},{"location":"interfaces/solidity-api/#lock_1","text":"function lock(address account, uint256 id, uint256 amount) external _Locks a specified amount of tokens for a given account and token ID. account is the address of the account to lock the tokens for. id is the ID of the token to lock. amount is the amount of tokens to lock. emits a TokensLocked event._","title":"lock"},{"location":"interfaces/solidity-api/#unlock_1","text":"function unlock(address account, uint256 id, uint256 amount) external _Unlocks a specified amount of tokens for a given account and token ID. account is the address of the account to unlock the tokens for. id is the ID of the token to unlock. amount is the amount of tokens to unlock. emits a TokensUnlocked event._","title":"unlock"},{"location":"interfaces/solidity-api/#unlockedbalanceof_1","text":"function unlockedBalanceOf(address account, uint256 id) external view returns (uint256) _Returns the unlocked balance of tokens for a given account and token ID. account is the address of the account to check the unlocked balance for. id is the ID of the token to check the unlocked balance for. Returns: The unlocked balance of tokens._","title":"unlockedBalanceOf"},{"location":"interfaces/solidity-api/#imultipass","text":"","title":"IMultipass"},{"location":"interfaces/solidity-api/#resolverecord_1","text":"function resolveRecord(struct LibMultipass.NameQuery query) external view returns (bool, struct LibMultipass.Record)","title":"resolveRecord"},{"location":"interfaces/solidity-api/#initializedomain_1","text":"function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) external _Initializes new LibMultipass.Domain and configures it's parameters Requirements: registrar is not zero domainName is not empty domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names domainName does not exist yet onlyOwner referrerReward+referralDiscount cannot be larger than fee @param registrar address of registrar @param freeRegistrationsNumber number of registrations free of fee @param fee fee in base currency of network @param domainName name of LibMultipass.Domain @param referrerReward referral fee share in base currency of network @param referralDiscount referral discount in base currency of network Emits an {InitializedDomain} event._","title":"initializeDomain"},{"location":"interfaces/solidity-api/#activatedomain_1","text":"function activateDomain(bytes32 domainName) external _Activates LibMultipass.Domain name Requirements: msg.sender is Owner Emits an {DomainActivated} event._","title":"activateDomain"},{"location":"interfaces/solidity-api/#deactivatedomain_1","text":"function deactivateDomain(bytes32 domainName) external _Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements: msg.sender is Owner OR registrar Emits an {DomainDeactivated} event._","title":"deactivateDomain"},{"location":"interfaces/solidity-api/#changefee_1","text":"function changeFee(bytes32 domainName, uint256 fee) external _Changes registrar address Requirements: msg.sender is Owner Emits an {DomainFeeChanged} event._","title":"changeFee"},{"location":"interfaces/solidity-api/#changeregistrar_1","text":"function changeRegistrar(bytes32 domainName, address newRegistrar) external _Changes registrar address Requirements: msg.sender is Owner Emits an {RegistrarChangeRequested} event._","title":"changeRegistrar"},{"location":"interfaces/solidity-api/#deletename_1","text":"function deleteName(struct LibMultipass.NameQuery query) external _deletes name Requirements: msg.sender is Owner Emits an {DomainTTLChangeRequested} event._","title":"deleteName"},{"location":"interfaces/solidity-api/#changereferralprogram_1","text":"function changeReferralProgram(uint256 referrerFeeShare, uint256 referralDiscount, uint256 freeRegistrations, bytes32 domainName) external _executes all pending changes to LibMultipass.Domain that fulfill TTL Requirements: domainName must be set referrerFeeShare+referralDiscount cannot be larger than 2^32 Emits an {ReferralProgramChangeRequested} event._","title":"changeReferralProgram"},{"location":"interfaces/solidity-api/#register_1","text":"function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) external payable _registers new name under LibMultipass.Domain Requirements: all arguments must be set domainName must be active resolveRecord for given arguments should return no LibMultipass.Record Emits an {registered} event._","title":"register"},{"location":"interfaces/solidity-api/#modifyusername_1","text":"function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) external payable _modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain_","title":"modifyUserName"},{"location":"interfaces/solidity-api/#parameters_13","text":"Name Type Description domainName bytes32 LibMultipass.Domain query struct LibMultipass.NameQuery newName bytes32 new name Emits an {Modified} event. registrarSignature bytes signatureDeadline uint256","title":"Parameters"},{"location":"interfaces/solidity-api/#getbalance_1","text":"function getBalance() external view returns (uint256) returns balance of this contract","title":"getBalance"},{"location":"interfaces/solidity-api/#getdomainstate_1","text":"function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain) returns LibMultipass.Domain state variables","title":"getDomainState"},{"location":"interfaces/solidity-api/#parameters_14","text":"Name Type Description domainName bytes32 name of the LibMultipass.Domain","title":"Parameters"},{"location":"interfaces/solidity-api/#return-values_8","text":"Name Type Description [0] struct LibMultipass.Domain (name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize)","title":"Return Values"},{"location":"interfaces/solidity-api/#getcontractstate_2","text":"function getContractState() external view returns (uint256) returns contract state variables","title":"getContractState"},{"location":"interfaces/solidity-api/#return-values_9","text":"Name Type Description [0] uint256 (s_numDomains)","title":"Return Values"},{"location":"interfaces/solidity-api/#withrawfunds_1","text":"function withrawFunds(address to) external _Withraws funds stored in smart contract Requirements: onlyOwner Emits an {fundsWithdawn} event._","title":"withrawFunds"},{"location":"interfaces/solidity-api/#getmodifyprice_1","text":"function getModifyPrice(struct LibMultipass.NameQuery query) external view returns (uint256)","title":"getModifyPrice"},{"location":"interfaces/solidity-api/#fundswithdawn","text":"event fundsWithdawn(uint256 amount, address account)","title":"fundsWithdawn"},{"location":"interfaces/solidity-api/#initializeddomain","text":"event InitializedDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount)","title":"InitializedDomain"},{"location":"interfaces/solidity-api/#domainactivated","text":"event DomainActivated(bytes32 domainName)","title":"DomainActivated"},{"location":"interfaces/solidity-api/#domaindeactivated","text":"event DomainDeactivated(bytes32 domainName)","title":"DomainDeactivated"},{"location":"interfaces/solidity-api/#domainfeechanged","text":"event DomainFeeChanged(bytes32 domainName, uint256 newFee)","title":"DomainFeeChanged"},{"location":"interfaces/solidity-api/#freeregistrationschanged","text":"event FreeRegistrationsChanged(uint256 domainIndex, uint256 newAmount)","title":"FreeRegistrationsChanged"},{"location":"interfaces/solidity-api/#registrarchangerequested","text":"event RegistrarChangeRequested(bytes32 domainName, address registrar)","title":"RegistrarChangeRequested"},{"location":"interfaces/solidity-api/#domainnamechangerequested","text":"event DomainNameChangeRequested(uint256 domainIndex, bytes32 NewDomainName)","title":"DomainNameChangeRequested"},{"location":"interfaces/solidity-api/#namedeleted","text":"event nameDeleted(bytes32 domainName, address wallet, bytes32 id, bytes32 name)","title":"nameDeleted"},{"location":"interfaces/solidity-api/#domainttlchangerequested","text":"event DomainTTLChangeRequested(bytes32 domainName, uint256 amount)","title":"DomainTTLChangeRequested"},{"location":"interfaces/solidity-api/#referralprogramchanged","text":"event ReferralProgramChanged(bytes32 domainName, uint256 reward, uint256 discount, uint256 freeNumber)","title":"ReferralProgramChanged"},{"location":"interfaces/solidity-api/#domainchangesarelive","text":"event DomainChangesAreLive(bytes32 domainName, bytes32[] changes)","title":"DomainChangesAreLive"},{"location":"interfaces/solidity-api/#changesqeuecanceled","text":"event changesQeueCanceled(bytes32 domainName, bytes32[] changes)","title":"changesQeueCanceled"},{"location":"interfaces/solidity-api/#registered","text":"event Registered(bytes32 domainName, struct LibMultipass.Record NewRecord)","title":"Registered"},{"location":"interfaces/solidity-api/#referred","text":"event Referred(struct LibMultipass.Record refferrer, struct LibMultipass.Record newRecord, bytes32 domainName)","title":"Referred"},{"location":"interfaces/solidity-api/#userrecordmodified","text":"event UserRecordModified(struct LibMultipass.Record newRecord, bytes32 oldName, bytes32 domainName)","title":"UserRecordModified"},{"location":"interfaces/solidity-api/#iranktoken","text":"","title":"IRankToken"},{"location":"interfaces/solidity-api/#rankinginstanceupdated","text":"event RankingInstanceUpdated(address newRankingInstance)","title":"RankingInstanceUpdated"},{"location":"interfaces/solidity-api/#levelup","text":"event LevelUp(address account, uint256 id)","title":"LevelUp"},{"location":"interfaces/solidity-api/#mint","text":"function mint(address to, uint256 amount, uint256 poolId, bytes data) external Mints a specified amount of tokens to an account. to is the address of the account to mint the tokens to. amount is the amount of tokens to mint. poolId is the ID of the pool. data is the additional data.","title":"mint"},{"location":"interfaces/solidity-api/#batchmint","text":"function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) external Mints specified amounts of tokens to an account. to is the address of the account to mint the tokens to. ids is the array of IDs of the tokens to mint. amounts is the array of amounts of tokens to mint. data is the additional data.","title":"batchMint"},{"location":"interfaces/solidity-api/#levelup_1","text":"function levelUp(address to, uint256 id, bytes data) external _Levels up an account. to is the address of the account to level up. id is the ID of the token. data is the additional data. emits a LevelUp event._","title":"levelUp"},{"location":"interfaces/solidity-api/#updaterankinginstance","text":"function updateRankingInstance(address newRankingInstance) external _Updates the ranking instance. newRankingInstance is the address of the new ranking instance. emits a RankingInstanceUpdated event._","title":"updateRankingInstance"},{"location":"interfaces/solidity-api/#getrankinginstance","text":"function getRankingInstance() external view returns (address) _Gets the ranking instance which can emit new rank updates and mint rank tokens. Returns: The address of the ranking instance._","title":"getRankingInstance"},{"location":"interfaces/solidity-api/#findnewrank","text":"function findNewRank(address account, uint256 oldRank) external view returns (uint256) _Finds the new rank of an account. account is the address of the account. oldRank is the old rank of the account. It checks the balance of the account and returns the new rank that can be upgraded to. Returns: The new rank of the account._","title":"findNewRank"},{"location":"interfaces/solidity-api/#getaccountrank","text":"function getAccountRank(address account) external view returns (uint256) _Gets the rank of an account. account is the address of the account. Returns: The rank of the account._","title":"getAccountRank"},{"location":"interfaces/solidity-api/#irankifyinstancecommons","text":"","title":"IRankifyInstanceCommons"},{"location":"interfaces/solidity-api/#score","text":"struct Score { address participant; uint256 score; }","title":"Score"},{"location":"interfaces/solidity-api/#rinstancesettings","text":"struct RInstanceSettings { uint256 gamePrice; address gamePaymentToken; uint256 joinGamePrice; uint256 numGames; address rankTokenAddress; bool contractInitialized; struct LibQuadraticVoting.qVotingStruct voting; }","title":"RInstanceSettings"},{"location":"interfaces/solidity-api/#rinstancestate","text":"struct RInstanceState { struct IRankifyInstanceCommons.RInstanceSettings BestOfState; struct LibTBG.GameSettings TBGSEttings; }","title":"RInstanceState"},{"location":"interfaces/solidity-api/#votehidden","text":"struct VoteHidden { bytes32 hash; bytes proof; }","title":"VoteHidden"},{"location":"interfaces/solidity-api/#rinstance","text":"struct RInstance { uint256 rank; address createdBy; mapping(uint256 => string) ongoingProposals; uint256 numOngoingProposals; uint256 numPrevProposals; mapping(address => bytes32) proposalCommitmentHashes; uint256 numCommitments; mapping(address => struct IRankifyInstanceCommons.VoteHidden) votesHidden; address[] additionalRanks; uint256 paymentsBalance; uint256 numVotesThisTurn; uint256 numVotesPrevTurn; mapping(address => bool) playerVoted; }","title":"RInstance"},{"location":"interfaces/solidity-api/#registrationopen","text":"event RegistrationOpen(uint256 gameid)","title":"RegistrationOpen"},{"location":"interfaces/solidity-api/#playerjoined","text":"event PlayerJoined(uint256 gameId, address participant)","title":"PlayerJoined"},{"location":"interfaces/solidity-api/#gamestarted","text":"event GameStarted(uint256 gameId)","title":"GameStarted"},{"location":"interfaces/solidity-api/#gamecreated","text":"event gameCreated(uint256 gameId, address gm, address creator, uint256 rank)","title":"gameCreated"},{"location":"interfaces/solidity-api/#gameclosed","text":"event GameClosed(uint256 gameId)","title":"GameClosed"},{"location":"interfaces/solidity-api/#playerleft","text":"event PlayerLeft(uint256 gameId, address player)","title":"PlayerLeft"},{"location":"interfaces/solidity-api/#libarray","text":"","title":"LibArray"},{"location":"interfaces/solidity-api/#quicksort","text":"function quickSort(uint256[] arr, int256 left, int256 right) internal view _Sorts the elements of the array in ascending order using the quicksort algorithm. Requirements: The array to be sorted must not be empty. The starting and ending indices must be within the bounds of the array. Modifies: The array is sorted in ascending order. Note: This function uses the in-place quicksort algorithm, which has an average-case complexity of O(n log n) and a worst-case complexity of O(n^2)._","title":"quickSort"},{"location":"interfaces/solidity-api/#libcoinvending","text":"_This library is used to simulate the vending machine coin acceptor state machine that: - Supports large number of positions; Each represents requirements to acess different goods of the virtual vending machine. - Accepts multiple assets of following types: Native (Eth), ERC20, ERC721, and ERC1155 tokens that can be stacked together. - Allows for each individual asset action promise can be one of following: - Lock: The asset is locked in the acceptor with promise that asset will be returned to the sender at release funds time. - Bet: The asset is locked in the acceptor with promise that asset will be awarded to benificiary at release funds time. - Pay: The asset is locked in the acceptor with promise that asset will be paid to payee at release funds time. - Burn: The asset is locked in the acceptor with promise that asset will be destroyed at release funds time. - Maintains each position balance, hence allowing multiple participants to line up for the same position. - Allows three actions: - Fund position with assets - Refund assets to user - Consume assets and provide goods to user - Consuming asset might take a form of - Transferring assets to payee - Burning assets - Awarding beneficiary with assets - Returning locked assets back to sender This library DOES enforces that any position can only be refunded or processed only within amount funded boundaries This library DOES NOT store the addresses of senders, nor benificiaries, nor payees. This is to be stored within implementation contract. !!!!! IMPORTANT !!!!! This library does NOT invocates reentrancy guards. It is implementation contract's responsibility to enforce reentrancy guards. Reentrancy guards MUST be implemented in an implementing contract. Usage: Configure position via configure(...) fund position with assets via fund(...) release or refund assets via release(...) or refund(...) repeat steps 1 and 2 as needed. Position can be recofigured at any time when it's effective balance is zero: timesFunded - timesRefuned - timesReleased = 0 Test state: This library most functionality has been tested: see ../tests/LibCoinVending.ts and ../tests/report.md for details. ERC721 token is checked only for \"HAVE\" condition since putting requirements on non fungable token id yet to be resolved. (see ERC721 section in the code below) This library has not been yet audited_","title":"LibCoinVending"},{"location":"interfaces/solidity-api/#condition","text":"struct Condition { mapping(enum LibCoinVending.ContractTypes => mapping(address => mapping(uint256 => struct LibCoinVending.ContractCondition))) contracts; struct LibCoinVending.NumericCondition ethValues; uint256 timesRefunded; uint256 timesReleased; uint256 timesFunded; enum LibCoinVending.ContractTypes[] contractTypes; address[] contractAddresses; uint256[] contractIds; bool _isConfigured; }","title":"Condition"},{"location":"interfaces/solidity-api/#requirementtypes","text":"enum RequirementTypes { HAVE, LOCK, BURN, BET, PAY }","title":"RequirementTypes"},{"location":"interfaces/solidity-api/#transactionproperties","text":"struct TransactionProperties { bytes data; uint256 amount; }","title":"TransactionProperties"},{"location":"interfaces/solidity-api/#contractcondition","text":"struct ContractCondition { struct LibCoinVending.TransactionProperties have; struct LibCoinVending.TransactionProperties lock; struct LibCoinVending.TransactionProperties burn; struct LibCoinVending.TransactionProperties pay; struct LibCoinVending.TransactionProperties bet; }","title":"ContractCondition"},{"location":"interfaces/solidity-api/#numericcondition","text":"struct NumericCondition { uint256 have; uint256 lock; uint256 burn; uint256 pay; uint256 bet; }","title":"NumericCondition"},{"location":"interfaces/solidity-api/#transfertypes","text":"enum TransferTypes { FUND, REFUND, RELEASE }","title":"TransferTypes"},{"location":"interfaces/solidity-api/#conditionreturn","text":"struct ConditionReturn { struct LibCoinVending.NumericCondition ethValues; uint256 timesRefunded; uint256 timesReleased; uint256 timesFunded; address[] contractAddresses; uint256[] contractIds; enum LibCoinVending.ContractTypes[] contractTypes; bool _isConfigured; }","title":"ConditionReturn"},{"location":"interfaces/solidity-api/#configsmartrequirement","text":"struct configSmartRequirement { address contractAddress; uint256 contractId; enum LibCoinVending.ContractTypes contractType; struct LibCoinVending.ContractCondition contractRequirement; }","title":"configSmartRequirement"},{"location":"interfaces/solidity-api/#configposition","text":"struct ConfigPosition { struct LibCoinVending.NumericCondition ethValues; struct LibCoinVending.configSmartRequirement[] contracts; }","title":"ConfigPosition"},{"location":"interfaces/solidity-api/#libcoinvendingstorage","text":"struct LibCoinVendingStorage { mapping(bytes32 => struct LibCoinVending.Condition) positions; address beneficiary; }","title":"LibCoinVendingStorage"},{"location":"interfaces/solidity-api/#contracttypes","text":"enum ContractTypes { ERC20, ERC1155, ERC721 }","title":"ContractTypes"},{"location":"interfaces/solidity-api/#coin_vending_storage_position","text":"bytes32 COIN_VENDING_STORAGE_POSITION","title":"COIN_VENDING_STORAGE_POSITION"},{"location":"interfaces/solidity-api/#coinvendingposition","text":"function coinVendingPosition(bytes32 position) internal view returns (struct LibCoinVending.Condition)","title":"coinVendingPosition"},{"location":"interfaces/solidity-api/#coinvendingstorage","text":"function coinVendingStorage() internal pure returns (struct LibCoinVending.LibCoinVendingStorage es)","title":"coinVendingStorage"},{"location":"interfaces/solidity-api/#refund","text":"function refund(bytes32 position, address to) internal _Returns all position requirements back to fundee. position is the identifier of the condition. to is the address to refund the balance to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the to address. Increments the timesRefunded counter for the condition._","title":"refund"},{"location":"interfaces/solidity-api/#batchrefund","text":"function batchRefund(bytes32 position, address[] returnAddresses) internal _Returns all position requirements back to multiple fundees. position is the identifier of the condition. returnAddresses is an array of addresses to refund the balance to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to each address in returnAddresses . Increments the timesRefunded counter for the condition for each address in returnAddresses ._","title":"batchRefund"},{"location":"interfaces/solidity-api/#release","text":"function release(bytes32 position, address payee, address beneficiary, address returnAddress) internal _Releases the funds from a coin vending position to the specified addresses. position is the identifier of the condition. payee , beneficiary , and returnAddress are the addresses to release the funds to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the payee , beneficiary , and returnAddress . Increments the timesReleased counter for the condition._","title":"release"},{"location":"interfaces/solidity-api/#batchrelease","text":"function batchRelease(bytes32 position, address payee, address beneficiary, address[] returnAddresses) internal _Releases the funds from a coin vending position to multiple return addresses. position is the identifier of the condition. payee , beneficiary , and returnAddresses are the addresses to release the funds to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the payee , beneficiary , and each address in returnAddresses . Increments the timesReleased counter for the condition for each address in returnAddresses ._","title":"batchRelease"},{"location":"interfaces/solidity-api/#fund","text":"function fund(bytes32 position) internal _Funds the position by msg.sender . position is the identifier of the condition. Requirements: The condition must be configured. Modifies: Transfers the funds from msg.sender to this contract. Increments the timesFunded counter for the condition._","title":"fund"},{"location":"interfaces/solidity-api/#configure","text":"function configure(bytes32 position, struct LibCoinVending.ConfigPosition configuration) internal _Configures the position. position is the identifier of the condition. configuration is the new configuration for the condition. Requirements: The condition must not have a positive balance. Modifies: Sets the configuration of the condition to configuration ._","title":"configure"},{"location":"interfaces/solidity-api/#getposition","text":"function getPosition(bytes32 position) internal view returns (struct LibCoinVending.ConditionReturn) _Returns the condition associated with the given position. position is the identifier of the condition. Returns: The condition associated with position ._","title":"getPosition"},{"location":"interfaces/solidity-api/#getpositionbycontract","text":"function getPositionByContract(bytes32 position, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) internal view returns (struct LibCoinVending.ContractCondition) _Returns the contract condition associated with the given position, contract address, contract ID, and contract type. position is the identifier of the condition. contractAddress is the address of the contract. contractId is the ID of the contract. contractType is the type of the contract. Returns: The contract condition associated with position , contractAddress , contractId , and contractType ._","title":"getPositionByContract"},{"location":"interfaces/solidity-api/#libeip712withstorage","text":"","title":"LibEIP712WithStorage"},{"location":"interfaces/solidity-api/#eip712_storage_position","text":"bytes32 EIP712_STORAGE_POSITION","title":"EIP712_STORAGE_POSITION"},{"location":"interfaces/solidity-api/#libeip712withstoragestorage","text":"struct LibEIP712WithStorageStorage { bytes32 _CACHED_DOMAIN_SEPARATOR; uint256 _CACHED_CHAIN_ID; address _CACHED_THIS; bytes32 _HASHED_NAME; bytes32 _HASHED_VERSION; bytes32 _TYPE_HASH; }","title":"LibEIP712WithStorageStorage"},{"location":"interfaces/solidity-api/#eip712withstorage","text":"function EIP712WithStorage() internal pure returns (struct LibEIP712WithStorage.LibEIP712WithStorageStorage ds)","title":"EIP712WithStorage"},{"location":"interfaces/solidity-api/#libmultipass","text":"","title":"LibMultipass"},{"location":"interfaces/solidity-api/#namequery","text":"resolves user from any given argument Requirements: domainName must be given and must be initialized id OR username OR address must be given This method first tries to resolve by address, then by user id and finally by username","title":"NameQuery"},{"location":"interfaces/solidity-api/#parameters_15","text":"Name Type Description struct NameQuery { bytes32 domainName; address wallet; bytes32 name; bytes32 id; bytes32 targetDomain; }","title":"Parameters"},{"location":"interfaces/solidity-api/#domain","text":"The domain name of the registrar.","title":"Domain"},{"location":"interfaces/solidity-api/#parameters_16","text":"Name Type Description struct Domain { bytes32 name; uint256 fee; uint256 freeRegistrationsNumber; uint256 referrerReward; uint256 referralDiscount; bool isActive; address registrar; uint24 ttl; uint256 registerSize; }","title":"Parameters"},{"location":"interfaces/solidity-api/#record","text":"struct Record { address wallet; bytes32 name; bytes32 id; uint96 nonce; bytes32 domainName; }","title":"Record"},{"location":"interfaces/solidity-api/#multipass_storage_position","text":"bytes32 MULTIPASS_STORAGE_POSITION","title":"MULTIPASS_STORAGE_POSITION"},{"location":"interfaces/solidity-api/#domainnameservice","text":"The domain name of the registrar.","title":"DomainNameService"},{"location":"interfaces/solidity-api/#parameters_17","text":"Name Type Description struct DomainNameService { struct LibMultipass.Domain properties; mapping(bytes32 => address) idToAddress; mapping(bytes32 => uint96) nonce; mapping(address => bytes32) addressToId; mapping(bytes32 => bytes32) nameToId; mapping(bytes32 => bytes32) idToName; }","title":"Parameters"},{"location":"interfaces/solidity-api/#multipassstoragestruct","text":"struct MultipassStorageStruct { mapping(uint256 => struct LibMultipass.DomainNameService) domains; mapping(bytes32 => uint256) domainNameToIndex; uint256 numDomains; }","title":"MultipassStorageStruct"},{"location":"interfaces/solidity-api/#multipassstorage","text":"function MultipassStorage() internal pure returns (struct LibMultipass.MultipassStorageStruct es)","title":"MultipassStorage"},{"location":"interfaces/solidity-api/#_typehash","text":"bytes32 _TYPEHASH","title":"_TYPEHASH"},{"location":"interfaces/solidity-api/#_typehash_referral","text":"bytes32 _TYPEHASH_REFERRAL","title":"_TYPEHASH_REFERRAL"},{"location":"interfaces/solidity-api/#_checkstringfits32b","text":"function _checkStringFits32b(string value) internal pure returns (bool)","title":"_checkStringFits32b"},{"location":"interfaces/solidity-api/#_checknotempty","text":"function _checkNotEmpty(bytes32 value) internal pure returns (bool)","title":"_checkNotEmpty"},{"location":"interfaces/solidity-api/#resolvedomainindex","text":"function resolveDomainIndex(bytes32 domainName) internal view returns (uint256)","title":"resolveDomainIndex"},{"location":"interfaces/solidity-api/#_getdomainstorage","text":"function _getDomainStorage(bytes32 domainName) internal view returns (struct LibMultipass.DomainNameService)","title":"_getDomainStorage"},{"location":"interfaces/solidity-api/#_initializedomain","text":"function _initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) internal","title":"_initializeDomain"},{"location":"interfaces/solidity-api/#_getmodifyprice","text":"function _getModifyPrice(struct LibMultipass.Record userRecord) internal view returns (uint256)","title":"_getModifyPrice"},{"location":"interfaces/solidity-api/#resolverecord_2","text":"function resolveRecord(struct LibMultipass.NameQuery query) internal view returns (bool, struct LibMultipass.Record) resolves Record of name query in to status and identity","title":"resolveRecord"},{"location":"interfaces/solidity-api/#_setrecord","text":"function _setRecord(struct LibMultipass.DomainNameService domain, struct LibMultipass.Record record) internal this function bears no security checks, it will ignore nonce in arg and will increment nonce value stored in domain instread","title":"_setRecord"},{"location":"interfaces/solidity-api/#queryfromrecord","text":"function queryFromRecord(struct LibMultipass.Record _record, bytes32 _domainName) internal pure returns (struct LibMultipass.NameQuery)","title":"queryFromRecord"},{"location":"interfaces/solidity-api/#shouldregisterforfree","text":"function shouldRegisterForFree(struct LibMultipass.DomainNameService domain) internal view returns (bool)","title":"shouldRegisterForFree"},{"location":"interfaces/solidity-api/#_registernew","text":"function _registerNew(struct LibMultipass.Record newRecord, struct LibMultipass.DomainNameService domain) internal","title":"_registerNew"},{"location":"interfaces/solidity-api/#_getcontractstate","text":"function _getContractState() internal view returns (uint256)","title":"_getContractState"},{"location":"interfaces/solidity-api/#_getdomainstoragebyidx","text":"function _getDomainStorageByIdx(uint256 index) internal view returns (struct LibMultipass.DomainNameService)","title":"_getDomainStorageByIdx"},{"location":"interfaces/solidity-api/#quadraticvotingerror","text":"error quadraticVotingError(string paramter, uint256 arg, uint256 arg2)","title":"quadraticVotingError"},{"location":"interfaces/solidity-api/#libquadraticvoting","text":"A library for quadratic voting calculations.","title":"LibQuadraticVoting"},{"location":"interfaces/solidity-api/#qvotingstruct","text":"struct qVotingStruct { uint256 voteCredits; uint256 maxQuadraticPoints; uint256 minQuadraticPositons; }","title":"qVotingStruct"},{"location":"interfaces/solidity-api/#precomputevalues","text":"function precomputeValues(uint256 voteCredits, uint256 minExpectedVoteItems) internal pure returns (struct LibQuadraticVoting.qVotingStruct) _Precomputes the values for quadratic voting. voteCredits is the total number of vote credits. minExpectedVoteItems is the minimum expected number of vote items. Returns: A qVotingStruct containing the precomputed values._","title":"precomputeValues"},{"location":"interfaces/solidity-api/#computescoresbyvpindex","text":"function computeScoresByVPIndex(struct LibQuadraticVoting.qVotingStruct q, uint256[][] VotersVotes, bool[] voterVoted, uint256 notVotedGivesEveyone, uint256 proposalsLength) internal pure returns (uint256[]) _Computes the scores for each proposal by voter preference index. q is the precomputed quadratic voting values. VotersVotes is a 2D array of votes, where each row corresponds to a voter and each column corresponds to a proposal. voterVoted is an array indicating whether each voter has voted. notVotedGivesEveyone is the number of points to distribute to each proposal for each voter that did not vote. proposalsLength is the number of proposals. Returns: An array of scores for each proposal._","title":"computeScoresByVPIndex"},{"location":"interfaces/solidity-api/#librankify","text":"","title":"LibRankify"},{"location":"interfaces/solidity-api/#comparestrings","text":"function compareStrings(string a, string b) internal pure returns (bool) _Compares two strings for equality. a and b are the strings to compare. Returns: true if the strings are equal, false otherwise._","title":"compareStrings"},{"location":"interfaces/solidity-api/#getgamestorage","text":"function getGameStorage(uint256 gameId) internal view returns (struct IRankifyInstanceCommons.RInstance game) _Returns the game storage for the given game ID. gameId is the ID of the game. Returns: The game storage for gameId ._","title":"getGameStorage"},{"location":"interfaces/solidity-api/#rinstancestorage_2","text":"function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog) _Returns the Rankify InstanceSettings storage. Returns: The RInstanceSettings storage._","title":"RInstanceStorage"},{"location":"interfaces/solidity-api/#_proposal_proof_typehash","text":"bytes32 _PROPOSAL_PROOF_TYPEHASH","title":"_PROPOSAL_PROOF_TYPEHASH"},{"location":"interfaces/solidity-api/#_vote_proof_typehash","text":"bytes32 _VOTE_PROOF_TYPEHASH","title":"_VOTE_PROOF_TYPEHASH"},{"location":"interfaces/solidity-api/#_vote_submit_proof_typehash","text":"bytes32 _VOTE_SUBMIT_PROOF_TYPEHASH","title":"_VOTE_SUBMIT_PROOF_TYPEHASH"},{"location":"interfaces/solidity-api/#enforceisinitialized","text":"function enforceIsInitialized() internal view _Ensures that the contract is initialized. Requirements: The contract must be initialized._","title":"enforceIsInitialized"},{"location":"interfaces/solidity-api/#enforcegameexists","text":"function enforceGameExists(uint256 gameId) internal view _Ensures that the game with the given ID exists. gameId is the ID of the game. Requirements: The game with gameId must exist._","title":"enforceGameExists"},{"location":"interfaces/solidity-api/#newgame","text":"function newGame(uint256 gameId, address gameMaster, uint256 gameRank, address creator) internal _Creates a new game with the given parameters. gameId is the ID of the new game. gameMaster is the address of the game master. gameRank is the rank of the game. creator is the address of the creator of the game. Requirements: The game with gameId must not already exist. gameRank must not be 0. If the game price is not 0, the creator must have approved this contract to transfer the game price amount of the game payment token on their behalf. Modifies: Creates a new game with gameId . Transfers the game price amount of the game payment token from creator to this contract. Sets the payments balance of the game to the game price. Sets the creator of the game to creator . Increments the number of games. Sets the rank of the game to gameRank . Mints new rank tokens._","title":"newGame"},{"location":"interfaces/solidity-api/#enforceisgamecreator","text":"function enforceIsGameCreator(uint256 gameId, address candidate) internal view _Ensures that the candidate is the creator of the game with the given ID. gameId is the ID of the game. candidate is the address of the candidate. Requirements: The game with gameId must exist. candidate must be the creator of the game._","title":"enforceIsGameCreator"},{"location":"interfaces/solidity-api/#enforceisgm","text":"function enforceIsGM(uint256 gameId, address candidate) internal view _Ensures that the candidate is the game master of the game with the given ID. gameId is the ID of the game. candidate is the address of the candidate. Requirements: The game with gameId must exist. candidate must be the game master of the game._","title":"enforceIsGM"},{"location":"interfaces/solidity-api/#joingame_1","text":"function joinGame(uint256 gameId, address player) internal _Allows a player to join a game. gameId is the ID of the game. player is the address of the player. Requirements: The game with gameId must exist. If the join game price is not 0, the player must have approved this contract to transfer the join game price amount of the game payment token on their behalf. Modifies: Transfers the join game price amount of the game payment token from player to this contract. Increases the payments balance of the game by the join game price. Adds player to the game._","title":"joinGame"},{"location":"interfaces/solidity-api/#closegame","text":"function closeGame(uint256 gameId, address beneficiary, function (uint256,address) playersGameEndedCallback) internal returns (uint256[]) _Closes the game with the given ID and transfers the game's balance to the beneficiary. gameId is the ID of the game. beneficiary is the address to transfer the game's balance to. playersGameEndedCallback is a callback function to call for each player when the game ends. Requirements: The game with gameId must exist. Modifies: Emits rank rewards for the game. Removes and unlocks each player from the game. Calls playersGameEndedCallback for each player. Transfers the game's balance to beneficiary . Returns: The final scores of the game._","title":"closeGame"},{"location":"interfaces/solidity-api/#quitgame","text":"function quitGame(uint256 gameId, address player, bool slash, function (uint256,address) onPlayerLeftCallback) internal _Allows a player to quit a game. gameId is the ID of the game. player is the address of the player. slash is a boolean indicating whether to slash the player's payment refund. onPlayerLeftCallback is a callback function to call when the player leaves. Requirements: The game with gameId must exist. Modifies: If the join game price is not 0, transfers a refund to player and decreases the game's payments balance by the refund amount. Removes and unlocks player from the game. Calls onPlayerLeftCallback for player ._","title":"quitGame"},{"location":"interfaces/solidity-api/#cancelgame_1","text":"function cancelGame(uint256 gameId, function (uint256,address) onPlayerLeftCallback, address beneficiary) internal _Cancels the game with the given ID, refunds half of the game's payment to the game creator, and transfers the remaining balance to the beneficiary. gameId is the ID of the game. onPlayerLeftCallback is a callback function to call for each player when they leave. beneficiary is the address to transfer the remaining balance to. Requirements: The game with gameId must exist. Modifies: Calls quitGame for each player in the game. Transfers half of the game's payment to the game creator. Decreases the game's payments balance by the refund amount. Transfers the remaining balance of the game to beneficiary . Deletes the game._","title":"cancelGame"},{"location":"interfaces/solidity-api/#fulfillrankrq","text":"function fulfillRankRq(uint256 gameId, address player) internal _Fulfills the rank requirement for a player to join a game. gameId is the ID of the game. player is the address of the player. Modifies: Locks the rank token(s) of player in the rank token contract. If the game has additional ranks, locks the additional ranks of player in the respective rank token contracts._","title":"fulfillRankRq"},{"location":"interfaces/solidity-api/#emitrankrewards","text":"function emitRankRewards(uint256 gameId, address[] leaderboard) internal _Emits rank rewards to the top addresses in the leaderboard for each rank in the game. gameId is the ID of the game. leaderboard is an array of addresses representing the leaderboard. Modifies: Calls emitRankReward for the main rank and each additional rank in the game._","title":"emitRankRewards"},{"location":"interfaces/solidity-api/#removeandunlockplayer","text":"function removeAndUnlockPlayer(uint256 gameId, address player) internal _Removes a player from a game and unlocks their rank tokens. gameId is the ID of the game. player is the address of the player to be removed. Requirements: The game with gameId must exist. Modifies: Removes player from the game. If the game rank is greater than 1, unlocks the game rank token for player in the rank token contract and unlocks each additional rank token for player in the respective rank token contracts._","title":"removeAndUnlockPlayer"},{"location":"interfaces/solidity-api/#tryplayermove","text":"function tryPlayerMove(uint256 gameId, address player) internal returns (bool) _Tries to make a move for a player in a game. gameId is the ID of the game. player is the address of the player. The \"move\" is considered to be a state when player has made all actions he could in the given turn. Requirements: The game with gameId must exist. Modifies: If the player has not voted and a vote is expected, or if the player has not made a proposal and a proposal is expected, does not make a move and returns false . Otherwise, makes a move for player and returns true ._","title":"tryPlayerMove"},{"location":"interfaces/solidity-api/#calculatescoresquadratic","text":"function calculateScoresQuadratic(uint256 gameId, uint256[][] votesRevealed, uint256[] proposerIndicies) internal returns (uint256[], uint256[]) _Calculates the scores using a quadratic formula based on the revealed votes and proposer indices. gameId is the ID of the game. votesRevealed is an array of revealed votes. proposerIndicies is an array of proposer indices that links proposals to index in getPlayers(). Returns: An array of updated scores for each player. An array of scores calculated for the current round._","title":"calculateScoresQuadratic"},{"location":"interfaces/solidity-api/#libreentrancyguard","text":"","title":"LibReentrancyGuard"},{"location":"interfaces/solidity-api/#tbg_storage_position","text":"bytes32 TBG_STORAGE_POSITION","title":"TBG_STORAGE_POSITION"},{"location":"interfaces/solidity-api/#reentrancyguardstruct","text":"struct ReentrancyGuardStruct { bool _entered; }","title":"ReentrancyGuardStruct"},{"location":"interfaces/solidity-api/#reentrancyguardstorage","text":"function reentrancyGuardStorage() internal pure returns (struct LibReentrancyGuard.ReentrancyGuardStruct ds)","title":"reentrancyGuardStorage"},{"location":"interfaces/solidity-api/#libtbg","text":"_Library for managing turn-based games. It is designed to be used as a base library for games, and provides the following functionality: - setting game settings such as time per turn, max players, min players, etc as well as perform score and leaderboard tracking Limitations: - It is assumed there is only one game per player - It is assumed there is only on game master per game WARNING Some limitations: - This library is still under development and its interfaces may change. - getting game data (which has own storage assigement and can be encapsulated from library) however there is no storage slot collision checks in place_","title":"LibTBG"},{"location":"interfaces/solidity-api/#gamesettings","text":"struct GameSettings { uint256 timePerTurn; uint256 maxPlayersSize; uint256 minPlayersSize; uint256 timeToJoin; uint256 maxTurns; uint256 numWinners; uint256 voteCredits; string subject; }","title":"GameSettings"},{"location":"interfaces/solidity-api/#gameinstance","text":"struct GameInstance { address gameMaster; uint256 currentTurn; uint256 turnStartedAt; uint256 registrationOpenAt; bool hasStarted; bool hasEnded; struct EnumerableSet.AddressSet players; mapping(address => bool) madeMove; uint256 numPlayersMadeMove; mapping(address => uint256) score; bytes32 implemenationStoragePointer; bool isOvertime; address[] leaderboard; }","title":"GameInstance"},{"location":"interfaces/solidity-api/#tbgstoragestruct","text":"struct TBGStorageStruct { struct LibTBG.GameSettings settings; mapping(uint256 => struct LibTBG.GameInstance) games; mapping(address => uint256) playerInGame; uint256 totalGamesCreated; }","title":"TBGStorageStruct"},{"location":"interfaces/solidity-api/#tbg_storage_position_1","text":"bytes32 TBG_STORAGE_POSITION","title":"TBG_STORAGE_POSITION"},{"location":"interfaces/solidity-api/#implementation_storage_position","text":"bytes32 IMPLEMENTATION_STORAGE_POSITION","title":"IMPLEMENTATION_STORAGE_POSITION"},{"location":"interfaces/solidity-api/#tbgstorage","text":"function TBGStorage() internal pure returns (struct LibTBG.TBGStorageStruct es)","title":"TBGStorage"},{"location":"interfaces/solidity-api/#_getgame","text":"function _getGame(uint256 gameId) internal view returns (struct LibTBG.GameInstance)","title":"_getGame"},{"location":"interfaces/solidity-api/#init","text":"function init(struct LibTBG.GameSettings settings) internal _Initializes the game with the provided settings. settings is the settings for the game. Requirements: settings.timePerTurn must not be zero. settings.maxPlayersSize must not be zero. settings.minPlayersSize must be at least 2. settings.maxTurns must not be zero. settings.numWinners must not be zero and must be less than settings.minPlayersSize . settings.timeToJoin must not be zero. settings.maxPlayersSize must not be less than settings.minPlayersSize . settings.subject must not be an empty string. Modifies: Sets the settings of the game to settings ._","title":"init"},{"location":"interfaces/solidity-api/#creategame_3","text":"function createGame(uint256 gameId, address gm) internal _Creates a new game with the provided game ID and game master. gameId is the ID of the game. gm is the address of the game master. Requirements: The game with gameId must not already exist. gm must not be the zero address. gameId must not be zero. The game master of the game with gameId must be the zero address. Modifies: Sets the game master of the game with gameId to gm . Increments the total number of games created._","title":"createGame"},{"location":"interfaces/solidity-api/#deletegame","text":"function deleteGame(uint256 gameId) internal _Deletes a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. Modifies: Sets the game master, current turn, hasEnded, hasStarted, implementationStoragePointer, isOvertime, leaderboard, numPlayersMadeMove, players, registrationOpenAt, and turnStartedAt of the game with gameId to their initial values. Sets the score and madeMove of each player in the game with gameId to their initial values._","title":"deleteGame"},{"location":"interfaces/solidity-api/#canbejoined","text":"function canBeJoined(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID can be joined. gameId is the ID of the game. Returns: A boolean indicating whether the game can be joined._","title":"canBeJoined"},{"location":"interfaces/solidity-api/#addplayer","text":"function addPlayer(uint256 gameId, address participant) internal _Adds a player to a game with the provided game ID. gameId is the ID of the game. participant is the address of the player. Requirements: The game with gameId must exist. participant must not already be in a game. The number of players in the game with gameId must be less than the maximum number of players. The game with gameId must be joinable. Modifies: Adds participant to the players of the game with gameId . Sets the madeMove of participant in the game with gameId to false. Sets the game of participant to gameId ._","title":"addPlayer"},{"location":"interfaces/solidity-api/#isplayeringame","text":"function isPlayerInGame(uint256 gameId, address player) internal view returns (bool) _Checks if a player is in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Returns: A boolean indicating whether the player is in the game._","title":"isPlayerInGame"},{"location":"interfaces/solidity-api/#removeplayer","text":"function removePlayer(uint256 gameId, address participant) internal _Removes a player from a game with the provided game ID. gameId is the ID of the game. participant is the address of the player. Requirements: The game with gameId must exist. participant must be in the game with gameId . The game with gameId must not have started or must have ended. Modifies: Sets the game of participant to 0. Removes participant from the players of the game with gameId ._","title":"removePlayer"},{"location":"interfaces/solidity-api/#isturntimedout","text":"function isTurnTimedOut(uint256 gameId) internal view returns (bool) _Checks if the current turn in a game with the provided game ID has timed out. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started. Returns: A boolean indicating whether the current turn has timed out._","title":"isTurnTimedOut"},{"location":"interfaces/solidity-api/#gameexists","text":"function gameExists(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID exists. gameId is the ID of the game. Returns: A boolean indicating whether the game exists._","title":"gameExists"},{"location":"interfaces/solidity-api/#enforcehasstarted","text":"function enforceHasStarted(uint256 gameId) internal view _Enforces that a game with the provided game ID has started. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started._","title":"enforceHasStarted"},{"location":"interfaces/solidity-api/#canendturn_1","text":"function canEndTurn(uint256 gameId) internal view returns (bool) _Enforces that a game with the provided game ID has started. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started._","title":"canEndTurn"},{"location":"interfaces/solidity-api/#canendturnearly","text":"function canEndTurnEarly(uint256 gameId) internal view returns (bool) _Checks if the current turn in a game with the provided game ID can end early. gameId is the ID of the game. Returns: A boolean indicating whether the current turn can end early._","title":"canEndTurnEarly"},{"location":"interfaces/solidity-api/#onlyinturntime","text":"modifier onlyInTurnTime(uint256 gameId) _Modifier that requires the current turn in a game with the provided game ID to be able to end. gameId is the ID of the game. Requirements: The current turn in the game with gameId must be able to end._","title":"onlyInTurnTime"},{"location":"interfaces/solidity-api/#onlywhenturncanend","text":"modifier onlyWhenTurnCanEnd(uint256 gameId)","title":"onlyWhenTurnCanEnd"},{"location":"interfaces/solidity-api/#_clearcurrentmoves","text":"function _clearCurrentMoves(struct LibTBG.GameInstance game) internal _Clears the current moves in a game. game is the game. Modifies: Sets the madeMove of each player in game to false._","title":"_clearCurrentMoves"},{"location":"interfaces/solidity-api/#_resetplayerstates","text":"function _resetPlayerStates(struct LibTBG.GameInstance game) internal _Resets the states of the players in a game. game is the game. Modifies: Sets the madeMove and score of each player in game to their initial values._","title":"_resetPlayerStates"},{"location":"interfaces/solidity-api/#setscore","text":"function setScore(uint256 gameId, address player, uint256 value) internal _Sets the score of a player in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. value is the score. Requirements: player must be in the game with gameId . Modifies: Sets the score of player in the game with gameId to value ._","title":"setScore"},{"location":"interfaces/solidity-api/#getscore","text":"function getScore(uint256 gameId, address player) internal view returns (uint256) _Gets the score of a player in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Returns: The score of player in the game with gameId ._","title":"getScore"},{"location":"interfaces/solidity-api/#getscores_1","text":"function getScores(uint256 gameId) internal view returns (address[], uint256[]) _Gets the scores of the players in a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId . An array of the scores of the players in the game with gameId ._","title":"getScores"},{"location":"interfaces/solidity-api/#openregistration_1","text":"function openRegistration(uint256 gameId) internal _Opens registration for a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. Modifies: Sets the registrationOpenAt of the game with gameId to the current block timestamp._","title":"openRegistration"},{"location":"interfaces/solidity-api/#isregistrationopen_1","text":"function isRegistrationOpen(uint256 gameId) internal view returns (bool) _Checks if registration is open for a game with the provided game ID. gameId is the ID of the game. Returns: A boolean indicating whether registration is open for the game._","title":"isRegistrationOpen"},{"location":"interfaces/solidity-api/#canstart","text":"function canStart(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID can start. gameId is the ID of the game. Returns: A boolean indicating whether the game can start._","title":"canStart"},{"location":"interfaces/solidity-api/#canstartearly","text":"function canStartEarly(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID can start early. gameId is the ID of the game. By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached. Returns: A boolean indicating whether the game can start early._","title":"canStartEarly"},{"location":"interfaces/solidity-api/#startgameearly","text":"function startGameEarly(uint256 gameId) internal _Starts a game with the provided game ID early. gameId is the ID of the game. By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached. Requirements: The game with gameId must exist. The game with gameId must not have started. The game with gameId must have opened registration. The number of players in the game with gameId must be greater than or equal to the minimum number of players. The number of players in the game with gameId must be equal to the maximum number of players or the current block timestamp must be greater than the registration open time plus the time to join. Modifies: Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with gameId to their new values. Resets the states of the players in the game with gameId ._","title":"startGameEarly"},{"location":"interfaces/solidity-api/#startgame_1","text":"function startGame(uint256 gameId) internal _Starts a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. The game with gameId must not have started. The game with gameId must have opened registration. The current block timestamp must be greater than the registration open time plus the time to join. Modifies: Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with gameId to their new values. Resets the states of the players in the game with gameId ._","title":"startGame"},{"location":"interfaces/solidity-api/#getturn_1","text":"function getTurn(uint256 gameId) internal view returns (uint256) _Gets the current turn of a game with the provided game ID. gameId is the ID of the game. Returns: The current turn of the game with gameId ._","title":"getTurn"},{"location":"interfaces/solidity-api/#getgm_1","text":"function getGM(uint256 gameId) internal view returns (address) _Gets the game master of a game with the provided game ID. gameId is the ID of the game. Returns: The game master of the game with gameId ._","title":"getGM"},{"location":"interfaces/solidity-api/#islastturn_1","text":"function isLastTurn(uint256 gameId) internal view returns (bool) _Checks if the current turn is the last turn in a game with the provided game ID. gameId is the ID of the game. Returns: A boolean indicating whether the current turn is the last turn in the game._","title":"isLastTurn"},{"location":"interfaces/solidity-api/#isgameover_1","text":"function isGameOver(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID is over. gameId is the ID of the game. Returns: A boolean indicating whether the game is over._","title":"isGameOver"},{"location":"interfaces/solidity-api/#enforceisnotover","text":"function enforceIsNotOver(uint256 gameId) internal view _Enforces that a game with the provided game ID is not over. gameId is the ID of the game. Requirements: The game with gameId must not be over._","title":"enforceIsNotOver"},{"location":"interfaces/solidity-api/#playermove","text":"function playerMove(uint256 gameId, address player) internal _Records a player's move in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Requirements: The game with gameId must have started. The game with gameId must not be over. player must not have made a move in the current turn of the game with gameId . player must be in the game with gameId . Modifies: Sets the madeMove of player in the game with gameId to true. Increments the numPlayersMadeMove of the game with gameId ._","title":"playerMove"},{"location":"interfaces/solidity-api/#isplayerturncomplete_1","text":"function isPlayerTurnComplete(uint256 gameId, address player) internal view returns (bool)","title":"isPlayerTurnComplete"},{"location":"interfaces/solidity-api/#enforceisplayinggame","text":"function enforceIsPlayingGame(uint256 gameId, address player) internal view _Enforces that a player is in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Requirements: player must be in the game with gameId ._","title":"enforceIsPlayingGame"},{"location":"interfaces/solidity-api/#hasstarted","text":"function hasStarted(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID has started. gameId is the ID of the game. Returns: A boolean indicating whether the game has started._","title":"hasStarted"},{"location":"interfaces/solidity-api/#getleaderboard","text":"function getLeaderBoard(uint256 gameId) internal view returns (address[]) _Gets the leaderboard of a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId , sorted by score._","title":"getLeaderBoard"},{"location":"interfaces/solidity-api/#nextturn","text":"function nextTurn(uint256 gameId) internal returns (bool, bool, bool) _Advances to the next turn in a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must be able to end the current turn early. (all players have moved or the turn has timed out) Modifies: Clears the current moves in the game with gameId . Increments the currentTurn of the game with gameId . Sets the turnStartedAt of the game with gameId to the current block timestamp. If the current turn is the last turn or the game with gameId is in overtime, checks if the game is a tie and sets the isOvertime of the game with gameId to the result. Sets the hasEnded of the game with gameId to whether the game is over. Returns: A boolean indicating whether the current turn is the last turn. A boolean indicating whether the game is a tie. A boolean indicating whether the game is over._","title":"nextTurn"},{"location":"interfaces/solidity-api/#getdatastorage","text":"function getDataStorage() internal pure returns (bytes32 pointer) _Gets the data storage pointer. Returns: The data storage pointer._","title":"getDataStorage"},{"location":"interfaces/solidity-api/#getgamedatastorage","text":"function getGameDataStorage(uint256 gameId) internal view returns (bytes32 pointer) _Gets the game data storage pointer of a game with the provided game ID. gameId is the ID of the game. Returns: The game data storage pointer of the game with gameId ._","title":"getGameDataStorage"},{"location":"interfaces/solidity-api/#getplayersnumber","text":"function getPlayersNumber(uint256 gameId) internal view returns (uint256) _Gets the number of players in a game with the provided game ID. gameId is the ID of the game. Returns: The number of players in the game with gameId ._","title":"getPlayersNumber"},{"location":"interfaces/solidity-api/#getplayers_1","text":"function getPlayers(uint256 gameId) internal view returns (address[]) _Gets the players in a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId ._","title":"getPlayers"},{"location":"interfaces/solidity-api/#getgamesettings","text":"function getGameSettings() internal view returns (struct LibTBG.GameSettings) _Gets the game settings. Returns: The game settings._","title":"getGameSettings"},{"location":"interfaces/solidity-api/#enforceispreregistrationstage","text":"function enforceIsPreRegistrationStage(uint256 gameId) internal view _Enforces that a game with the provided game ID is in the pre-registration stage. gameId is the ID of the game. Requirements: Registration must not be open for the game with gameId . The game with gameId must not have started._","title":"enforceIsPreRegistrationStage"},{"location":"interfaces/solidity-api/#addovertime","text":"function addOvertime(uint256 gameId) internal _Adds overtime to a game with the provided game ID. gameId is the ID of the game. Modifies: Sets the isOvertime of the game with gameId to true._","title":"addOvertime"},{"location":"interfaces/solidity-api/#isovertime_1","text":"function isOvertime(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID is in overtime. gameId is the ID of the game. Returns: A boolean indicating whether the game is in overtime._","title":"isOvertime"},{"location":"interfaces/solidity-api/#resetovertime","text":"function resetOvertime(uint256 gameId) internal _Resets the overtime of a game with the provided game ID. gameId is the ID of the game. Modifies: Sets the isOvertime of the game with gameId to false._","title":"resetOvertime"},{"location":"interfaces/solidity-api/#istie","text":"function isTie(uint256 gameId) internal view returns (bool) _Checks if a game with the provided game ID is a tie. gameId is the ID of the game. Tie being defined as at least two of the top numWinners players having the same score. Returns: A boolean indicating whether the game is a tie._","title":"isTie"},{"location":"interfaces/solidity-api/#getplayersgame_1","text":"function getPlayersGame(address player) internal view returns (uint256) _Gets the game ID of the game a player is in. player is the address of the player. Returns: The game ID of the game player is in._","title":"getPlayersGame"},{"location":"interfaces/solidity-api/#sortbyscore","text":"function sortByScore(uint256 gameId) internal view returns (address[], uint256[]) _Sorts the players in a game with the provided game ID by score in descending order. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId , sorted by score. An array of the scores of the players in the game with gameId , sorted in descending order._","title":"sortByScore"},{"location":"interfaces/solidity-api/#ranktoken","text":"","title":"RankToken"},{"location":"interfaces/solidity-api/#rank","text":"mapping(address => uint256) rank","title":"rank"},{"location":"interfaces/solidity-api/#toprank","text":"uint256 topRank","title":"topRank"},{"location":"interfaces/solidity-api/#_levelupthreshold","text":"uint256 _levelUpThreshold","title":"_levelUpThreshold"},{"location":"interfaces/solidity-api/#onlyrankinginstance","text":"modifier onlyRankingInstance()","title":"onlyRankingInstance"},{"location":"interfaces/solidity-api/#constructor_2","text":"constructor(string uri_, address owner_, string cURI, uint256 levelUpThreshold, address[] components, uint256[] componentWeights) public","title":"constructor"},{"location":"interfaces/solidity-api/#getrankinginstance_1","text":"function getRankingInstance() public view returns (address) _Gets the ranking instance which can emit new rank updates and mint rank tokens. Returns: The address of the ranking instance._","title":"getRankingInstance"},{"location":"interfaces/solidity-api/#contracturi","text":"function contractURI() public view returns (string)","title":"contractURI"},{"location":"interfaces/solidity-api/#seturi","text":"function setURI(string uri_) public","title":"setURI"},{"location":"interfaces/solidity-api/#setcontracturi","text":"function setContractURI(string uri_) public","title":"setContractURI"},{"location":"interfaces/solidity-api/#leader","text":"event Leader(address account, uint256 rank)","title":"Leader"},{"location":"interfaces/solidity-api/#mint_1","text":"function mint(address to, uint256 amount, uint256 level, bytes data) public","title":"mint"},{"location":"interfaces/solidity-api/#updaterankinginstance_1","text":"function updateRankingInstance(address newRankingInstance) public _Updates the ranking instance. newRankingInstance is the address of the new ranking instance. emits a RankingInstanceUpdated event._","title":"updateRankingInstance"},{"location":"interfaces/solidity-api/#lock_2","text":"function lock(address account, uint256 id, uint256 amount) public","title":"lock"},{"location":"interfaces/solidity-api/#unlock_2","text":"function unlock(address account, uint256 id, uint256 amount) public","title":"unlock"},{"location":"interfaces/solidity-api/#batchmint_1","text":"function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) public Mints specified amounts of tokens to an account. to is the address of the account to mint the tokens to. ids is the array of IDs of the tokens to mint. amounts is the array of amounts of tokens to mint. data is the additional data.","title":"batchMint"},{"location":"interfaces/solidity-api/#levelup_2","text":"function levelUp(address to, uint256 level, bytes data) public","title":"levelUp"},{"location":"interfaces/solidity-api/#findnewrank_1","text":"function findNewRank(address account, uint256 oldRank) public view returns (uint256) _Finds the new rank of an account. account is the address of the account. oldRank is the old rank of the account. It checks the balance of the account and returns the new rank that can be upgraded to. Returns: The new rank of the account._","title":"findNewRank"},{"location":"interfaces/solidity-api/#rankupdated","text":"event RankUpdated(address account, uint256 rank)","title":"RankUpdated"},{"location":"interfaces/solidity-api/#_aftertokentransfer","text":"function _afterTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal _Hook that is called after any token transfer. This includes minting and burning, as well as batched variants. The same hook is called on both single and batched variants. For single transfers, the length of the id and amount arrays will be 1. Calling conditions (for each id and amount pair): When from and to are both non-zero, amount of from 's tokens of token type id will be transferred to to . When from is zero, amount tokens of token type id will be minted for to . when to is zero, amount of from 's tokens of token type id will be burned. from and to are never both zero. ids and amounts have the same, non-zero length. To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]._","title":"_afterTokenTransfer"},{"location":"interfaces/solidity-api/#getaccountrank_1","text":"function getAccountRank(address account) external view returns (uint256) _Gets the rank of an account. account is the address of the account. Returns: The rank of the account._","title":"getAccountRank"},{"location":"interfaces/solidity-api/#supportsinterface","text":"function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)","title":"supportsInterface"},{"location":"interfaces/solidity-api/#rankify","text":"","title":"Rankify"},{"location":"interfaces/solidity-api/#numtokens","text":"uint256 numTokens","title":"numTokens"},{"location":"interfaces/solidity-api/#constructor_3","text":"constructor(address owner) public","title":"constructor"},{"location":"interfaces/solidity-api/#mint_2","text":"function mint(address to, uint256 amount) public","title":"mint"},{"location":"specifications/IAppFactory/","text":"App factory # Requirements # Must allow anyone Interface # interface IFactoryAssetsManager { function deployAsset(bytes32 assetUri, bytes32 assetType, bytes calldata instantiationPayload) external; function deployAssetManager(address sAddr, bytes32 strategyId, bytes calldata instantiationPayload) external; function isAssetManager(address maybeManager) external view returns (bool); function isManagedAsset(address maybeAsset) external view returns (bool); function getAsset(address manager) external view returns (address); function getAssetType(address asset) external view returns (bytes32); function getAssetUri(address asset) external view returns (bytes32); event AssetDeployed(address indexed asset, bytes32 indexed assetUri, bytes32 indexed assetType); event AssetManagerDeployed(address indexed asset, address indexed manager, bytes32 indexed strategyId); } Rationale # Combining asset factory with manager instance factory - It could be possible to isolate functionality in two different contracts. Such design would imply that rank token factory may be called by either owner or game instance factory. Hence they are sharing same security level, and since factory deploys instances already tied to a particular rank token, they would become decoupled from token factory in case if token factory was swapped. Same can be achieved by deploying one factory as diamond contract and using Instance & Token deployments factory","title":"App factory"},{"location":"specifications/IAppFactory/#app-factory","text":"","title":"App factory"},{"location":"specifications/IAppFactory/#requirements","text":"Must allow anyone","title":"Requirements"},{"location":"specifications/IAppFactory/#interface","text":"interface IFactoryAssetsManager { function deployAsset(bytes32 assetUri, bytes32 assetType, bytes calldata instantiationPayload) external; function deployAssetManager(address sAddr, bytes32 strategyId, bytes calldata instantiationPayload) external; function isAssetManager(address maybeManager) external view returns (bool); function isManagedAsset(address maybeAsset) external view returns (bool); function getAsset(address manager) external view returns (address); function getAssetType(address asset) external view returns (bytes32); function getAssetUri(address asset) external view returns (bytes32); event AssetDeployed(address indexed asset, bytes32 indexed assetUri, bytes32 indexed assetType); event AssetManagerDeployed(address indexed asset, address indexed manager, bytes32 indexed strategyId); }","title":"Interface"},{"location":"specifications/IAppFactory/#rationale","text":"Combining asset factory with manager instance factory - It could be possible to isolate functionality in two different contracts. Such design would imply that rank token factory may be called by either owner or game instance factory. Hence they are sharing same security level, and since factory deploys instances already tied to a particular rank token, they would become decoupled from token factory in case if token factory was swapped. Same can be achieved by deploying one factory as diamond contract and using Instance & Token deployments factory","title":"Rationale"},{"location":"specifications/ManagedAssetFactory/","text":"Managed Asset Factory # Abstract # Producer is a smart contract that is able to deploy(produce) asset contracts and asset management contracts from one, versioned and trusted implementation factory-like source. It allows an asset emission to be controlled by multiple management contracts by being an asset emitter himself who only can does this on behalf of registered management contract. Such contract allows to have single registry of multiple assets each of whose is known to behave according to same logical constraints of trusted implementation of management instances that only differ with instantiation constructor argument differences. Motivation # Rating systems often are based on some quantitative representation for participants strengths and can be often expressed as an integer number selected so that minimum resolution can describe ratings granularly enough particular application. In practice forming tournaments, payment tiers etc however such granularity often is being reduced by quantizing participant ratings to some less granular groupings. For example in chess, FIDE used Elo rating system will use scale that defined in boundaries of [1000,2700]. FIDE will also quantize these values in to categories each being 25 points wide to form tournament game groups. It will also specify that awarded titles, such as \"Grand-Master\" requires rating over a threshold. With bloom of meta-verse philosophy it seem to be valuable to be able to define such rating system agnostic from any particular implementation and organization, rather as modular and generic aggregator for different ratings, hence enabling cross-stream collaboration and convenient way of sharing, querying ratings as well as the quantization values that represent distinct, principal quality difference. In order to build such an asset system, where each would be capable representing a category for some matter in united and global registry existing token ERC1155 standard can be utilized. To link those together some kind of trusted registry is needed that can manage such coupled assets and create cross-domain trust. Specification # Assets and asset management logic are separated and are pre-defined as factory templates, that allow instantiating party only pass in arbitrary constructor arguments as customization properties. Whenever a management contract needs to call privileged method on the asset, it calls Factory Asset Manager which forwards call. Definitions # Asset : An ERC1155 contract that represents a matter Asset manager : An arbitrary contract that can manage one particular asset Registry : Storage located within the Producer contract which stores records about assets and corresponding managers Instance : A factory deployment, it may be either asset or asset manager Template : A reference code that is used to produce instances Requirements # Must deploy asset Manager with exactly one asset assigned. Must allow multiple Managers to manage same asset. Must be able to deploy new assets by instantiating from a template. Must be able to deploy new AssetManager by instantiating from a template. Must record deployed instance address and template identifier and it's relationship to other instances in the registry. Must emit an event when asset is created. Must emit an event when manager is created. May have multiple asset types available to instantiate. May have multiple management types available to instantiate Should be EIP165 compliant. Mus be able to distinguish whether address is an asset Must be able to distinguish whether address is a manager Must be able to distinguish whether manager manages an asset Must be able to distinguish whether asset is is managed by a manager Must store in the registry and return Asset URI Must store in the registry and return Asset Type Must store in the registry and return Manager Template Id Must store in the registry and return Managers asset address Interface # interface IFactoryAssetsManager { function deployAsset(bytes32 assetUri, bytes32 assetType, bytes calldata instantiationPayload) external; function deployAssetManager(address sAddr, bytes32 strategyId, bytes calldata instantiationPayload) external; function isAssetManager(address maybeManager) external view returns (bool); function isManagedAsset(address maybeAsset) external view returns (bool); function getAsset(address manager) external view returns (address); function getAssetType(address asset) external view returns (bytes32); function getAssetUri(address asset) external view returns (bytes32); event AssetDeployed(address indexed asset, bytes32 indexed assetUri, bytes32 indexed assetType); event AssetManagerDeployed(address indexed asset, address indexed manager, bytes32 indexed strategyId); } Rationale # Combining asset factory with manager instance factory - It could be possible to isolate functionality in two different contracts. Such design would imply that rank token factory may be called by either owner or game instance factory. Hence they are sharing same security level, and since factory deploys instances already tied to a particular rank token, they would become decoupled from token factory in case if token factory was swapped. Same can be achieved by deploying one factory as diamond contract and using Instance & Token deployments factory","title":"Managed Asset Factory"},{"location":"specifications/ManagedAssetFactory/#managed-asset-factory","text":"","title":"Managed Asset Factory"},{"location":"specifications/ManagedAssetFactory/#abstract","text":"Producer is a smart contract that is able to deploy(produce) asset contracts and asset management contracts from one, versioned and trusted implementation factory-like source. It allows an asset emission to be controlled by multiple management contracts by being an asset emitter himself who only can does this on behalf of registered management contract. Such contract allows to have single registry of multiple assets each of whose is known to behave according to same logical constraints of trusted implementation of management instances that only differ with instantiation constructor argument differences.","title":"Abstract"},{"location":"specifications/ManagedAssetFactory/#motivation","text":"Rating systems often are based on some quantitative representation for participants strengths and can be often expressed as an integer number selected so that minimum resolution can describe ratings granularly enough particular application. In practice forming tournaments, payment tiers etc however such granularity often is being reduced by quantizing participant ratings to some less granular groupings. For example in chess, FIDE used Elo rating system will use scale that defined in boundaries of [1000,2700]. FIDE will also quantize these values in to categories each being 25 points wide to form tournament game groups. It will also specify that awarded titles, such as \"Grand-Master\" requires rating over a threshold. With bloom of meta-verse philosophy it seem to be valuable to be able to define such rating system agnostic from any particular implementation and organization, rather as modular and generic aggregator for different ratings, hence enabling cross-stream collaboration and convenient way of sharing, querying ratings as well as the quantization values that represent distinct, principal quality difference. In order to build such an asset system, where each would be capable representing a category for some matter in united and global registry existing token ERC1155 standard can be utilized. To link those together some kind of trusted registry is needed that can manage such coupled assets and create cross-domain trust.","title":"Motivation"},{"location":"specifications/ManagedAssetFactory/#specification","text":"Assets and asset management logic are separated and are pre-defined as factory templates, that allow instantiating party only pass in arbitrary constructor arguments as customization properties. Whenever a management contract needs to call privileged method on the asset, it calls Factory Asset Manager which forwards call.","title":"Specification"},{"location":"specifications/ManagedAssetFactory/#definitions","text":"Asset : An ERC1155 contract that represents a matter Asset manager : An arbitrary contract that can manage one particular asset Registry : Storage located within the Producer contract which stores records about assets and corresponding managers Instance : A factory deployment, it may be either asset or asset manager Template : A reference code that is used to produce instances","title":"Definitions"},{"location":"specifications/ManagedAssetFactory/#requirements","text":"Must deploy asset Manager with exactly one asset assigned. Must allow multiple Managers to manage same asset. Must be able to deploy new assets by instantiating from a template. Must be able to deploy new AssetManager by instantiating from a template. Must record deployed instance address and template identifier and it's relationship to other instances in the registry. Must emit an event when asset is created. Must emit an event when manager is created. May have multiple asset types available to instantiate. May have multiple management types available to instantiate Should be EIP165 compliant. Mus be able to distinguish whether address is an asset Must be able to distinguish whether address is a manager Must be able to distinguish whether manager manages an asset Must be able to distinguish whether asset is is managed by a manager Must store in the registry and return Asset URI Must store in the registry and return Asset Type Must store in the registry and return Manager Template Id Must store in the registry and return Managers asset address","title":"Requirements"},{"location":"specifications/ManagedAssetFactory/#interface","text":"interface IFactoryAssetsManager { function deployAsset(bytes32 assetUri, bytes32 assetType, bytes calldata instantiationPayload) external; function deployAssetManager(address sAddr, bytes32 strategyId, bytes calldata instantiationPayload) external; function isAssetManager(address maybeManager) external view returns (bool); function isManagedAsset(address maybeAsset) external view returns (bool); function getAsset(address manager) external view returns (address); function getAssetType(address asset) external view returns (bytes32); function getAssetUri(address asset) external view returns (bytes32); event AssetDeployed(address indexed asset, bytes32 indexed assetUri, bytes32 indexed assetType); event AssetManagerDeployed(address indexed asset, address indexed manager, bytes32 indexed strategyId); }","title":"Interface"},{"location":"specifications/ManagedAssetFactory/#rationale","text":"Combining asset factory with manager instance factory - It could be possible to isolate functionality in two different contracts. Such design would imply that rank token factory may be called by either owner or game instance factory. Hence they are sharing same security level, and since factory deploys instances already tied to a particular rank token, they would become decoupled from token factory in case if token factory was swapped. Same can be achieved by deploying one factory as diamond contract and using Instance & Token deployments factory","title":"Rationale"}]}