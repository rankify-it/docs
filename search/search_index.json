{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started # Project Overview # Rankify is a pioneering platform designed to transform organizational management through decentralized decision-making structures and AI-enhanced collaboration. By implementing the innovative Autonomous Competence Identification (ACID) protocol protocol, Rankify empowers organizations to streamline decision processes, improve accuracy, and achieve outcomes that rival those of expert systems. The success of this innovative approach hinges on the effective implementation of the ACID protocol, a milestone that promises to revolutionize the way organizations operate. Goals # Project goal is to create a fully autonomous on-chain system that is efficient and secure in it's decision making process. Ultimate goal is to create a organization management protocol that is neural-network like, fully decentralized and is represented by as diverse as possible, top level experts in their respective fields. Scope # The project is divided into several phases, each of which is designed to address a specific aspect of the ACID protocol. The first phase focuses on the development of the core infrastructure, including the creation of the Rankify DAO, the implementation of the ACID protocol, and the establishment of the Rankify ecosystem. Subsequent phases will focus on the development of additional features, such as the integration of AI-enhanced decision-making tools, the creation of a decentralized marketplace, and the implementation of MPC (Multi-Party Computation) based privacy solutions. Project ecosystem is EVM supported chains in the initial stages, with plans to expand to other chains in the future as well as support private chains that will be able to roll-up to public chains.","title":"Getting started"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#project-overview","text":"Rankify is a pioneering platform designed to transform organizational management through decentralized decision-making structures and AI-enhanced collaboration. By implementing the innovative Autonomous Competence Identification (ACID) protocol protocol, Rankify empowers organizations to streamline decision processes, improve accuracy, and achieve outcomes that rival those of expert systems. The success of this innovative approach hinges on the effective implementation of the ACID protocol, a milestone that promises to revolutionize the way organizations operate.","title":"Project Overview"},{"location":"#goals","text":"Project goal is to create a fully autonomous on-chain system that is efficient and secure in it's decision making process. Ultimate goal is to create a organization management protocol that is neural-network like, fully decentralized and is represented by as diverse as possible, top level experts in their respective fields.","title":"Goals"},{"location":"#scope","text":"The project is divided into several phases, each of which is designed to address a specific aspect of the ACID protocol. The first phase focuses on the development of the core infrastructure, including the creation of the Rankify DAO, the implementation of the ACID protocol, and the establishment of the Rankify ecosystem. Subsequent phases will focus on the development of additional features, such as the integration of AI-enhanced decision-making tools, the creation of a decentralized marketplace, and the implementation of MPC (Multi-Party Computation) based privacy solutions. Project ecosystem is EVM supported chains in the initial stages, with plans to expand to other chains in the future as well as support private chains that will be able to roll-up to public chains.","title":"Scope"},{"location":"governance/","text":"Governance # Rankify governance is Rankify itself. We are pioneering the way by starting from a multi party controlled wallet, that was seeded by Gitcoin grants and it will gradually evolve into interlinked autonomous organizations infrastructure network. Progressive decentralization # Definition of progressive decentralization is given as ability for the system to evolve from centralized to decentralized state. Rankify as protocol allows establishing Peer-to-Peer communications on Entity level without sacrificing for security. This is achieved by using Multisignature wallet that represents decentralized organization branches. Sub DAOs (Cells) # Sub DAOs, or also referred as Cells are autonomous bodies that can act on their own. Sub DAOs are specifically fetched to service some narrowed specialty need of the organization and represent faster, more specialized units that can take decisions more promptly, have required permissions available from parent DAO as well as they have ability to recursively repeat decentralization process, breaking it down to atomic pieces. Linkage between parent organization and Cells is done by having a \"tournament\", each of whose is a Rankify Application Sub DAO Tokenomics # Under a protocol, as DAO-cell creates new and new cells, it actually does not delegate any of control over itself other rather than that it is connected to it's sub-ordinate DAOs only via multi-sig wallet, which only may be controlling some of the sub-dao governance token issuance parameters as well as pre-definitions. Such sub-ordinates have no value on it own, they do not change any of the parent DAO governance parameters and they are not able to issue any of the governance tokens on their own either completely, or until some internal growth stage. There are no initial coin offerings available to such generated DAOs, instead ACID games are applied to generate such fully autonomously. Note In short, outcome of using the ACID protocol is that participants willing to become DAO members must enter a tournament, which will take their bets and mint award tokens to the winners. A sybil attack resistance as per ACID is expressed in contributions members must do in order to participate. Thus, a sybil attack analysis formula can be used to estimate equilibrium point between exchanging parent token directly versus exchanging it via sybil attack on children asset minting schema. Relation of these values can be estimated by sybil resistance of protocol, and in worst case is exponential: f(n) = C * N^n . Where f(n) is the value of the token, C is the constant, N is the quorum factor and n is the number of sub-dao governance votes obtained. Decentralization Roadmap # Approximate timeline is as follows: timeline section 2024 Q2 : Multisig Arbitrum Seeded Q3 : Arbitrum branch Governance token issuance : Rankify DAO (Arbitrum branch) Q4 : Base Multisig Seeded : Ranking Application (Arbitrum branch) section 2025 Q1 : Alpha participation Airdrop Q2+ : TBD More detail will be added as we flow through the process. Rankify Arbitrum Multisig # First Rankify DAO Multisig is deployed on the Arbitrum network, it's address is ToDo: Add Address Alpha DAO Arbitrum # Alpha DAO Arbitrum is a first decentralization step. Right now governance process undergoes in the community to define the details of the upcoming setup.","title":"Governance"},{"location":"governance/#governance","text":"Rankify governance is Rankify itself. We are pioneering the way by starting from a multi party controlled wallet, that was seeded by Gitcoin grants and it will gradually evolve into interlinked autonomous organizations infrastructure network.","title":"Governance"},{"location":"governance/#progressive-decentralization","text":"Definition of progressive decentralization is given as ability for the system to evolve from centralized to decentralized state. Rankify as protocol allows establishing Peer-to-Peer communications on Entity level without sacrificing for security. This is achieved by using Multisignature wallet that represents decentralized organization branches.","title":"Progressive decentralization"},{"location":"governance/#sub-daos-cells","text":"Sub DAOs, or also referred as Cells are autonomous bodies that can act on their own. Sub DAOs are specifically fetched to service some narrowed specialty need of the organization and represent faster, more specialized units that can take decisions more promptly, have required permissions available from parent DAO as well as they have ability to recursively repeat decentralization process, breaking it down to atomic pieces. Linkage between parent organization and Cells is done by having a \"tournament\", each of whose is a Rankify Application","title":"Sub DAOs (Cells)"},{"location":"governance/#sub-dao-tokenomics","text":"Under a protocol, as DAO-cell creates new and new cells, it actually does not delegate any of control over itself other rather than that it is connected to it's sub-ordinate DAOs only via multi-sig wallet, which only may be controlling some of the sub-dao governance token issuance parameters as well as pre-definitions. Such sub-ordinates have no value on it own, they do not change any of the parent DAO governance parameters and they are not able to issue any of the governance tokens on their own either completely, or until some internal growth stage. There are no initial coin offerings available to such generated DAOs, instead ACID games are applied to generate such fully autonomously. Note In short, outcome of using the ACID protocol is that participants willing to become DAO members must enter a tournament, which will take their bets and mint award tokens to the winners. A sybil attack resistance as per ACID is expressed in contributions members must do in order to participate. Thus, a sybil attack analysis formula can be used to estimate equilibrium point between exchanging parent token directly versus exchanging it via sybil attack on children asset minting schema. Relation of these values can be estimated by sybil resistance of protocol, and in worst case is exponential: f(n) = C * N^n . Where f(n) is the value of the token, C is the constant, N is the quorum factor and n is the number of sub-dao governance votes obtained.","title":"Sub DAO Tokenomics"},{"location":"governance/#decentralization-roadmap","text":"Approximate timeline is as follows: timeline section 2024 Q2 : Multisig Arbitrum Seeded Q3 : Arbitrum branch Governance token issuance : Rankify DAO (Arbitrum branch) Q4 : Base Multisig Seeded : Ranking Application (Arbitrum branch) section 2025 Q1 : Alpha participation Airdrop Q2+ : TBD More detail will be added as we flow through the process.","title":"Decentralization Roadmap"},{"location":"governance/#rankify-arbitrum-multisig","text":"First Rankify DAO Multisig is deployed on the Arbitrum network, it's address is ToDo: Add Address","title":"Rankify Arbitrum Multisig"},{"location":"governance/#alpha-dao-arbitrum","text":"Alpha DAO Arbitrum is a first decentralization step. Right now governance process undergoes in the community to define the details of the upcoming setup.","title":"Alpha DAO Arbitrum"},{"location":"tokens/","text":"Token types # Rank Token # Rank NFT is a semi fungible token that represents a competence. It is implemented as ERC1155 standard. It acts as a proof of competence that may be used in various scenarios as NFT itself, where token id represents bearers rank . These tokens are also may be exchanged for governance tokens under a deployment defined, immutable rules. Governance tokens # Governance token is a token that represents a voting power in the DAO. It is implemented as ERC20 standard. It is used to vote on proposals and to participate in the governance of the DAO. RKFY # RKFY is a governance token of the Rankify DAO. Its unique aspect is that it is bootstrapped solely by participating in the ranking games. There will be no ICO nor any other form of direct issuance of RKFY tokens except for the genesis ranking games. The games however are specifically tailored and will represent a real hands-on challenges organization will face, such as code development, community building and so on. Note You can think of such distribution system as a \"proof of useful work\" airdrop for the DAO. \"RANKIFY CORE\" NFT # \"RANKIFY CORE\" NFT is a special NFT that is minted to the DAO members that have participated in the genesis ranking games. It is is exchanged on fixed ratio tied to token Id. It is used to represent the DAO membership and to provide additional benefits to the members.","title":"Token types"},{"location":"tokens/#token-types","text":"","title":"Token types"},{"location":"tokens/#rank-token","text":"Rank NFT is a semi fungible token that represents a competence. It is implemented as ERC1155 standard. It acts as a proof of competence that may be used in various scenarios as NFT itself, where token id represents bearers rank . These tokens are also may be exchanged for governance tokens under a deployment defined, immutable rules.","title":"Rank Token"},{"location":"tokens/#governance-tokens","text":"Governance token is a token that represents a voting power in the DAO. It is implemented as ERC20 standard. It is used to vote on proposals and to participate in the governance of the DAO.","title":"Governance tokens"},{"location":"tokens/#rkfy","text":"RKFY is a governance token of the Rankify DAO. Its unique aspect is that it is bootstrapped solely by participating in the ranking games. There will be no ICO nor any other form of direct issuance of RKFY tokens except for the genesis ranking games. The games however are specifically tailored and will represent a real hands-on challenges organization will face, such as code development, community building and so on. Note You can think of such distribution system as a \"proof of useful work\" airdrop for the DAO.","title":"RKFY"},{"location":"tokens/#rankify-core-nft","text":"\"RANKIFY CORE\" NFT is a special NFT that is minted to the DAO members that have participated in the genesis ranking games. It is is exchanged on fixed ratio tied to token Id. It is used to represent the DAO membership and to provide additional benefits to the members.","title":"\"RANKIFY CORE\" NFT"},{"location":"architecture/","text":"Smart contract infrastructure # The Rankify smart contract infrastructure is built upon a modular design, emphasizing trustless operations to facilitate progressive decentralization within organizations and to mitigate some of the roadblocks on wider adoption of decentralized governance. Adhering to systems theory principles, the architecture can be understood as a black box, responding to stimuli inputs with defined output reactions, while its key feature is the support for recursive patterns, enabling iterative processes on both input and output levels. Including governing body, infrastructure as consisting of two main pieces: App Store : Registry of different ranking system applications that may be installed on cells Cell infrastructures : Dimensions for ranking that participants produce. Note The rankify community governing DAO and multi-sig in the image above can be seen as an instance of Cell infrastructure. Cells # A single cell is an autonomous governance unit, structured as an NxM matrix of inputs and outputs connected to a multisig-wallet. Each cell, representing a specific topic or workgroup, leverages a modular and customizable infrastructure consisting of: Rank NFT : A semi-fungible ERC1155 token signifying the bearer's rank within the subject. Governance Token : An ERC20 token used for governance, minted by exchanging Rank NFTs. DAO contract : OSx DAO Contract governed entirely by holders of the governance token. App Instance : Ranking app, implements the autonomous competence identification protocol. Multisig Wallet : A wallet adhering to the Gnosis ISafe , connecting governing bodies and facilitating decision-making. Protocol is modular and trends to support already existing multi-sig infrastructure as well as experimentation hence protocol deployed, established, and modified cells, that are referred as Primordial , Generated , and Mutated accordingly. Above diagram describes infrastructure Generated cells adhere, while diagram involving governing body (green blocks) on top of this page describes primordial cell, which yet has no Rank NFT asset to complete it, as well as it is not listed in any auto-generation registries. Distribution system # The core concept of scaling Rankify is to give ability for organizations to easily spawn whole pieces of new infrastructure, such as new cells, or new applications that form organizations unique offerings to others in the network. Thus we develop a distribution system with goal to provide as generic and permission less approach as possible with yet a security guarantees between different organizations, that are translated trough curating own application infrastructure. Application infrastructure consist of: Repository : Provides single address contracts to have versioned source control. Installer : Target specific interface that consumes distributions. App developer either deploys plain source or sets up a repository for his work and deploys his source to that to provide version control interface. Then he can propose any organization to add his repository to their Installer Plugin to have his application available for installation. If it succeeds, organization members now can create their own instances of applications that all will share same source code and version. 7e8c3e06-40e1-4d77-b49e-37f60c0e74bf Anyone can create their own repository, and become distributor, however Rankify DAO curates its own distribution contract, listing its own resources and community-approved third-party applications. IVRepoFactory is provided for convenience of creating new repositories. Repositories # The App Repositories are built upon the IRepository interface, which mirrors the functionality of the OSx IPluginRepo . It provides a versioned repository for source non-permissive control implementations. Users of that repository can be sure that every time they request specific application version, same address will be returned and keep track of newest releases. Note The developer source code does not need to be aware of the repository structure, already existing contracts may be added to the repository. Installer # Installer is an abstract integration contract that takes distributions and installs them into target organization. It must implement IInstaller interface, and it's only interface dependency is Repository contract. It is an abstract that must be extended to meet specific target interface requirements. Note Application might have time-zone specific properties, making it necessary to have multiple instances of the same application, each with its own unique configuration. Warning Installer main use case assumes ability to instantiate multiple instances, it does not track permissions to install applications nor it enforces their count. Such limits can be introduced in the instantiation logic InstallationPlan requirements that are approved by DAO. OSx Installer # A concrete installer version, \"OSx Installer\" plugin is provided to support integration with Aragon OSx framework. This Installer must be authorized by the DAO, maintains a list of approved distributors as well it is the only system component that must be aware of installation target specific interfaces. It simplifies the process for users to launch whitelisted applications, acting as a proxy between instances and the DAO contract as well as generalizes apps development.","title":"Smart contract infrastructure"},{"location":"architecture/#smart-contract-infrastructure","text":"The Rankify smart contract infrastructure is built upon a modular design, emphasizing trustless operations to facilitate progressive decentralization within organizations and to mitigate some of the roadblocks on wider adoption of decentralized governance. Adhering to systems theory principles, the architecture can be understood as a black box, responding to stimuli inputs with defined output reactions, while its key feature is the support for recursive patterns, enabling iterative processes on both input and output levels. Including governing body, infrastructure as consisting of two main pieces: App Store : Registry of different ranking system applications that may be installed on cells Cell infrastructures : Dimensions for ranking that participants produce. Note The rankify community governing DAO and multi-sig in the image above can be seen as an instance of Cell infrastructure.","title":"Smart contract infrastructure"},{"location":"architecture/#cells","text":"A single cell is an autonomous governance unit, structured as an NxM matrix of inputs and outputs connected to a multisig-wallet. Each cell, representing a specific topic or workgroup, leverages a modular and customizable infrastructure consisting of: Rank NFT : A semi-fungible ERC1155 token signifying the bearer's rank within the subject. Governance Token : An ERC20 token used for governance, minted by exchanging Rank NFTs. DAO contract : OSx DAO Contract governed entirely by holders of the governance token. App Instance : Ranking app, implements the autonomous competence identification protocol. Multisig Wallet : A wallet adhering to the Gnosis ISafe , connecting governing bodies and facilitating decision-making. Protocol is modular and trends to support already existing multi-sig infrastructure as well as experimentation hence protocol deployed, established, and modified cells, that are referred as Primordial , Generated , and Mutated accordingly. Above diagram describes infrastructure Generated cells adhere, while diagram involving governing body (green blocks) on top of this page describes primordial cell, which yet has no Rank NFT asset to complete it, as well as it is not listed in any auto-generation registries.","title":"Cells"},{"location":"architecture/#distribution-system","text":"The core concept of scaling Rankify is to give ability for organizations to easily spawn whole pieces of new infrastructure, such as new cells, or new applications that form organizations unique offerings to others in the network. Thus we develop a distribution system with goal to provide as generic and permission less approach as possible with yet a security guarantees between different organizations, that are translated trough curating own application infrastructure. Application infrastructure consist of: Repository : Provides single address contracts to have versioned source control. Installer : Target specific interface that consumes distributions. App developer either deploys plain source or sets up a repository for his work and deploys his source to that to provide version control interface. Then he can propose any organization to add his repository to their Installer Plugin to have his application available for installation. If it succeeds, organization members now can create their own instances of applications that all will share same source code and version. 7e8c3e06-40e1-4d77-b49e-37f60c0e74bf Anyone can create their own repository, and become distributor, however Rankify DAO curates its own distribution contract, listing its own resources and community-approved third-party applications. IVRepoFactory is provided for convenience of creating new repositories.","title":"Distribution system"},{"location":"architecture/#repositories","text":"The App Repositories are built upon the IRepository interface, which mirrors the functionality of the OSx IPluginRepo . It provides a versioned repository for source non-permissive control implementations. Users of that repository can be sure that every time they request specific application version, same address will be returned and keep track of newest releases. Note The developer source code does not need to be aware of the repository structure, already existing contracts may be added to the repository.","title":"Repositories"},{"location":"architecture/#installer","text":"Installer is an abstract integration contract that takes distributions and installs them into target organization. It must implement IInstaller interface, and it's only interface dependency is Repository contract. It is an abstract that must be extended to meet specific target interface requirements. Note Application might have time-zone specific properties, making it necessary to have multiple instances of the same application, each with its own unique configuration. Warning Installer main use case assumes ability to instantiate multiple instances, it does not track permissions to install applications nor it enforces their count. Such limits can be introduced in the instantiation logic InstallationPlan requirements that are approved by DAO.","title":"Installer"},{"location":"architecture/#osx-installer","text":"A concrete installer version, \"OSx Installer\" plugin is provided to support integration with Aragon OSx framework. This Installer must be authorized by the DAO, maintains a list of approved distributors as well it is the only system component that must be aware of installation target specific interfaces. It simplifies the process for users to launch whitelisted applications, acting as a proxy between instances and the DAO contract as well as generalizes apps development.","title":"OSx Installer"},{"location":"architecture/applications/","text":"Applications # Overview # While application distribution system can, and is encouraged, to be used for pretty much anything, Rankify main goal is to provide necessary infrastructure for Autonomous Competence identification (ACID) protocol installation. In our implementation the asset is being decoupled from governing body to allow for more flexible and dynamic governance and to encourage experimentation without sacrificing for governance security. The representation of comptence is done via Rank NFTs . Hence it is required that applications are able to mint and burn Rank NFTs assets, they can do this by using installation proxy as their mint and burn target. When called, the proxy will mint or burn the asset on behalf of the application. This approach allows applications to be versioned, prevents outdated instances from being used. Tip You are welcome to write your own application, if it meets community standards, it can be included in the Rankify ecosystem, or used to create your own DAO ecosystem autonomously! Best list challenge # The best list challenge is a simple example of an application that can be built on top of the Rankify infrastructure. It allows users to submit their ideas and vote on them to create a ranked list of ideas. Protocol is designed in accordance to autonomous competence identification protocol: participation is anonymous, time continuous and results are verifiable.","title":"Applications"},{"location":"architecture/applications/#applications","text":"","title":"Applications"},{"location":"architecture/applications/#overview","text":"While application distribution system can, and is encouraged, to be used for pretty much anything, Rankify main goal is to provide necessary infrastructure for Autonomous Competence identification (ACID) protocol installation. In our implementation the asset is being decoupled from governing body to allow for more flexible and dynamic governance and to encourage experimentation without sacrificing for governance security. The representation of comptence is done via Rank NFTs . Hence it is required that applications are able to mint and burn Rank NFTs assets, they can do this by using installation proxy as their mint and burn target. When called, the proxy will mint or burn the asset on behalf of the application. This approach allows applications to be versioned, prevents outdated instances from being used. Tip You are welcome to write your own application, if it meets community standards, it can be included in the Rankify ecosystem, or used to create your own DAO ecosystem autonomously!","title":"Overview"},{"location":"architecture/applications/#best-list-challenge","text":"The best list challenge is a simple example of an application that can be built on top of the Rankify infrastructure. It allows users to submit their ideas and vote on them to create a ranked list of ideas. Protocol is designed in accordance to autonomous competence identification protocol: participation is anonymous, time continuous and results are verifiable.","title":"Best list challenge"},{"location":"architecture/specifications/","text":"Specifications # This document outlines the detailed specifications for our project. Each section in this document corresponds to a different component of the system and is further divided into two categories: Functional Requirements and Security Requirements. Functional Requirements : define the functionality that a system or system component must be able to perform. They describe what the system should do and include specifications for features, capabilities, and operational constraints. Security Requirements : define the measures that are needed to protect the system from potential threats. They often involve access control, data protection, and system integrity. Security requirements are given per implementation given the context of the implementations as these requirements are not universal. Functional requirements # Repositories # Functional interface requirements are described in IRepository , functionality must fulfill following unit tests: It emits VersionCreated when createVersion is called successfully It reverts with InvalidReleaseIncrement if a release number is incremented by more than one It reverts with ReleaseZeroNotAllowed if a release number is set to zero in createVersion When no release nor version exists: It reverts with VersionHashDoesNotExist if getVersion is called It reverts with ReleaseDoesNotExist if updateReleaseMetadata is called It returns zero if latestRelease is called on repository with no releases It returns zero if buildCount is called on repository with no releases It reverts with VersionHashDoesNotExist if called getLatestVersion(address) It reverts with ReleaseDoesNotExist if called getLatestVersion(uint8) When version and release exists: It reverts with AlreadyInPreviousRelease if createVersion if the same source address It returns correct release count for given major version upon calling buildCount It returns correct Version if getVersion is called with valid major and minor version It returns correct Version if getLatestVersion(address) is called It returns correct Version if getLatestVersion(uint8) is called It emits ReleaseMetadataUpdated when updateReleaseMetadata is called successfully Registry [TBD] # Cells [TBD] # Rank NFT # Must implement OpenSea compatible uri format that can resolve to title, Description and image Must allow only owner to modify metadata May implement additional IRankToken interface Governance Token [TBD] # Applications # There is no strict interface requirements on the applications, they can generally stay unaware of any of the infrastructure components. However, it must implement the following functional requirements: It shall be able to to mint and/or burn at least one Rank NFT asset. Asset minting shall involve participation costs Participation costs shall be immutable parameter paid in ERC20 token Participation payment token must differ from governance token of target organization Participation cost relation to minted asset must be possible to express in formally verifiable way Optional requirements # These formally are not required, but will speed up process of incorporating application in the protocol supporting user interfaces. It shall implement application initialization schema It shall implement instance initialization schema It may implement IRankifyInstanceCommons Installer # installer must implement IRepoInstaller interface, functionality must fulfill following unit tests: it emits RepositoryAdded if addRepository is called successfully. it emits Instantiated if instantiate is called successfully. it reverts with RepositoryDoesNotExist if instantiate is called with non-existing repository. it reverts with VersionDoesNotMatchRequirement if instantiate version does not match. it emits Repositor Removed when removeRepository` is called successfully. it emits Instantiated if instantiateLatest is called successfully. it reverts with RepositoryDoesNotExist if instantiateLatest is called with non-existing repository. when repository already exists: it emits RepositoryRequirementUpdated if addRepository is called successfully with already existing repository. when RepositoryRequirementUpdated was emitted: it reverts with VersionDoesNotMatchRequirement if instance version does not match requirement anymore. it emits Upgraded if upgrade is called successfully. it reverts with VersionDoesNotMatchRequirement if upgrade is called with version that does not match the required version. It returns correct Repository if getRepository is called with valid instance address It returns all instances of a repository if getInstances is called with valid repository address It returns all active repositories if getRepositories is called It returns version tag if getVersion is called with valid instance address It returns VersionRequirement if getVersionRequirement is called with valid instance address It reverts with InstanceDoesNotExist if getVersionRequirement is called with non-existing instance address It reverts with InstanceDoesNotExist if getVersion is called with non-existing instance address It reverts with RepositoryDoesNotExist if getRepository is called with non-existing instance address It reverts with RepositoryDoesNotExist if getInstances is called with non-existing repository address Instance [TBD] # Security requirements # Security specifications outlined per contract instance are implementation agnostic. They are meant to be implemented in a way that is most suitable for the given context. Following definitions extend ERC-2119 definitions: Access point : A function or method that is part of the protected contract's interface. WHITELIST : Set of addresses that are explicitly allowed on certain access points. BLACKLIST : Set addresses that are explicitly disallowed on certain access points. RESTRICTED : An access point that MUST enforce WHITELIST. UNRESTRICTED : An access point that MAY enforce BLACKLIST. DAO Owned Repository # DAO controlled functional Repository must fulfill following security requirements: All non-read methods are RESTRICTED, where only WHITELIST member is Rankify Multisig Rankify Multisig MAY assign WHITELIST members to each access point individually Rankify Multisig MAY revoke WHITELIST members from each access point individually All read methods are UNRESTRICTED, with no BLACKLIST members No one may modify security settings except Rankify Multisig Rankify Multisig MAY transfer it's privileges to another account Rankify Multisig # Multisig controlled functional Safe Wallet Initially deployed with a single signer and 1-of-1, Rankify DAO signer Rankify DAO signer MAY add or remove signers Rankify DAO signer MAY change the threshold Rankify DAO signer MAY revoke it's own signer status App Instances # Installer [TBD] #","title":"Specifications"},{"location":"architecture/specifications/#specifications","text":"This document outlines the detailed specifications for our project. Each section in this document corresponds to a different component of the system and is further divided into two categories: Functional Requirements and Security Requirements. Functional Requirements : define the functionality that a system or system component must be able to perform. They describe what the system should do and include specifications for features, capabilities, and operational constraints. Security Requirements : define the measures that are needed to protect the system from potential threats. They often involve access control, data protection, and system integrity. Security requirements are given per implementation given the context of the implementations as these requirements are not universal.","title":"Specifications"},{"location":"architecture/specifications/#functional-requirements","text":"","title":"Functional requirements"},{"location":"architecture/specifications/#repositories","text":"Functional interface requirements are described in IRepository , functionality must fulfill following unit tests: It emits VersionCreated when createVersion is called successfully It reverts with InvalidReleaseIncrement if a release number is incremented by more than one It reverts with ReleaseZeroNotAllowed if a release number is set to zero in createVersion When no release nor version exists: It reverts with VersionHashDoesNotExist if getVersion is called It reverts with ReleaseDoesNotExist if updateReleaseMetadata is called It returns zero if latestRelease is called on repository with no releases It returns zero if buildCount is called on repository with no releases It reverts with VersionHashDoesNotExist if called getLatestVersion(address) It reverts with ReleaseDoesNotExist if called getLatestVersion(uint8) When version and release exists: It reverts with AlreadyInPreviousRelease if createVersion if the same source address It returns correct release count for given major version upon calling buildCount It returns correct Version if getVersion is called with valid major and minor version It returns correct Version if getLatestVersion(address) is called It returns correct Version if getLatestVersion(uint8) is called It emits ReleaseMetadataUpdated when updateReleaseMetadata is called successfully","title":"Repositories"},{"location":"architecture/specifications/#registry-tbd","text":"","title":"Registry [TBD]"},{"location":"architecture/specifications/#cells-tbd","text":"","title":"Cells [TBD]"},{"location":"architecture/specifications/#rank-nft","text":"Must implement OpenSea compatible uri format that can resolve to title, Description and image Must allow only owner to modify metadata May implement additional IRankToken interface","title":"Rank NFT"},{"location":"architecture/specifications/#governance-token-tbd","text":"","title":"Governance Token [TBD]"},{"location":"architecture/specifications/#applications","text":"There is no strict interface requirements on the applications, they can generally stay unaware of any of the infrastructure components. However, it must implement the following functional requirements: It shall be able to to mint and/or burn at least one Rank NFT asset. Asset minting shall involve participation costs Participation costs shall be immutable parameter paid in ERC20 token Participation payment token must differ from governance token of target organization Participation cost relation to minted asset must be possible to express in formally verifiable way","title":"Applications"},{"location":"architecture/specifications/#optional-requirements","text":"These formally are not required, but will speed up process of incorporating application in the protocol supporting user interfaces. It shall implement application initialization schema It shall implement instance initialization schema It may implement IRankifyInstanceCommons","title":"Optional requirements"},{"location":"architecture/specifications/#installer","text":"installer must implement IRepoInstaller interface, functionality must fulfill following unit tests: it emits RepositoryAdded if addRepository is called successfully. it emits Instantiated if instantiate is called successfully. it reverts with RepositoryDoesNotExist if instantiate is called with non-existing repository. it reverts with VersionDoesNotMatchRequirement if instantiate version does not match. it emits Repositor Removed when removeRepository` is called successfully. it emits Instantiated if instantiateLatest is called successfully. it reverts with RepositoryDoesNotExist if instantiateLatest is called with non-existing repository. when repository already exists: it emits RepositoryRequirementUpdated if addRepository is called successfully with already existing repository. when RepositoryRequirementUpdated was emitted: it reverts with VersionDoesNotMatchRequirement if instance version does not match requirement anymore. it emits Upgraded if upgrade is called successfully. it reverts with VersionDoesNotMatchRequirement if upgrade is called with version that does not match the required version. It returns correct Repository if getRepository is called with valid instance address It returns all instances of a repository if getInstances is called with valid repository address It returns all active repositories if getRepositories is called It returns version tag if getVersion is called with valid instance address It returns VersionRequirement if getVersionRequirement is called with valid instance address It reverts with InstanceDoesNotExist if getVersionRequirement is called with non-existing instance address It reverts with InstanceDoesNotExist if getVersion is called with non-existing instance address It reverts with RepositoryDoesNotExist if getRepository is called with non-existing instance address It reverts with RepositoryDoesNotExist if getInstances is called with non-existing repository address","title":"Installer"},{"location":"architecture/specifications/#instance-tbd","text":"","title":"Instance [TBD]"},{"location":"architecture/specifications/#security-requirements","text":"Security specifications outlined per contract instance are implementation agnostic. They are meant to be implemented in a way that is most suitable for the given context. Following definitions extend ERC-2119 definitions: Access point : A function or method that is part of the protected contract's interface. WHITELIST : Set of addresses that are explicitly allowed on certain access points. BLACKLIST : Set addresses that are explicitly disallowed on certain access points. RESTRICTED : An access point that MUST enforce WHITELIST. UNRESTRICTED : An access point that MAY enforce BLACKLIST.","title":"Security requirements"},{"location":"architecture/specifications/#dao-owned-repository","text":"DAO controlled functional Repository must fulfill following security requirements: All non-read methods are RESTRICTED, where only WHITELIST member is Rankify Multisig Rankify Multisig MAY assign WHITELIST members to each access point individually Rankify Multisig MAY revoke WHITELIST members from each access point individually All read methods are UNRESTRICTED, with no BLACKLIST members No one may modify security settings except Rankify Multisig Rankify Multisig MAY transfer it's privileges to another account","title":"DAO Owned Repository"},{"location":"architecture/specifications/#rankify-multisig","text":"Multisig controlled functional Safe Wallet Initially deployed with a single signer and 1-of-1, Rankify DAO signer Rankify DAO signer MAY add or remove signers Rankify DAO signer MAY change the threshold Rankify DAO signer MAY revoke it's own signer status","title":"Rankify Multisig"},{"location":"architecture/specifications/#app-instances","text":"","title":"App Instances"},{"location":"architecture/specifications/#installer-tbd","text":"","title":"Installer [TBD]"},{"location":"contracts/abstracts/CompositeERC1155/","text":"CompositeERC1155 # Description # An abstract contract that extends LockableERC1155 and provides functionality for composite ERC1155 tokens. Composite tokens can be \"composed\" from multiple underlying assets, which however do not change their owner and in contrast to that use LockableERC1155 standard, which allows to read locked asset BalanceOf, OwnerOf methods correctly Implementation # internal function constructor # constructor(string uri_, address[] dimensionTokens, uint256[] tokenWeights) internal internal function _mint # function _mint(address to, uint256 tokenId, uint256 value, bytes data) internal virtual internal function _burn # function _burn(address from, uint256 id, uint256 amount) internal *Destroys amount tokens of token type id from from Emits a {TransferSingle} event. Requirements: from cannot be the zero address. from must have at least amount tokens of token type id .* public function decompose # function decompose(address from, uint256 id, uint256 amount) public virtual Input Type Description from address The address from which the composite token is being decomposed. id uint256 The ID of the composite token being decomposed. amount uint256 The amount of the composite token to decompose. Decomposes a composite ERC1155 token into its individual components. This function unlocks the specified amount of the composite token from each dimension, and then burns the specified amount of the composite token from the caller's balance. public function burn # function burn(address account, uint256 id, uint256 value) public virtual Input Type Description account address The address of the token owner. id uint256 The ID of the token to burn. value uint256 The amount of tokens to burn. *Burns a specified amount of tokens from the given account. This will burn all underlying (composite) assets Requirements: account must be the token owner or an approved operator. id and value must be valid token ID and amount to burn. All underlying \"composite\" assets implement burn as well* public function getComponents # function getComponents() public virtual returns (address[], uint256[]) Output Type Description 0 address[] An array of component addresses and an array of component weights. 1 uint256[] Retrieves the components of the CompositeERC1155 contract.","title":"CompositeERC1155"},{"location":"contracts/abstracts/CompositeERC1155/#compositeerc1155","text":"","title":"CompositeERC1155"},{"location":"contracts/abstracts/CompositeERC1155/#description","text":"An abstract contract that extends LockableERC1155 and provides functionality for composite ERC1155 tokens. Composite tokens can be \"composed\" from multiple underlying assets, which however do not change their owner and in contrast to that use LockableERC1155 standard, which allows to read locked asset BalanceOf, OwnerOf methods correctly","title":"Description"},{"location":"contracts/abstracts/CompositeERC1155/#implementation","text":"","title":"Implementation"},{"location":"contracts/abstracts/CompositeERC1155/#internal-function-constructor","text":"constructor(string uri_, address[] dimensionTokens, uint256[] tokenWeights) internal","title":"internal function constructor"},{"location":"contracts/abstracts/CompositeERC1155/#internal-function-_mint","text":"function _mint(address to, uint256 tokenId, uint256 value, bytes data) internal virtual","title":"internal function _mint"},{"location":"contracts/abstracts/CompositeERC1155/#internal-function-_burn","text":"function _burn(address from, uint256 id, uint256 amount) internal *Destroys amount tokens of token type id from from Emits a {TransferSingle} event. Requirements: from cannot be the zero address. from must have at least amount tokens of token type id .*","title":"internal function _burn"},{"location":"contracts/abstracts/CompositeERC1155/#public-function-decompose","text":"function decompose(address from, uint256 id, uint256 amount) public virtual Input Type Description from address The address from which the composite token is being decomposed. id uint256 The ID of the composite token being decomposed. amount uint256 The amount of the composite token to decompose. Decomposes a composite ERC1155 token into its individual components. This function unlocks the specified amount of the composite token from each dimension, and then burns the specified amount of the composite token from the caller's balance.","title":"public function decompose"},{"location":"contracts/abstracts/CompositeERC1155/#public-function-burn","text":"function burn(address account, uint256 id, uint256 value) public virtual Input Type Description account address The address of the token owner. id uint256 The ID of the token to burn. value uint256 The amount of tokens to burn. *Burns a specified amount of tokens from the given account. This will burn all underlying (composite) assets Requirements: account must be the token owner or an approved operator. id and value must be valid token ID and amount to burn. All underlying \"composite\" assets implement burn as well*","title":"public function burn"},{"location":"contracts/abstracts/CompositeERC1155/#public-function-getcomponents","text":"function getComponents() public virtual returns (address[], uint256[]) Output Type Description 0 address[] An array of component addresses and an array of component weights. 1 uint256[] Retrieves the components of the CompositeERC1155 contract.","title":"public function getComponents"},{"location":"contracts/abstracts/DiamondReentrancyGuard/","text":"# Description # Implementation # internal modifier nonReentrant # modifier nonReentrant()","title":"DiamondReentrancyGuard"},{"location":"contracts/abstracts/DiamondReentrancyGuard/#_1","text":"","title":""},{"location":"contracts/abstracts/DiamondReentrancyGuard/#description","text":"","title":"Description"},{"location":"contracts/abstracts/DiamondReentrancyGuard/#implementation","text":"","title":"Implementation"},{"location":"contracts/abstracts/DiamondReentrancyGuard/#internal-modifier-nonreentrant","text":"modifier nonReentrant()","title":"internal modifier nonReentrant"},{"location":"contracts/abstracts/IVInstallerPlugin/","text":"# Description # Implementation #","title":"IVInstallerPlugin"},{"location":"contracts/abstracts/IVInstallerPlugin/#_1","text":"","title":""},{"location":"contracts/abstracts/IVInstallerPlugin/#description","text":"","title":"Description"},{"location":"contracts/abstracts/IVInstallerPlugin/#implementation","text":"","title":"Implementation"},{"location":"contracts/abstracts/LockableERC1155/","text":"# error insufficient # error insufficient(uint256 id, uint256 balance, uint256 required) LockableERC1155 # Description # This is an abstract contract that extends the ERC1155 token contract and implements the ILockableERC1155 interface. It provides functionality to lock and unlock token amounts for specific accounts and IDs. Implementation # internal variable lockedAmounts # mapping(address => mapping(uint256 => uint256)) lockedAmounts public function lock # function lock(address account, uint256 id, uint256 amount) public virtual Input Type Description account address The address of the account to lock tokens for. id uint256 The ID of the token to lock. amount uint256 The amount of tokens to lock. Locks a specified amount of tokens for a given account and token ID. If the account does not have enough balance to lock the specified amount, the function will revert with an \"insufficient\" error message. Emits a TokensLocked event after successfully locking the tokens. public function unlock # function unlock(address account, uint256 id, uint256 amount) public virtual Input Type Description account address The address of the account to unlock tokens for. id uint256 The ID of the token to unlock. amount uint256 The amount of tokens to unlock. Unlocks a specified amount of tokens for a given account and token ID. If the locked amount is less than the specified amount, it reverts with an \"insufficient\" error message. Emits a TokensUnlocked event after unlocking the tokens. public function unlockedBalanceOf # function unlockedBalanceOf(address account, uint256 id) public view returns (uint256) Input Type Description account address The address of the account. id uint256 The ID of the ERC1155 token. Output 0 uint256 The unlocked balance of the ERC1155 token for the account. Returns the unlocked balance of a specific ERC1155 token for an account. The unlocked balance is calculated by subtracting the locked amount from the total balance. internal function _beforeTokenTransfer # function _beforeTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal virtual Input Type Description operator address The address performing the token transfer. from address The address from which the tokens are being transferred. to address The address to which the tokens are being transferred. ids uint256[] An array of token IDs being transferred. amounts uint256[] An array of token amounts being transferred. data bytes Additional data attached to the transfer. Hook function that is called before any token transfer. It checks if the transfer is allowed based on the locked amounts of the tokens. If the transfer is not allowed, it reverts with an error message.","title":"LockableERC1155"},{"location":"contracts/abstracts/LockableERC1155/#_1","text":"","title":""},{"location":"contracts/abstracts/LockableERC1155/#error-insufficient","text":"error insufficient(uint256 id, uint256 balance, uint256 required)","title":"error insufficient"},{"location":"contracts/abstracts/LockableERC1155/#lockableerc1155","text":"","title":"LockableERC1155"},{"location":"contracts/abstracts/LockableERC1155/#description","text":"This is an abstract contract that extends the ERC1155 token contract and implements the ILockableERC1155 interface. It provides functionality to lock and unlock token amounts for specific accounts and IDs.","title":"Description"},{"location":"contracts/abstracts/LockableERC1155/#implementation","text":"","title":"Implementation"},{"location":"contracts/abstracts/LockableERC1155/#internal-variable-lockedamounts","text":"mapping(address => mapping(uint256 => uint256)) lockedAmounts","title":"internal variable lockedAmounts"},{"location":"contracts/abstracts/LockableERC1155/#public-function-lock","text":"function lock(address account, uint256 id, uint256 amount) public virtual Input Type Description account address The address of the account to lock tokens for. id uint256 The ID of the token to lock. amount uint256 The amount of tokens to lock. Locks a specified amount of tokens for a given account and token ID. If the account does not have enough balance to lock the specified amount, the function will revert with an \"insufficient\" error message. Emits a TokensLocked event after successfully locking the tokens.","title":"public function lock"},{"location":"contracts/abstracts/LockableERC1155/#public-function-unlock","text":"function unlock(address account, uint256 id, uint256 amount) public virtual Input Type Description account address The address of the account to unlock tokens for. id uint256 The ID of the token to unlock. amount uint256 The amount of tokens to unlock. Unlocks a specified amount of tokens for a given account and token ID. If the locked amount is less than the specified amount, it reverts with an \"insufficient\" error message. Emits a TokensUnlocked event after unlocking the tokens.","title":"public function unlock"},{"location":"contracts/abstracts/LockableERC1155/#public-function-unlockedbalanceof","text":"function unlockedBalanceOf(address account, uint256 id) public view returns (uint256) Input Type Description account address The address of the account. id uint256 The ID of the ERC1155 token. Output 0 uint256 The unlocked balance of the ERC1155 token for the account. Returns the unlocked balance of a specific ERC1155 token for an account. The unlocked balance is calculated by subtracting the locked amount from the total balance.","title":"public function unlockedBalanceOf"},{"location":"contracts/abstracts/LockableERC1155/#internal-function-_beforetokentransfer","text":"function _beforeTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal virtual Input Type Description operator address The address performing the token transfer. from address The address from which the tokens are being transferred. to address The address to which the tokens are being transferred. ids uint256[] An array of token IDs being transferred. amounts uint256[] An array of token amounts being transferred. data bytes Additional data attached to the transfer. Hook function that is called before any token transfer. It checks if the transfer is allowed based on the locked amounts of the tokens. If the transfer is not allowed, it reverts with an error message.","title":"internal function _beforeTokenTransfer"},{"location":"contracts/abstracts/draft-EIP712Diamond/","text":"# Description # https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data. The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible, thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in their contracts using a combination of abi.encode and keccak256 . This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA ({_hashTypedDataV4}). The implementation of the domain separator was designed to be as efficient as possible while still properly updating the chain id to protect against replay attacks on an eventual fork of the chain. NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method https://docs.metamask.io/guide/signing-data.html[ eth_signTypedDataV4 in MetaMask]. Available since v3.4. Implementation # internal function constructor # constructor() internal *Initializes the domain separator and parameter caches. The meaning of name and version is specified in https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]: name : the user readable name of the signing domain, i.e. the name of the DApp or the protocol. version : the current major version of the signing domain. NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart contract upgrade].* internal function _domainSeparatorV4 # function _domainSeparatorV4() internal view returns (bytes32) Returns the domain separator for the current chain. internal function _hashTypedDataV4 # function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) *Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this function returns the hash of the fully encoded EIP712 message for this domain. This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example: solidity bytes32 digest = _hashTypedDataV4(keccak256(abi.encode( keccak256(\"Mail(address to,string contents)\"), mailTo, keccak256(bytes(mailContents)) ))); address signer = ECDSA.recover(digest, signature); *","title":"draft EIP712Diamond"},{"location":"contracts/abstracts/draft-EIP712Diamond/#_1","text":"","title":""},{"location":"contracts/abstracts/draft-EIP712Diamond/#description","text":"https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data. The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible, thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in their contracts using a combination of abi.encode and keccak256 . This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA ({_hashTypedDataV4}). The implementation of the domain separator was designed to be as efficient as possible while still properly updating the chain id to protect against replay attacks on an eventual fork of the chain. NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method https://docs.metamask.io/guide/signing-data.html[ eth_signTypedDataV4 in MetaMask]. Available since v3.4.","title":"Description"},{"location":"contracts/abstracts/draft-EIP712Diamond/#implementation","text":"","title":"Implementation"},{"location":"contracts/abstracts/draft-EIP712Diamond/#internal-function-constructor","text":"constructor() internal *Initializes the domain separator and parameter caches. The meaning of name and version is specified in https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]: name : the user readable name of the signing domain, i.e. the name of the DApp or the protocol. version : the current major version of the signing domain. NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart contract upgrade].*","title":"internal function constructor"},{"location":"contracts/abstracts/draft-EIP712Diamond/#internal-function-_domainseparatorv4","text":"function _domainSeparatorV4() internal view returns (bytes32) Returns the domain separator for the current chain.","title":"internal function _domainSeparatorV4"},{"location":"contracts/abstracts/draft-EIP712Diamond/#internal-function-_hashtypeddatav4","text":"function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) *Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this function returns the hash of the fully encoded EIP712 message for this domain. This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example: solidity bytes32 digest = _hashTypedDataV4(keccak256(abi.encode( keccak256(\"Mail(address to,string contents)\"), mailTo, keccak256(bytes(mailContents)) ))); address signer = ECDSA.recover(digest, signature); *","title":"internal function _hashTypedDataV4"},{"location":"contracts/facets/DNSFacet/","text":"# Description # Implementation # internal function _isValidSignature # function _isValidSignature(bytes message, bytes signature, address account) internal view returns (bool) public function initializeDomain # function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) public *Initializes new LibMultipass.Domain and configures it's parameters Requirements: registrar is not zero domainName is not empty domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names domainName does not exist yet onlyOwner referrerReward+referralDiscount cannot be larger than fee @param registrar address of registrar @param freeRegistrationsNumber number of registrations free of fee @param fee fee in base currency of network @param domainName name of LibMultipass.Domain @param referrerReward referral fee share in base currency of network @param referralDiscount referral discount in base currency of network Emits an {InitializedDomain} event.* public function activateDomain # function activateDomain(bytes32 domainName) public *Activates LibMultipass.Domain name Requirements: msg.sender is Owner Emits an {DomainActivated} event.* public function deactivateDomain # function deactivateDomain(bytes32 domainName) public *Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements: msg.sender is Owner OR registrar Emits an {DomainDeactivated} event.* public function changeFee # function changeFee(bytes32 domainName, uint256 fee) public *Changes registrar address Requirements: msg.sender is Owner Emits an {DomainFeeChanged} event.* public function changeRegistrar # function changeRegistrar(bytes32 domainName, address newRegistrar) public *Changes registrar address Requirements: msg.sender is Owner Emits an {RegistrarChangeRequested} event.* public function deleteName # function deleteName(struct LibMultipass.NameQuery query) public *deletes name Requirements: msg.sender is Owner Emits an {DomainTTLChangeRequested} event.* public function changeReferralProgram # function changeReferralProgram(uint256 referrerReward, uint256 freeRegistrations, uint256 referralDiscount, bytes32 domainName) public public function resolveRecord # function resolveRecord(struct LibMultipass.NameQuery query) public view returns (bool, struct LibMultipass.Record) resolves LibMultipass.Record of name query in to status and identity public function register # function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) public payable *registers new name under LibMultipass.Domain Requirements: all arguments must be set domainName must be active resolveRecord for given arguments should return no LibMultipass.Record Emits an {registered} event.* public function getModifyPrice # function getModifyPrice(struct LibMultipass.NameQuery query) public view returns (uint256) public function modifyUserName # function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) public payable Input Type Description domainName bytes32 LibMultipass.Domain query struct LibMultipass.NameQuery newName bytes32 new name Emits an {Modified} event. registrarSignature bytes signatureDeadline uint256 *modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain* external function getBalance # function getBalance() external view returns (uint256) returns balance of this contract external function getDomainState # function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain) Input Type Description domainName bytes32 name of the LibMultipass.Domain Output 0 struct LibMultipass.Domain (name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize) returns LibMultipass.Domain state variables external function getDomainStateByIdx # function getDomainStateByIdx(uint256 index) external view returns (struct LibMultipass.Domain) external function getContractState # function getContractState() external view returns (uint256) Output Type Description 0 uint256 (s_numDomains) returns contract state variables public function withrawFunds # function withrawFunds(address to) public *Withraws funds stored in smart contract Requirements: onlyOwner Emits an {fundsWithdawn} event.*","title":"DNSFacet"},{"location":"contracts/facets/DNSFacet/#_1","text":"","title":""},{"location":"contracts/facets/DNSFacet/#description","text":"","title":"Description"},{"location":"contracts/facets/DNSFacet/#implementation","text":"","title":"Implementation"},{"location":"contracts/facets/DNSFacet/#internal-function-_isvalidsignature","text":"function _isValidSignature(bytes message, bytes signature, address account) internal view returns (bool)","title":"internal function _isValidSignature"},{"location":"contracts/facets/DNSFacet/#public-function-initializedomain","text":"function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) public *Initializes new LibMultipass.Domain and configures it's parameters Requirements: registrar is not zero domainName is not empty domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names domainName does not exist yet onlyOwner referrerReward+referralDiscount cannot be larger than fee @param registrar address of registrar @param freeRegistrationsNumber number of registrations free of fee @param fee fee in base currency of network @param domainName name of LibMultipass.Domain @param referrerReward referral fee share in base currency of network @param referralDiscount referral discount in base currency of network Emits an {InitializedDomain} event.*","title":"public function initializeDomain"},{"location":"contracts/facets/DNSFacet/#public-function-activatedomain","text":"function activateDomain(bytes32 domainName) public *Activates LibMultipass.Domain name Requirements: msg.sender is Owner Emits an {DomainActivated} event.*","title":"public function activateDomain"},{"location":"contracts/facets/DNSFacet/#public-function-deactivatedomain","text":"function deactivateDomain(bytes32 domainName) public *Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements: msg.sender is Owner OR registrar Emits an {DomainDeactivated} event.*","title":"public function deactivateDomain"},{"location":"contracts/facets/DNSFacet/#public-function-changefee","text":"function changeFee(bytes32 domainName, uint256 fee) public *Changes registrar address Requirements: msg.sender is Owner Emits an {DomainFeeChanged} event.*","title":"public function changeFee"},{"location":"contracts/facets/DNSFacet/#public-function-changeregistrar","text":"function changeRegistrar(bytes32 domainName, address newRegistrar) public *Changes registrar address Requirements: msg.sender is Owner Emits an {RegistrarChangeRequested} event.*","title":"public function changeRegistrar"},{"location":"contracts/facets/DNSFacet/#public-function-deletename","text":"function deleteName(struct LibMultipass.NameQuery query) public *deletes name Requirements: msg.sender is Owner Emits an {DomainTTLChangeRequested} event.*","title":"public function deleteName"},{"location":"contracts/facets/DNSFacet/#public-function-changereferralprogram","text":"function changeReferralProgram(uint256 referrerReward, uint256 freeRegistrations, uint256 referralDiscount, bytes32 domainName) public","title":"public function changeReferralProgram"},{"location":"contracts/facets/DNSFacet/#public-function-resolverecord","text":"function resolveRecord(struct LibMultipass.NameQuery query) public view returns (bool, struct LibMultipass.Record) resolves LibMultipass.Record of name query in to status and identity","title":"public function resolveRecord"},{"location":"contracts/facets/DNSFacet/#public-function-register","text":"function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) public payable *registers new name under LibMultipass.Domain Requirements: all arguments must be set domainName must be active resolveRecord for given arguments should return no LibMultipass.Record Emits an {registered} event.*","title":"public function register"},{"location":"contracts/facets/DNSFacet/#public-function-getmodifyprice","text":"function getModifyPrice(struct LibMultipass.NameQuery query) public view returns (uint256)","title":"public function getModifyPrice"},{"location":"contracts/facets/DNSFacet/#public-function-modifyusername","text":"function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) public payable Input Type Description domainName bytes32 LibMultipass.Domain query struct LibMultipass.NameQuery newName bytes32 new name Emits an {Modified} event. registrarSignature bytes signatureDeadline uint256 *modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain*","title":"public function modifyUserName"},{"location":"contracts/facets/DNSFacet/#external-function-getbalance","text":"function getBalance() external view returns (uint256) returns balance of this contract","title":"external function getBalance"},{"location":"contracts/facets/DNSFacet/#external-function-getdomainstate","text":"function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain) Input Type Description domainName bytes32 name of the LibMultipass.Domain Output 0 struct LibMultipass.Domain (name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize) returns LibMultipass.Domain state variables","title":"external function getDomainState"},{"location":"contracts/facets/DNSFacet/#external-function-getdomainstatebyidx","text":"function getDomainStateByIdx(uint256 index) external view returns (struct LibMultipass.Domain)","title":"external function getDomainStateByIdx"},{"location":"contracts/facets/DNSFacet/#external-function-getcontractstate","text":"function getContractState() external view returns (uint256) Output Type Description 0 uint256 (s_numDomains) returns contract state variables","title":"external function getContractState"},{"location":"contracts/facets/DNSFacet/#public-function-withrawfunds","text":"function withrawFunds(address to) public *Withraws funds stored in smart contract Requirements: onlyOwner Emits an {fundsWithdawn} event.*","title":"public function withrawFunds"},{"location":"contracts/facets/EIP712InspectorFacet/","text":"# Description # Implementation # public function inspectEIP712Hashes # function inspectEIP712Hashes() public view returns (bytes32 _CACHED_DOMAIN_SEPARATOR, uint256 _CACHED_CHAIN_ID, address _CACHED_THIS, bytes32 _HASHED_NAME, bytes32 _HASHED_VERSION, bytes32 _TYPE_HASH) public function currentChainId # function currentChainId() public view returns (uint256)","title":"EIP712InspectorFacet"},{"location":"contracts/facets/EIP712InspectorFacet/#_1","text":"","title":""},{"location":"contracts/facets/EIP712InspectorFacet/#description","text":"","title":"Description"},{"location":"contracts/facets/EIP712InspectorFacet/#implementation","text":"","title":"Implementation"},{"location":"contracts/facets/EIP712InspectorFacet/#public-function-inspecteip712hashes","text":"function inspectEIP712Hashes() public view returns (bytes32 _CACHED_DOMAIN_SEPARATOR, uint256 _CACHED_CHAIN_ID, address _CACHED_THIS, bytes32 _HASHED_NAME, bytes32 _HASHED_VERSION, bytes32 _TYPE_HASH)","title":"public function inspectEIP712Hashes"},{"location":"contracts/facets/EIP712InspectorFacet/#public-function-currentchainid","text":"function currentChainId() public view returns (uint256)","title":"public function currentChainId"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/","text":"# Description # Implementation # event OverTime # event OverTime(uint256 gameId) event LastTurn # event LastTurn(uint256 gameId) event ProposalScore # event ProposalScore(uint256 gameId, uint256 turn, string proposalHash, string proposal, uint256 score) event TurnEnded # event TurnEnded(uint256 gameId, uint256 turn, address[] players, uint256[] scores, string[] newProposals, uint256[] proposerIndicies, uint256[][] votes) event GameOver # event GameOver(uint256 gameId, address[] players, uint256[] scores) event ProposalSubmitted # event ProposalSubmitted(uint256 gameId, uint256 turn, address proposer, bytes32 commitmentHash, string proposalEncryptedByGM) public struct ProposalParams # struct ProposalParams { uint256 gameId; string encryptedProposal; bytes32 commitmentHash; address proposer; } event VoteSubmitted # event VoteSubmitted(uint256 gameId, uint256 turn, address player, string votesHidden) public function submitVote # function submitVote(uint256 gameId, string encryptedVotes, address voter) public *Submits a vote for a game. gameId is the ID of the game. encryptedVotes is the encrypted votes. voter is the address of the voter. Emits a VoteSubmitted event. Requirements: The caller must be a game master of the game with gameId . The game with gameId must exist. The game with gameId must have started. The game with gameId must not be over. voter must be in the game with gameId . The current turn of the game with gameId must be greater than 1.* public function submitProposal # function submitProposal(struct RankifyInstanceGameMastersFacet.ProposalParams proposalData) public *Submits a proposal for a game. proposalData is the proposal data. Requirements: The game with proposalData.gameId must exist. The caller must be a game master of the game with proposalData.gameId .* public function endTurn # function endTurn(uint256 gameId, uint256[][] votes, string[] newProposals, uint256[] proposerIndicies) public *Ends the current turn of a game with the provided game ID. gameId is the ID of the game. votes is the array of votes. newProposals is the array of new proposals for the upcoming voting round. proposerIndicies is the array of indices of the proposers in the previous voting round. emits a ProposalScore event for each player if the turn is not the first. emits a TurnEnded event. Modifies: Calls the _nextTurn function with gameId and newProposals . Resets the number of commitments of the game with gameId to 0. Resets the proposal commitment hash and ongoing proposal of each player in the game with gameId . Requirements: The caller must be a game master of the game with gameId . The game with gameId must have started. The game with gameId must not be over. newProposals array MUST be sorted randomly to ensure privacy votes and proposerIndicies MUST correspond to players array from game.getPlayers()*","title":"RankifyInstanceGameMastersFacet"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#_1","text":"","title":""},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#description","text":"","title":"Description"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#implementation","text":"","title":"Implementation"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#event-overtime","text":"event OverTime(uint256 gameId)","title":"event OverTime"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#event-lastturn","text":"event LastTurn(uint256 gameId)","title":"event LastTurn"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#event-proposalscore","text":"event ProposalScore(uint256 gameId, uint256 turn, string proposalHash, string proposal, uint256 score)","title":"event ProposalScore"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#event-turnended","text":"event TurnEnded(uint256 gameId, uint256 turn, address[] players, uint256[] scores, string[] newProposals, uint256[] proposerIndicies, uint256[][] votes)","title":"event TurnEnded"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#event-gameover","text":"event GameOver(uint256 gameId, address[] players, uint256[] scores)","title":"event GameOver"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#event-proposalsubmitted","text":"event ProposalSubmitted(uint256 gameId, uint256 turn, address proposer, bytes32 commitmentHash, string proposalEncryptedByGM)","title":"event ProposalSubmitted"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#public-struct-proposalparams","text":"struct ProposalParams { uint256 gameId; string encryptedProposal; bytes32 commitmentHash; address proposer; }","title":"public struct ProposalParams"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#event-votesubmitted","text":"event VoteSubmitted(uint256 gameId, uint256 turn, address player, string votesHidden)","title":"event VoteSubmitted"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#public-function-submitvote","text":"function submitVote(uint256 gameId, string encryptedVotes, address voter) public *Submits a vote for a game. gameId is the ID of the game. encryptedVotes is the encrypted votes. voter is the address of the voter. Emits a VoteSubmitted event. Requirements: The caller must be a game master of the game with gameId . The game with gameId must exist. The game with gameId must have started. The game with gameId must not be over. voter must be in the game with gameId . The current turn of the game with gameId must be greater than 1.*","title":"public function submitVote"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#public-function-submitproposal","text":"function submitProposal(struct RankifyInstanceGameMastersFacet.ProposalParams proposalData) public *Submits a proposal for a game. proposalData is the proposal data. Requirements: The game with proposalData.gameId must exist. The caller must be a game master of the game with proposalData.gameId .*","title":"public function submitProposal"},{"location":"contracts/facets/RankifyInstanceGameMastersFacet/#public-function-endturn","text":"function endTurn(uint256 gameId, uint256[][] votes, string[] newProposals, uint256[] proposerIndicies) public *Ends the current turn of a game with the provided game ID. gameId is the ID of the game. votes is the array of votes. newProposals is the array of new proposals for the upcoming voting round. proposerIndicies is the array of indices of the proposers in the previous voting round. emits a ProposalScore event for each player if the turn is not the first. emits a TurnEnded event. Modifies: Calls the _nextTurn function with gameId and newProposals . Resets the number of commitments of the game with gameId to 0. Resets the proposal commitment hash and ongoing proposal of each player in the game with gameId . Requirements: The caller must be a game master of the game with gameId . The game with gameId must have started. The game with gameId must not be over. newProposals array MUST be sorted randomly to ensure privacy votes and proposerIndicies MUST correspond to players array from game.getPlayers()*","title":"public function endTurn"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/","text":"# error ZeroValue # error ZeroValue() # error WrongAddress # error WrongAddress() # error OutOfBounds # error OutOfBounds() # Description # Implementation # internal function RInstanceStorage # function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog) external function setGamePrice # function setGamePrice(uint256 newPrice) external *Sets the game price. newPrice is the new game price. Modifies: Sets the game price to newPrice . Requirements: The caller must be the contract owner.* external function setJoinGamePrice # function setJoinGamePrice(uint256 newPrice) external *Sets the join game price. newPrice is the new join game price. Modifies: Sets the join game price to newPrice . Requirements: The caller must be the contract owner.* external function setRankTokenAddress # function setRankTokenAddress(address newRankToken) external *Sets the rank token address. newRankToken is the new rank token address. Modifies: Sets the rank token address to newRankToken . Requirements: The caller must be the contract owner. newRankToken must not be the zero address. newRankToken must support the ERC1155 interface.* external function setTimePerTurn # function setTimePerTurn(uint256 newTimePerTurn) external *Sets the time per turn. newTimePerTurn is the new time per turn. Modifies: Sets the time per turn to newTimePerTurn . Requirements: The caller must be the contract owner.* external function setMaxPlayersSize # function setMaxPlayersSize(uint256 newMaxPlayersSize) external *Sets the maximum number of players in a game. newMaxPlayersSize is the new maximum number of players. Modifies: Sets the maximum number of players to newMaxPlayersSize . Requirements: The caller must be the contract owner. newMaxPlayersSize must be greater than or equal to the minimum number of players.* external function setMinPlayersSize # function setMinPlayersSize(uint256 newMinPlayersSize) external *Sets the minimum number of players in a game. newMinPlayersSize is the new minimum number of players. Modifies: Sets the minimum number of players to newMinPlayersSize . Requirements: The caller must be the contract owner. newMinPlayersSize must be less than or equal to the maximum number of players.* external function setTimeToJoin # function setTimeToJoin(uint256 newTimeToJoin) external *Sets the time to join a game. newTimeToJoin is the new time to join. Modifies: Sets the time to join to newTimeToJoin . Requirements: The caller must be the contract owner. newTimeToJoin must not be zero.* external function setMaxTurns # function setMaxTurns(uint256 newMaxTurns) external *Sets the maximum number of turns in a game. newMaxTurns is the new maximum number of turns. Modifies: Sets the maximum number of turns to newMaxTurns . Requirements: The caller must be the contract owner. newMaxTurns must not be zero.*","title":"RankifyInstanceGameOwnersFacet"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#_1","text":"","title":""},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#error-zerovalue","text":"error ZeroValue()","title":"error ZeroValue"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#_2","text":"","title":""},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#error-wrongaddress","text":"error WrongAddress()","title":"error WrongAddress"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#_3","text":"","title":""},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#error-outofbounds","text":"error OutOfBounds()","title":"error OutOfBounds"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#_4","text":"","title":""},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#description","text":"","title":"Description"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#implementation","text":"","title":"Implementation"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#internal-function-rinstancestorage","text":"function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog)","title":"internal function RInstanceStorage"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#external-function-setgameprice","text":"function setGamePrice(uint256 newPrice) external *Sets the game price. newPrice is the new game price. Modifies: Sets the game price to newPrice . Requirements: The caller must be the contract owner.*","title":"external function setGamePrice"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#external-function-setjoingameprice","text":"function setJoinGamePrice(uint256 newPrice) external *Sets the join game price. newPrice is the new join game price. Modifies: Sets the join game price to newPrice . Requirements: The caller must be the contract owner.*","title":"external function setJoinGamePrice"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#external-function-setranktokenaddress","text":"function setRankTokenAddress(address newRankToken) external *Sets the rank token address. newRankToken is the new rank token address. Modifies: Sets the rank token address to newRankToken . Requirements: The caller must be the contract owner. newRankToken must not be the zero address. newRankToken must support the ERC1155 interface.*","title":"external function setRankTokenAddress"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#external-function-settimeperturn","text":"function setTimePerTurn(uint256 newTimePerTurn) external *Sets the time per turn. newTimePerTurn is the new time per turn. Modifies: Sets the time per turn to newTimePerTurn . Requirements: The caller must be the contract owner.*","title":"external function setTimePerTurn"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#external-function-setmaxplayerssize","text":"function setMaxPlayersSize(uint256 newMaxPlayersSize) external *Sets the maximum number of players in a game. newMaxPlayersSize is the new maximum number of players. Modifies: Sets the maximum number of players to newMaxPlayersSize . Requirements: The caller must be the contract owner. newMaxPlayersSize must be greater than or equal to the minimum number of players.*","title":"external function setMaxPlayersSize"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#external-function-setminplayerssize","text":"function setMinPlayersSize(uint256 newMinPlayersSize) external *Sets the minimum number of players in a game. newMinPlayersSize is the new minimum number of players. Modifies: Sets the minimum number of players to newMinPlayersSize . Requirements: The caller must be the contract owner. newMinPlayersSize must be less than or equal to the maximum number of players.*","title":"external function setMinPlayersSize"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#external-function-settimetojoin","text":"function setTimeToJoin(uint256 newTimeToJoin) external *Sets the time to join a game. newTimeToJoin is the new time to join. Modifies: Sets the time to join to newTimeToJoin . Requirements: The caller must be the contract owner. newTimeToJoin must not be zero.*","title":"external function setTimeToJoin"},{"location":"contracts/facets/RankifyInstanceGameOwnersFacet/#external-function-setmaxturns","text":"function setMaxTurns(uint256 newMaxTurns) external *Sets the maximum number of turns in a game. newMaxTurns is the new maximum number of turns. Modifies: Sets the maximum number of turns to newMaxTurns . Requirements: The caller must be the contract owner. newMaxTurns must not be zero.*","title":"external function setMaxTurns"},{"location":"contracts/facets/RankifyInstanceMainFacet/","text":"# Description # Implementation # internal function RInstanceStorage # function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog) public function createGame # function createGame(address gameMaster, uint256 gameId, uint256 gameRank) public *Creates a new game with the provided game master, game ID, and game rank. Optionally, additional ranks can be provided. gameMaster is the address of the game master. gameId is the ID of the new game. gameRank is the rank of the new game. additionalRanks is the array of additional ranks. emits a GameCreated event. Requirements: There are some game price requirments that must be met under gameId.newGame function that are set during the contract initialization and refer to the contract maintainer benefits. Modifies: Calls the newGame function with gameMaster , gameRank , and msg.sender . Configures the coin vending with gameId and an empty configuration. If additionalRanks is not empty, mints rank tokens for each additional rank and sets the additional ranks of the game with gameId to additionalRanks .* public function createGame # function createGame(address gameMaster, uint256 gameId, uint256 gameRank, address[] additionalRanks) public public function createGame # function createGame(address gameMaster, uint256 gameRank) public public function cancelGame # function cancelGame(uint256 gameId) public *Cancels a game with the provided game ID. gameId is the ID of the game. Modifies: Calls the enforceIsGameCreator function with msg.sender . Requirements: The caller must be the game creator of the game with gameId . Game must not be started.* public function leaveGame # function leaveGame(uint256 gameId) public *Allows a player to leave a game with the provided game ID. gameId is the ID of the game. Modifies: Calls the quitGame function with msg.sender , true , and onPlayerQuit . Requirements: The caller must be a player in the game with gameId . Game must not be started.* public function openRegistration # function openRegistration(uint256 gameId) public *Opens registration for a game with the provided game ID. gameId is the ID of the game. emits a RegistrationOpen event. Modifies: Calls the enforceIsGameCreator function with msg.sender . Calls the enforceIsPreRegistrationStage function. Calls the openRegistration function. Requirements: The caller must be the game creator of the game with gameId . The game with gameId must be in the pre-registration stage.* public function joinGame # function joinGame(uint256 gameId) public payable *Allows a player to join a game with the provided game ID. gameId is the ID of the game. emits a PlayerJoined event. Modifies: Calls the joinGame function with msg.sender . Calls the fund function with bytes32(gameId) . Requirements: The caller must not be a player in the game with gameId . Game phase must be registration. Caller must be able to fulfill funding requirements.* public function startGame # function startGame(uint256 gameId) public *Starts a game with the provided game ID early. gameId is the ID of the game. emits a GameStarted event. Modifies: Calls the enforceGameExists function. Calls the startGameEarly function. Requirements: The game with gameId must exist.* public function onERC1155Received # function onERC1155Received(address operator, address, uint256, uint256, bytes) public view returns (bytes4) external function onERC1155BatchReceived # function onERC1155BatchReceived(address operator, address, uint256[], uint256[], bytes) external view returns (bytes4) external function onERC721Received # function onERC721Received(address operator, address, uint256, bytes) external view returns (bytes4) public function getContractState # function getContractState() public view returns (struct IRankifyInstanceCommons.RInstanceState) public function getTurn # function getTurn(uint256 gameId) public view returns (uint256) public function getGM # function getGM(uint256 gameId) public view returns (address) public function getScores # function getScores(uint256 gameId) public view returns (address[], uint256[]) public function isOvertime # function isOvertime(uint256 gameId) public view returns (bool) public function isGameOver # function isGameOver(uint256 gameId) public view returns (bool) public function getPlayersGame # function getPlayersGame(address player) public view returns (uint256) public function isLastTurn # function isLastTurn(uint256 gameId) public view returns (bool) public function isRegistrationOpen # function isRegistrationOpen(uint256 gameId) public view returns (bool) public function gameCreator # function gameCreator(uint256 gameId) public view returns (address) public function getGameRank # function getGameRank(uint256 gameId) public view returns (uint256) public function getPlayers # function getPlayers(uint256 gameId) public view returns (address[]) public function canStartGame # function canStartGame(uint256 gameId) public view returns (bool) public function canEndTurn # function canEndTurn(uint256 gameId) public view returns (bool) public function isPlayerTurnComplete # function isPlayerTurnComplete(uint256 gameId, address player) public view returns (bool) public function getPlayerVotedArray # function getPlayerVotedArray(uint256 gameId) public view returns (bool[]) public function getPlayersMoved # function getPlayersMoved(uint256 gameId) public view returns (bool[], uint256)","title":"RankifyInstanceMainFacet"},{"location":"contracts/facets/RankifyInstanceMainFacet/#_1","text":"","title":""},{"location":"contracts/facets/RankifyInstanceMainFacet/#description","text":"","title":"Description"},{"location":"contracts/facets/RankifyInstanceMainFacet/#implementation","text":"","title":"Implementation"},{"location":"contracts/facets/RankifyInstanceMainFacet/#internal-function-rinstancestorage","text":"function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog)","title":"internal function RInstanceStorage"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-creategame","text":"function createGame(address gameMaster, uint256 gameId, uint256 gameRank) public *Creates a new game with the provided game master, game ID, and game rank. Optionally, additional ranks can be provided. gameMaster is the address of the game master. gameId is the ID of the new game. gameRank is the rank of the new game. additionalRanks is the array of additional ranks. emits a GameCreated event. Requirements: There are some game price requirments that must be met under gameId.newGame function that are set during the contract initialization and refer to the contract maintainer benefits. Modifies: Calls the newGame function with gameMaster , gameRank , and msg.sender . Configures the coin vending with gameId and an empty configuration. If additionalRanks is not empty, mints rank tokens for each additional rank and sets the additional ranks of the game with gameId to additionalRanks .*","title":"public function createGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-creategame_1","text":"function createGame(address gameMaster, uint256 gameId, uint256 gameRank, address[] additionalRanks) public","title":"public function createGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-creategame_2","text":"function createGame(address gameMaster, uint256 gameRank) public","title":"public function createGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-cancelgame","text":"function cancelGame(uint256 gameId) public *Cancels a game with the provided game ID. gameId is the ID of the game. Modifies: Calls the enforceIsGameCreator function with msg.sender . Requirements: The caller must be the game creator of the game with gameId . Game must not be started.*","title":"public function cancelGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-leavegame","text":"function leaveGame(uint256 gameId) public *Allows a player to leave a game with the provided game ID. gameId is the ID of the game. Modifies: Calls the quitGame function with msg.sender , true , and onPlayerQuit . Requirements: The caller must be a player in the game with gameId . Game must not be started.*","title":"public function leaveGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-openregistration","text":"function openRegistration(uint256 gameId) public *Opens registration for a game with the provided game ID. gameId is the ID of the game. emits a RegistrationOpen event. Modifies: Calls the enforceIsGameCreator function with msg.sender . Calls the enforceIsPreRegistrationStage function. Calls the openRegistration function. Requirements: The caller must be the game creator of the game with gameId . The game with gameId must be in the pre-registration stage.*","title":"public function openRegistration"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-joingame","text":"function joinGame(uint256 gameId) public payable *Allows a player to join a game with the provided game ID. gameId is the ID of the game. emits a PlayerJoined event. Modifies: Calls the joinGame function with msg.sender . Calls the fund function with bytes32(gameId) . Requirements: The caller must not be a player in the game with gameId . Game phase must be registration. Caller must be able to fulfill funding requirements.*","title":"public function joinGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-startgame","text":"function startGame(uint256 gameId) public *Starts a game with the provided game ID early. gameId is the ID of the game. emits a GameStarted event. Modifies: Calls the enforceGameExists function. Calls the startGameEarly function. Requirements: The game with gameId must exist.*","title":"public function startGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-onerc1155received","text":"function onERC1155Received(address operator, address, uint256, uint256, bytes) public view returns (bytes4)","title":"public function onERC1155Received"},{"location":"contracts/facets/RankifyInstanceMainFacet/#external-function-onerc1155batchreceived","text":"function onERC1155BatchReceived(address operator, address, uint256[], uint256[], bytes) external view returns (bytes4)","title":"external function onERC1155BatchReceived"},{"location":"contracts/facets/RankifyInstanceMainFacet/#external-function-onerc721received","text":"function onERC721Received(address operator, address, uint256, bytes) external view returns (bytes4)","title":"external function onERC721Received"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getcontractstate","text":"function getContractState() public view returns (struct IRankifyInstanceCommons.RInstanceState)","title":"public function getContractState"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getturn","text":"function getTurn(uint256 gameId) public view returns (uint256)","title":"public function getTurn"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getgm","text":"function getGM(uint256 gameId) public view returns (address)","title":"public function getGM"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getscores","text":"function getScores(uint256 gameId) public view returns (address[], uint256[])","title":"public function getScores"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-isovertime","text":"function isOvertime(uint256 gameId) public view returns (bool)","title":"public function isOvertime"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-isgameover","text":"function isGameOver(uint256 gameId) public view returns (bool)","title":"public function isGameOver"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getplayersgame","text":"function getPlayersGame(address player) public view returns (uint256)","title":"public function getPlayersGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-islastturn","text":"function isLastTurn(uint256 gameId) public view returns (bool)","title":"public function isLastTurn"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-isregistrationopen","text":"function isRegistrationOpen(uint256 gameId) public view returns (bool)","title":"public function isRegistrationOpen"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-gamecreator","text":"function gameCreator(uint256 gameId) public view returns (address)","title":"public function gameCreator"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getgamerank","text":"function getGameRank(uint256 gameId) public view returns (uint256)","title":"public function getGameRank"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getplayers","text":"function getPlayers(uint256 gameId) public view returns (address[])","title":"public function getPlayers"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-canstartgame","text":"function canStartGame(uint256 gameId) public view returns (bool)","title":"public function canStartGame"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-canendturn","text":"function canEndTurn(uint256 gameId) public view returns (bool)","title":"public function canEndTurn"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-isplayerturncomplete","text":"function isPlayerTurnComplete(uint256 gameId, address player) public view returns (bool)","title":"public function isPlayerTurnComplete"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getplayervotedarray","text":"function getPlayerVotedArray(uint256 gameId) public view returns (bool[])","title":"public function getPlayerVotedArray"},{"location":"contracts/facets/RankifyInstanceMainFacet/#public-function-getplayersmoved","text":"function getPlayersMoved(uint256 gameId) public view returns (bool[], uint256)","title":"public function getPlayersMoved"},{"location":"contracts/facets/RankifyInstanceRequirementsFacet/","text":"# Description # Implementation # event RequirementsConfigured # event RequirementsConfigured(uint256 gameId, struct LibCoinVending.ConfigPosition config) public function setJoinRequirements # function setJoinRequirements(uint256 gameId, struct LibCoinVending.ConfigPosition config) public Input Type Description gameId uint256 The ID of the game. config struct LibCoinVending.ConfigPosition The configuration position for the join requirements. Sets the join requirements for a specific game. Only the game creator can call this function. The game must be in the pre-registration stage. public function getJoinRequirements # function getJoinRequirements(uint256 gameId) public view returns (struct LibCoinVending.ConditionReturn) Input Type Description gameId uint256 The ID of the game. Output 0 struct LibCoinVending.ConditionReturn The join requirements as a LibCoinVending.ConditionReturn struct. Retrieves the join requirements for a specific game. public function getJoinRequirementsByToken # function getJoinRequirementsByToken(uint256 gameId, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) public view returns (struct LibCoinVending.ContractCondition) Input Type Description gameId uint256 The ID of the game. contractAddress address The address of the contract. contractId uint256 The ID of the contract. contractType enum LibCoinVending.ContractTypes The type of the contract. Output 0 struct LibCoinVending.ContractCondition The join requirements for the specified token. Retrieves the join requirements for a specific token in a game.","title":"RankifyInstanceRequirementsFacet"},{"location":"contracts/facets/RankifyInstanceRequirementsFacet/#_1","text":"","title":""},{"location":"contracts/facets/RankifyInstanceRequirementsFacet/#description","text":"","title":"Description"},{"location":"contracts/facets/RankifyInstanceRequirementsFacet/#implementation","text":"","title":"Implementation"},{"location":"contracts/facets/RankifyInstanceRequirementsFacet/#event-requirementsconfigured","text":"event RequirementsConfigured(uint256 gameId, struct LibCoinVending.ConfigPosition config)","title":"event RequirementsConfigured"},{"location":"contracts/facets/RankifyInstanceRequirementsFacet/#public-function-setjoinrequirements","text":"function setJoinRequirements(uint256 gameId, struct LibCoinVending.ConfigPosition config) public Input Type Description gameId uint256 The ID of the game. config struct LibCoinVending.ConfigPosition The configuration position for the join requirements. Sets the join requirements for a specific game. Only the game creator can call this function. The game must be in the pre-registration stage.","title":"public function setJoinRequirements"},{"location":"contracts/facets/RankifyInstanceRequirementsFacet/#public-function-getjoinrequirements","text":"function getJoinRequirements(uint256 gameId) public view returns (struct LibCoinVending.ConditionReturn) Input Type Description gameId uint256 The ID of the game. Output 0 struct LibCoinVending.ConditionReturn The join requirements as a LibCoinVending.ConditionReturn struct. Retrieves the join requirements for a specific game.","title":"public function getJoinRequirements"},{"location":"contracts/facets/RankifyInstanceRequirementsFacet/#public-function-getjoinrequirementsbytoken","text":"function getJoinRequirementsByToken(uint256 gameId, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) public view returns (struct LibCoinVending.ContractCondition) Input Type Description gameId uint256 The ID of the game. contractAddress address The address of the contract. contractId uint256 The ID of the contract. contractType enum LibCoinVending.ContractTypes The type of the contract. Output 0 struct LibCoinVending.ContractCondition The join requirements for the specified token. Retrieves the join requirements for a specific token in a game.","title":"public function getJoinRequirementsByToken"},{"location":"contracts/interfaces/IERC1155Receiver/","text":"ERC1155 transfer receiver interface # Description # Implementation # external function onERC1155Received # validate receipt of ERC1155 transfer function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes data) external returns (bytes4) Input Type Description operator address executor of transfer from address sender of tokens id uint256 token ID received value uint256 quantity of tokens received data bytes data payload Output 0 bytes4 function's own selector if transfer is accepted external function onERC1155BatchReceived # validate receipt of ERC1155 batch transfer function onERC1155BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data) external returns (bytes4) Input Type Description operator address executor of transfer from address sender of tokens ids uint256[] token IDs received values uint256[] quantities of tokens received data bytes data payload Output 0 bytes4 function's own selector if transfer is accepted","title":"ERC1155 transfer receiver interface"},{"location":"contracts/interfaces/IERC1155Receiver/#erc1155-transfer-receiver-interface","text":"","title":"ERC1155 transfer receiver interface"},{"location":"contracts/interfaces/IERC1155Receiver/#description","text":"","title":"Description"},{"location":"contracts/interfaces/IERC1155Receiver/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IERC1155Receiver/#external-function-onerc1155received","text":"validate receipt of ERC1155 transfer function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes data) external returns (bytes4) Input Type Description operator address executor of transfer from address sender of tokens id uint256 token ID received value uint256 quantity of tokens received data bytes data payload Output 0 bytes4 function's own selector if transfer is accepted","title":"external function onERC1155Received"},{"location":"contracts/interfaces/IERC1155Receiver/#external-function-onerc1155batchreceived","text":"validate receipt of ERC1155 batch transfer function onERC1155BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data) external returns (bytes4) Input Type Description operator address executor of transfer from address sender of tokens ids uint256[] token IDs received values uint256[] quantities of tokens received data bytes data payload Output 0 bytes4 function's own selector if transfer is accepted","title":"external function onERC1155BatchReceived"},{"location":"contracts/interfaces/ILockableERC1155/","text":"ILockableERC1155 # Description # Interface for a lockable ERC1155 token contract. Implementation # event TokensLocked # event TokensLocked(address account, uint256 id, uint256 value) event TokensUnlocked # event TokensUnlocked(address account, uint256 id, uint256 value) external function lock # function lock(address account, uint256 id, uint256 amount) external *Locks a specified amount of tokens for a given account and token ID. account is the address of the account to lock the tokens for. id is the ID of the token to lock. amount is the amount of tokens to lock. emits a TokensLocked event.* external function unlock # function unlock(address account, uint256 id, uint256 amount) external *Unlocks a specified amount of tokens for a given account and token ID. account is the address of the account to unlock the tokens for. id is the ID of the token to unlock. amount is the amount of tokens to unlock. emits a TokensUnlocked event.* external function unlockedBalanceOf # function unlockedBalanceOf(address account, uint256 id) external view returns (uint256) *Returns the unlocked balance of tokens for a given account and token ID. account is the address of the account to check the unlocked balance for. id is the ID of the token to check the unlocked balance for. Returns: The unlocked balance of tokens.*","title":"ILockableERC1155"},{"location":"contracts/interfaces/ILockableERC1155/#ilockableerc1155","text":"","title":"ILockableERC1155"},{"location":"contracts/interfaces/ILockableERC1155/#description","text":"Interface for a lockable ERC1155 token contract.","title":"Description"},{"location":"contracts/interfaces/ILockableERC1155/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/ILockableERC1155/#event-tokenslocked","text":"event TokensLocked(address account, uint256 id, uint256 value)","title":"event TokensLocked"},{"location":"contracts/interfaces/ILockableERC1155/#event-tokensunlocked","text":"event TokensUnlocked(address account, uint256 id, uint256 value)","title":"event TokensUnlocked"},{"location":"contracts/interfaces/ILockableERC1155/#external-function-lock","text":"function lock(address account, uint256 id, uint256 amount) external *Locks a specified amount of tokens for a given account and token ID. account is the address of the account to lock the tokens for. id is the ID of the token to lock. amount is the amount of tokens to lock. emits a TokensLocked event.*","title":"external function lock"},{"location":"contracts/interfaces/ILockableERC1155/#external-function-unlock","text":"function unlock(address account, uint256 id, uint256 amount) external *Unlocks a specified amount of tokens for a given account and token ID. account is the address of the account to unlock the tokens for. id is the ID of the token to unlock. amount is the amount of tokens to unlock. emits a TokensUnlocked event.*","title":"external function unlock"},{"location":"contracts/interfaces/ILockableERC1155/#external-function-unlockedbalanceof","text":"function unlockedBalanceOf(address account, uint256 id) external view returns (uint256) *Returns the unlocked balance of tokens for a given account and token ID. account is the address of the account to check the unlocked balance for. id is the ID of the token to check the unlocked balance for. Returns: The unlocked balance of tokens.*","title":"external function unlockedBalanceOf"},{"location":"contracts/interfaces/IManagedAssetFactory/","text":"# Description # Implementation # external function deployAsset # function deployAsset(bytes32 assetUri, bytes32 assetType, bytes instantiationPayload) external payable returns (address) external function deployAssetManager # function deployAssetManager(address sAddr, bytes32 strategyId, bytes instantiationPayload) external payable returns (address) external function isAssetManager # function isAssetManager(address maybeManager) external view returns (bool) external function isManagedAsset # function isManagedAsset(address maybeAsset) external view returns (bool) external function getAsset # function getAsset(address manager) external view returns (address) external function getAssetType # function getAssetType(address asset) external view returns (bytes32) external function getAssetUri # function getAssetUri(address asset) external view returns (bytes32) event AssetDeployed # event AssetDeployed(address asset, bytes32 assetUri, bytes32 assetType) event AssetManagerDeployed # event AssetManagerDeployed(address asset, address manager, bytes32 strategyId)","title":"IManagedAssetFactory"},{"location":"contracts/interfaces/IManagedAssetFactory/#_1","text":"","title":""},{"location":"contracts/interfaces/IManagedAssetFactory/#description","text":"","title":"Description"},{"location":"contracts/interfaces/IManagedAssetFactory/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IManagedAssetFactory/#external-function-deployasset","text":"function deployAsset(bytes32 assetUri, bytes32 assetType, bytes instantiationPayload) external payable returns (address)","title":"external function deployAsset"},{"location":"contracts/interfaces/IManagedAssetFactory/#external-function-deployassetmanager","text":"function deployAssetManager(address sAddr, bytes32 strategyId, bytes instantiationPayload) external payable returns (address)","title":"external function deployAssetManager"},{"location":"contracts/interfaces/IManagedAssetFactory/#external-function-isassetmanager","text":"function isAssetManager(address maybeManager) external view returns (bool)","title":"external function isAssetManager"},{"location":"contracts/interfaces/IManagedAssetFactory/#external-function-ismanagedasset","text":"function isManagedAsset(address maybeAsset) external view returns (bool)","title":"external function isManagedAsset"},{"location":"contracts/interfaces/IManagedAssetFactory/#external-function-getasset","text":"function getAsset(address manager) external view returns (address)","title":"external function getAsset"},{"location":"contracts/interfaces/IManagedAssetFactory/#external-function-getassettype","text":"function getAssetType(address asset) external view returns (bytes32)","title":"external function getAssetType"},{"location":"contracts/interfaces/IManagedAssetFactory/#external-function-getasseturi","text":"function getAssetUri(address asset) external view returns (bytes32)","title":"external function getAssetUri"},{"location":"contracts/interfaces/IManagedAssetFactory/#event-assetdeployed","text":"event AssetDeployed(address asset, bytes32 assetUri, bytes32 assetType)","title":"event AssetDeployed"},{"location":"contracts/interfaces/IManagedAssetFactory/#event-assetmanagerdeployed","text":"event AssetManagerDeployed(address asset, address manager, bytes32 strategyId)","title":"event AssetManagerDeployed"},{"location":"contracts/interfaces/IMultipass/","text":"# Description # Implementation # external function resolveRecord # function resolveRecord(struct LibMultipass.NameQuery query) external view returns (bool, struct LibMultipass.Record) external function initializeDomain # function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) external *Initializes new LibMultipass.Domain and configures it's parameters Requirements: registrar is not zero domainName is not empty domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names domainName does not exist yet onlyOwner referrerReward+referralDiscount cannot be larger than fee @param registrar address of registrar @param freeRegistrationsNumber number of registrations free of fee @param fee fee in base currency of network @param domainName name of LibMultipass.Domain @param referrerReward referral fee share in base currency of network @param referralDiscount referral discount in base currency of network Emits an {InitializedDomain} event.* external function activateDomain # function activateDomain(bytes32 domainName) external *Activates LibMultipass.Domain name Requirements: msg.sender is Owner Emits an {DomainActivated} event.* external function deactivateDomain # function deactivateDomain(bytes32 domainName) external *Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements: msg.sender is Owner OR registrar Emits an {DomainDeactivated} event.* external function changeFee # function changeFee(bytes32 domainName, uint256 fee) external *Changes registrar address Requirements: msg.sender is Owner Emits an {DomainFeeChanged} event.* external function changeRegistrar # function changeRegistrar(bytes32 domainName, address newRegistrar) external *Changes registrar address Requirements: msg.sender is Owner Emits an {RegistrarChangeRequested} event.* external function deleteName # function deleteName(struct LibMultipass.NameQuery query) external *deletes name Requirements: msg.sender is Owner Emits an {DomainTTLChangeRequested} event.* external function changeReferralProgram # function changeReferralProgram(uint256 referrerFeeShare, uint256 referralDiscount, uint256 freeRegistrations, bytes32 domainName) external *executes all pending changes to LibMultipass.Domain that fulfill TTL Requirements: domainName must be set referrerFeeShare+referralDiscount cannot be larger than 2^32 Emits an {ReferralProgramChangeRequested} event.* external function register # function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) external payable *registers new name under LibMultipass.Domain Requirements: all arguments must be set domainName must be active resolveRecord for given arguments should return no LibMultipass.Record Emits an {registered} event.* external function modifyUserName # function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) external payable Input Type Description domainName bytes32 LibMultipass.Domain query struct LibMultipass.NameQuery newName bytes32 new name Emits an {Modified} event. registrarSignature bytes signatureDeadline uint256 *modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain* external function getBalance # function getBalance() external view returns (uint256) returns balance of this contract external function getDomainState # function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain) Input Type Description domainName bytes32 name of the LibMultipass.Domain Output 0 struct LibMultipass.Domain (name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize) returns LibMultipass.Domain state variables external function getContractState # function getContractState() external view returns (uint256) Output Type Description 0 uint256 (s_numDomains) returns contract state variables external function withrawFunds # function withrawFunds(address to) external *Withraws funds stored in smart contract Requirements: onlyOwner Emits an {fundsWithdawn} event.* external function getModifyPrice # function getModifyPrice(struct LibMultipass.NameQuery query) external view returns (uint256) event fundsWithdawn # event fundsWithdawn(uint256 amount, address account) event InitializedDomain # event InitializedDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) event DomainActivated # event DomainActivated(bytes32 domainName) event DomainDeactivated # event DomainDeactivated(bytes32 domainName) event DomainFeeChanged # event DomainFeeChanged(bytes32 domainName, uint256 newFee) event FreeRegistrationsChanged # event FreeRegistrationsChanged(uint256 domainIndex, uint256 newAmount) event RegistrarChangeRequested # event RegistrarChangeRequested(bytes32 domainName, address registrar) event DomainNameChangeRequested # event DomainNameChangeRequested(uint256 domainIndex, bytes32 NewDomainName) event nameDeleted # event nameDeleted(bytes32 domainName, address wallet, bytes32 id, bytes32 name) event DomainTTLChangeRequested # event DomainTTLChangeRequested(bytes32 domainName, uint256 amount) event ReferralProgramChanged # event ReferralProgramChanged(bytes32 domainName, uint256 reward, uint256 discount, uint256 freeNumber) event DomainChangesAreLive # event DomainChangesAreLive(bytes32 domainName, bytes32[] changes) event changesQeueCanceled # event changesQeueCanceled(bytes32 domainName, bytes32[] changes) event Registered # event Registered(bytes32 domainName, struct LibMultipass.Record NewRecord) event Referred # event Referred(struct LibMultipass.Record refferrer, struct LibMultipass.Record newRecord, bytes32 domainName) event UserRecordModified # event UserRecordModified(struct LibMultipass.Record newRecord, bytes32 oldName, bytes32 domainName)","title":"IMultipass"},{"location":"contracts/interfaces/IMultipass/#_1","text":"","title":""},{"location":"contracts/interfaces/IMultipass/#description","text":"","title":"Description"},{"location":"contracts/interfaces/IMultipass/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IMultipass/#external-function-resolverecord","text":"function resolveRecord(struct LibMultipass.NameQuery query) external view returns (bool, struct LibMultipass.Record)","title":"external function resolveRecord"},{"location":"contracts/interfaces/IMultipass/#external-function-initializedomain","text":"function initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) external *Initializes new LibMultipass.Domain and configures it's parameters Requirements: registrar is not zero domainName is not empty domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names domainName does not exist yet onlyOwner referrerReward+referralDiscount cannot be larger than fee @param registrar address of registrar @param freeRegistrationsNumber number of registrations free of fee @param fee fee in base currency of network @param domainName name of LibMultipass.Domain @param referrerReward referral fee share in base currency of network @param referralDiscount referral discount in base currency of network Emits an {InitializedDomain} event.*","title":"external function initializeDomain"},{"location":"contracts/interfaces/IMultipass/#external-function-activatedomain","text":"function activateDomain(bytes32 domainName) external *Activates LibMultipass.Domain name Requirements: msg.sender is Owner Emits an {DomainActivated} event.*","title":"external function activateDomain"},{"location":"contracts/interfaces/IMultipass/#external-function-deactivatedomain","text":"function deactivateDomain(bytes32 domainName) external *Deactivates LibMultipass.Domain name Deactivated LibMultipass.Domain cannot mutate names and will return zeros Requirements: msg.sender is Owner OR registrar Emits an {DomainDeactivated} event.*","title":"external function deactivateDomain"},{"location":"contracts/interfaces/IMultipass/#external-function-changefee","text":"function changeFee(bytes32 domainName, uint256 fee) external *Changes registrar address Requirements: msg.sender is Owner Emits an {DomainFeeChanged} event.*","title":"external function changeFee"},{"location":"contracts/interfaces/IMultipass/#external-function-changeregistrar","text":"function changeRegistrar(bytes32 domainName, address newRegistrar) external *Changes registrar address Requirements: msg.sender is Owner Emits an {RegistrarChangeRequested} event.*","title":"external function changeRegistrar"},{"location":"contracts/interfaces/IMultipass/#external-function-deletename","text":"function deleteName(struct LibMultipass.NameQuery query) external *deletes name Requirements: msg.sender is Owner Emits an {DomainTTLChangeRequested} event.*","title":"external function deleteName"},{"location":"contracts/interfaces/IMultipass/#external-function-changereferralprogram","text":"function changeReferralProgram(uint256 referrerFeeShare, uint256 referralDiscount, uint256 freeRegistrations, bytes32 domainName) external *executes all pending changes to LibMultipass.Domain that fulfill TTL Requirements: domainName must be set referrerFeeShare+referralDiscount cannot be larger than 2^32 Emits an {ReferralProgramChangeRequested} event.*","title":"external function changeReferralProgram"},{"location":"contracts/interfaces/IMultipass/#external-function-register","text":"function register(struct LibMultipass.Record newRecord, bytes32 domainName, bytes registrarSignature, uint256 signatureDeadline, struct LibMultipass.NameQuery referrer, bytes referralCode) external payable *registers new name under LibMultipass.Domain Requirements: all arguments must be set domainName must be active resolveRecord for given arguments should return no LibMultipass.Record Emits an {registered} event.*","title":"external function register"},{"location":"contracts/interfaces/IMultipass/#external-function-modifyusername","text":"function modifyUserName(bytes32 domainName, struct LibMultipass.NameQuery query, bytes32 newName, bytes registrarSignature, uint256 signatureDeadline) external payable Input Type Description domainName bytes32 LibMultipass.Domain query struct LibMultipass.NameQuery newName bytes32 new name Emits an {Modified} event. registrarSignature bytes signatureDeadline uint256 *modifies exsisting LibMultipass.Record Requirements: resolveRecord for given arguments should return valid LibMultipass.Record LibMultipass.Domain must be active newAddress and newName should be set and be unique in current LibMultipass.Domain*","title":"external function modifyUserName"},{"location":"contracts/interfaces/IMultipass/#external-function-getbalance","text":"function getBalance() external view returns (uint256) returns balance of this contract","title":"external function getBalance"},{"location":"contracts/interfaces/IMultipass/#external-function-getdomainstate","text":"function getDomainState(bytes32 domainName) external view returns (struct LibMultipass.Domain) Input Type Description domainName bytes32 name of the LibMultipass.Domain Output 0 struct LibMultipass.Domain (name, fee, freeRegistrationsNumber, referrerReward, referralDiscount, isActive, registrar, ttl, registerSize) returns LibMultipass.Domain state variables","title":"external function getDomainState"},{"location":"contracts/interfaces/IMultipass/#external-function-getcontractstate","text":"function getContractState() external view returns (uint256) Output Type Description 0 uint256 (s_numDomains) returns contract state variables","title":"external function getContractState"},{"location":"contracts/interfaces/IMultipass/#external-function-withrawfunds","text":"function withrawFunds(address to) external *Withraws funds stored in smart contract Requirements: onlyOwner Emits an {fundsWithdawn} event.*","title":"external function withrawFunds"},{"location":"contracts/interfaces/IMultipass/#external-function-getmodifyprice","text":"function getModifyPrice(struct LibMultipass.NameQuery query) external view returns (uint256)","title":"external function getModifyPrice"},{"location":"contracts/interfaces/IMultipass/#event-fundswithdawn","text":"event fundsWithdawn(uint256 amount, address account)","title":"event fundsWithdawn"},{"location":"contracts/interfaces/IMultipass/#event-initializeddomain","text":"event InitializedDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount)","title":"event InitializedDomain"},{"location":"contracts/interfaces/IMultipass/#event-domainactivated","text":"event DomainActivated(bytes32 domainName)","title":"event DomainActivated"},{"location":"contracts/interfaces/IMultipass/#event-domaindeactivated","text":"event DomainDeactivated(bytes32 domainName)","title":"event DomainDeactivated"},{"location":"contracts/interfaces/IMultipass/#event-domainfeechanged","text":"event DomainFeeChanged(bytes32 domainName, uint256 newFee)","title":"event DomainFeeChanged"},{"location":"contracts/interfaces/IMultipass/#event-freeregistrationschanged","text":"event FreeRegistrationsChanged(uint256 domainIndex, uint256 newAmount)","title":"event FreeRegistrationsChanged"},{"location":"contracts/interfaces/IMultipass/#event-registrarchangerequested","text":"event RegistrarChangeRequested(bytes32 domainName, address registrar)","title":"event RegistrarChangeRequested"},{"location":"contracts/interfaces/IMultipass/#event-domainnamechangerequested","text":"event DomainNameChangeRequested(uint256 domainIndex, bytes32 NewDomainName)","title":"event DomainNameChangeRequested"},{"location":"contracts/interfaces/IMultipass/#event-namedeleted","text":"event nameDeleted(bytes32 domainName, address wallet, bytes32 id, bytes32 name)","title":"event nameDeleted"},{"location":"contracts/interfaces/IMultipass/#event-domainttlchangerequested","text":"event DomainTTLChangeRequested(bytes32 domainName, uint256 amount)","title":"event DomainTTLChangeRequested"},{"location":"contracts/interfaces/IMultipass/#event-referralprogramchanged","text":"event ReferralProgramChanged(bytes32 domainName, uint256 reward, uint256 discount, uint256 freeNumber)","title":"event ReferralProgramChanged"},{"location":"contracts/interfaces/IMultipass/#event-domainchangesarelive","text":"event DomainChangesAreLive(bytes32 domainName, bytes32[] changes)","title":"event DomainChangesAreLive"},{"location":"contracts/interfaces/IMultipass/#event-changesqeuecanceled","text":"event changesQeueCanceled(bytes32 domainName, bytes32[] changes)","title":"event changesQeueCanceled"},{"location":"contracts/interfaces/IMultipass/#event-registered","text":"event Registered(bytes32 domainName, struct LibMultipass.Record NewRecord)","title":"event Registered"},{"location":"contracts/interfaces/IMultipass/#event-referred","text":"event Referred(struct LibMultipass.Record refferrer, struct LibMultipass.Record newRecord, bytes32 domainName)","title":"event Referred"},{"location":"contracts/interfaces/IMultipass/#event-userrecordmodified","text":"event UserRecordModified(struct LibMultipass.Record newRecord, bytes32 oldName, bytes32 domainName)","title":"event UserRecordModified"},{"location":"contracts/interfaces/IRankToken/","text":"# Description # Implementation # event RankingInstanceUpdated # event RankingInstanceUpdated(address newRankingInstance) event LevelUp # event LevelUp(address account, uint256 id) external function mint # function mint(address to, uint256 amount, uint256 poolId, bytes data) external Mints a specified amount of tokens to an account. to is the address of the account to mint the tokens to. amount is the amount of tokens to mint. poolId is the ID of the pool. data is the additional data. external function batchMint # function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) external Mints specified amounts of tokens to an account. to is the address of the account to mint the tokens to. ids is the array of IDs of the tokens to mint. amounts is the array of amounts of tokens to mint. data is the additional data. external function levelUp # function levelUp(address to, uint256 id, bytes data) external *Levels up an account. to is the address of the account to level up. id is the ID of the token. data is the additional data. emits a LevelUp event.* external function updateRankingInstance # function updateRankingInstance(address newRankingInstance) external *Updates the ranking instance. newRankingInstance is the address of the new ranking instance. emits a RankingInstanceUpdated event.* external function getRankingInstance # function getRankingInstance() external view returns (address) *Gets the ranking instance which can emit new rank updates and mint rank tokens. Returns: The address of the ranking instance.* external function findNewRank # function findNewRank(address account, uint256 oldRank) external view returns (uint256) *Finds the new rank of an account. account is the address of the account. oldRank is the old rank of the account. It checks the balance of the account and returns the new rank that can be upgraded to. Returns: The new rank of the account.* external function getAccountRank # function getAccountRank(address account) external view returns (uint256) *Gets the rank of an account. account is the address of the account. Returns: The rank of the account.*","title":"IRankToken"},{"location":"contracts/interfaces/IRankToken/#_1","text":"","title":""},{"location":"contracts/interfaces/IRankToken/#description","text":"","title":"Description"},{"location":"contracts/interfaces/IRankToken/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IRankToken/#event-rankinginstanceupdated","text":"event RankingInstanceUpdated(address newRankingInstance)","title":"event RankingInstanceUpdated"},{"location":"contracts/interfaces/IRankToken/#event-levelup","text":"event LevelUp(address account, uint256 id)","title":"event LevelUp"},{"location":"contracts/interfaces/IRankToken/#external-function-mint","text":"function mint(address to, uint256 amount, uint256 poolId, bytes data) external Mints a specified amount of tokens to an account. to is the address of the account to mint the tokens to. amount is the amount of tokens to mint. poolId is the ID of the pool. data is the additional data.","title":"external function mint"},{"location":"contracts/interfaces/IRankToken/#external-function-batchmint","text":"function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) external Mints specified amounts of tokens to an account. to is the address of the account to mint the tokens to. ids is the array of IDs of the tokens to mint. amounts is the array of amounts of tokens to mint. data is the additional data.","title":"external function batchMint"},{"location":"contracts/interfaces/IRankToken/#external-function-levelup","text":"function levelUp(address to, uint256 id, bytes data) external *Levels up an account. to is the address of the account to level up. id is the ID of the token. data is the additional data. emits a LevelUp event.*","title":"external function levelUp"},{"location":"contracts/interfaces/IRankToken/#external-function-updaterankinginstance","text":"function updateRankingInstance(address newRankingInstance) external *Updates the ranking instance. newRankingInstance is the address of the new ranking instance. emits a RankingInstanceUpdated event.*","title":"external function updateRankingInstance"},{"location":"contracts/interfaces/IRankToken/#external-function-getrankinginstance","text":"function getRankingInstance() external view returns (address) *Gets the ranking instance which can emit new rank updates and mint rank tokens. Returns: The address of the ranking instance.*","title":"external function getRankingInstance"},{"location":"contracts/interfaces/IRankToken/#external-function-findnewrank","text":"function findNewRank(address account, uint256 oldRank) external view returns (uint256) *Finds the new rank of an account. account is the address of the account. oldRank is the old rank of the account. It checks the balance of the account and returns the new rank that can be upgraded to. Returns: The new rank of the account.*","title":"external function findNewRank"},{"location":"contracts/interfaces/IRankToken/#external-function-getaccountrank","text":"function getAccountRank(address account) external view returns (uint256) *Gets the rank of an account. account is the address of the account. Returns: The rank of the account.*","title":"external function getAccountRank"},{"location":"contracts/interfaces/IRankifyInstanceCommons/","text":"# Description # Implementation # public struct Score # struct Score { address participant; uint256 score; } public struct RInstanceSettings # struct RInstanceSettings { uint256 gamePrice; address gamePaymentToken; uint256 joinGamePrice; uint256 numGames; address rankTokenAddress; bool contractInitialized; struct LibQuadraticVoting.qVotingStruct voting; } public struct RInstanceState # struct RInstanceState { struct IRankifyInstanceCommons.RInstanceSettings BestOfState; struct LibTBG.GameSettings TBGSEttings; } public struct VoteHidden # struct VoteHidden { bytes32 hash; bytes proof; } public struct RInstance # struct RInstance { uint256 rank; address createdBy; mapping(uint256 => string) ongoingProposals; uint256 numOngoingProposals; uint256 numPrevProposals; mapping(address => bytes32) proposalCommitmentHashes; uint256 numCommitments; mapping(address => struct IRankifyInstanceCommons.VoteHidden) votesHidden; address[] additionalRanks; uint256 paymentsBalance; uint256 numVotesThisTurn; uint256 numVotesPrevTurn; mapping(address => bool) playerVoted; } event RegistrationOpen # event RegistrationOpen(uint256 gameid) event PlayerJoined # event PlayerJoined(uint256 gameId, address participant) event GameStarted # event GameStarted(uint256 gameId) event gameCreated # event gameCreated(uint256 gameId, address gm, address creator, uint256 rank) event GameClosed # event GameClosed(uint256 gameId) event PlayerLeft # event PlayerLeft(uint256 gameId, address player)","title":"IRankifyInstanceCommons"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#_1","text":"","title":""},{"location":"contracts/interfaces/IRankifyInstanceCommons/#description","text":"","title":"Description"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#public-struct-score","text":"struct Score { address participant; uint256 score; }","title":"public struct Score"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#public-struct-rinstancesettings","text":"struct RInstanceSettings { uint256 gamePrice; address gamePaymentToken; uint256 joinGamePrice; uint256 numGames; address rankTokenAddress; bool contractInitialized; struct LibQuadraticVoting.qVotingStruct voting; }","title":"public struct RInstanceSettings"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#public-struct-rinstancestate","text":"struct RInstanceState { struct IRankifyInstanceCommons.RInstanceSettings BestOfState; struct LibTBG.GameSettings TBGSEttings; }","title":"public struct RInstanceState"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#public-struct-votehidden","text":"struct VoteHidden { bytes32 hash; bytes proof; }","title":"public struct VoteHidden"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#public-struct-rinstance","text":"struct RInstance { uint256 rank; address createdBy; mapping(uint256 => string) ongoingProposals; uint256 numOngoingProposals; uint256 numPrevProposals; mapping(address => bytes32) proposalCommitmentHashes; uint256 numCommitments; mapping(address => struct IRankifyInstanceCommons.VoteHidden) votesHidden; address[] additionalRanks; uint256 paymentsBalance; uint256 numVotesThisTurn; uint256 numVotesPrevTurn; mapping(address => bool) playerVoted; }","title":"public struct RInstance"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#event-registrationopen","text":"event RegistrationOpen(uint256 gameid)","title":"event RegistrationOpen"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#event-playerjoined","text":"event PlayerJoined(uint256 gameId, address participant)","title":"event PlayerJoined"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#event-gamestarted","text":"event GameStarted(uint256 gameId)","title":"event GameStarted"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#event-gamecreated","text":"event gameCreated(uint256 gameId, address gm, address creator, uint256 rank)","title":"event gameCreated"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#event-gameclosed","text":"event GameClosed(uint256 gameId)","title":"event GameClosed"},{"location":"contracts/interfaces/IRankifyInstanceCommons/#event-playerleft","text":"event PlayerLeft(uint256 gameId, address player)","title":"event PlayerLeft"},{"location":"contracts/interfaces/IRepository/","text":"IRepository # Description # The interface required for a repository. This is a modified source from Aragon X, where interface names have been changed by generalising \"plugin\" in to source code address\". Implication of this is that this contract will not be aware of any setup code as opposed in original Aragon implementation which relied on having IPluginSetup requirements This means that it is thought to be consumed by a factory contract, that will act as \"Installer\" and use reposiories for solo purpose of code lookup. I think this is a good change as it makes the interface more generic and reusable for any kind of contract code, not just OSx specific. TBD - I think that major release versions should include migration contract and call signatures, but this would breaking interfaces reliant on \"Tag\" structure. Implementation # error VersionHashDoesNotExist # Thrown if a version does not exist. error VersionHashDoesNotExist(bytes32 versionHash) Input Type Description versionHash bytes32 The tag hash. error ReleaseZeroNotAllowed # Thrown if a release number is zero. error ReleaseZeroNotAllowed() error InvalidReleaseIncrement # Thrown if a release number is incremented by more than one. error InvalidReleaseIncrement(uint8 latestRelease, uint8 newRelease) Input Type Description latestRelease uint8 The latest release number. newRelease uint8 The new release number. error AlreadyInPreviousRelease # Thrown if the same contract exists already in a previous releases. error AlreadyInPreviousRelease(uint8 release, uint16 build, address source) Input Type Description release uint8 The release number of the already existing source. build uint16 The build number of the already existing source. source address The contract address. error EmptyReleaseMetadata # Thrown if the metadata URI is empty. error EmptyReleaseMetadata() error ReleaseDoesNotExist # Thrown if release does not exist. error ReleaseDoesNotExist() external function updateReleaseMetadata # Updates the metadata for release with content @fromHex(releaseMetadata) . function updateReleaseMetadata(uint8 release, bytes releaseMetadata) external Input Type Description release uint8 The release number. releaseMetadata bytes The release metadata URI. external function createVersion # Creates a new version as the latest build for an existing release number or the first build for a new release number for the provided source contract address and metadata. function createVersion(uint8 release, address source, bytes buildMetadata, bytes releaseMetadata) external Input Type Description release uint8 The release number. source address The address of the source code. buildMetadata bytes The build metadata URI. releaseMetadata bytes The release metadata URI. event VersionCreated # Emitted if the same source exists in previous releases. event VersionCreated(uint8 release, uint16 build, address source, bytes buildMetadata) Input Type Description release uint8 The release number. build uint16 The build number. source address The address of the source code. buildMetadata bytes The build metadata URI. event ReleaseMetadataUpdated # Emitted when a release's metadata was updated. event ReleaseMetadataUpdated(uint8 release, bytes releaseMetadata) Input Type Description release uint8 The release number. releaseMetadata bytes The release metadata URI. external function buildCount # Gets the total number of builds for a given release number. function buildCount(uint8 release) external view returns (uint256) Input Type Description release uint8 The release number. Output 0 uint256 The number of builds of this release. external function getVersion # Returns the version for a tag hash. function getVersion(bytes32 tagHash) external view returns (struct Version) Input Type Description tagHash bytes32 The tag hash. Output 0 struct Version The version associated with a tag hash. external function getVersion # Returns the version associated with a tag. function getVersion(struct Tag tag) external view returns (struct Version) Input Type Description tag struct Tag The version tag. Output 0 struct Version The version associated with the tag. external function getLatestVersion # Returns the latest version for a given source. function getLatestVersion(address source) external view returns (struct Version) Input Type Description source address The source address Output 0 struct Version The latest version associated with the source. external function getLatestVersion # Returns the latest version for a given release number. function getLatestVersion(uint8 release) external view returns (struct Version) Input Type Description release uint8 The release number. Output 0 struct Version The latest version of this release. external function latestRelease # Returns the latest version for a given release number. function latestRelease() external view returns (uint8) Output Type Description 0 uint8 The latest version of this repository.","title":"IRepository"},{"location":"contracts/interfaces/IRepository/#irepository","text":"","title":"IRepository"},{"location":"contracts/interfaces/IRepository/#description","text":"The interface required for a repository. This is a modified source from Aragon X, where interface names have been changed by generalising \"plugin\" in to source code address\". Implication of this is that this contract will not be aware of any setup code as opposed in original Aragon implementation which relied on having IPluginSetup requirements This means that it is thought to be consumed by a factory contract, that will act as \"Installer\" and use reposiories for solo purpose of code lookup. I think this is a good change as it makes the interface more generic and reusable for any kind of contract code, not just OSx specific. TBD - I think that major release versions should include migration contract and call signatures, but this would breaking interfaces reliant on \"Tag\" structure.","title":"Description"},{"location":"contracts/interfaces/IRepository/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IRepository/#error-versionhashdoesnotexist","text":"Thrown if a version does not exist. error VersionHashDoesNotExist(bytes32 versionHash) Input Type Description versionHash bytes32 The tag hash.","title":"error VersionHashDoesNotExist"},{"location":"contracts/interfaces/IRepository/#error-releasezeronotallowed","text":"Thrown if a release number is zero. error ReleaseZeroNotAllowed()","title":"error ReleaseZeroNotAllowed"},{"location":"contracts/interfaces/IRepository/#error-invalidreleaseincrement","text":"Thrown if a release number is incremented by more than one. error InvalidReleaseIncrement(uint8 latestRelease, uint8 newRelease) Input Type Description latestRelease uint8 The latest release number. newRelease uint8 The new release number.","title":"error InvalidReleaseIncrement"},{"location":"contracts/interfaces/IRepository/#error-alreadyinpreviousrelease","text":"Thrown if the same contract exists already in a previous releases. error AlreadyInPreviousRelease(uint8 release, uint16 build, address source) Input Type Description release uint8 The release number of the already existing source. build uint16 The build number of the already existing source. source address The contract address.","title":"error AlreadyInPreviousRelease"},{"location":"contracts/interfaces/IRepository/#error-emptyreleasemetadata","text":"Thrown if the metadata URI is empty. error EmptyReleaseMetadata()","title":"error EmptyReleaseMetadata"},{"location":"contracts/interfaces/IRepository/#error-releasedoesnotexist","text":"Thrown if release does not exist. error ReleaseDoesNotExist()","title":"error ReleaseDoesNotExist"},{"location":"contracts/interfaces/IRepository/#external-function-updatereleasemetadata","text":"Updates the metadata for release with content @fromHex(releaseMetadata) . function updateReleaseMetadata(uint8 release, bytes releaseMetadata) external Input Type Description release uint8 The release number. releaseMetadata bytes The release metadata URI.","title":"external function updateReleaseMetadata"},{"location":"contracts/interfaces/IRepository/#external-function-createversion","text":"Creates a new version as the latest build for an existing release number or the first build for a new release number for the provided source contract address and metadata. function createVersion(uint8 release, address source, bytes buildMetadata, bytes releaseMetadata) external Input Type Description release uint8 The release number. source address The address of the source code. buildMetadata bytes The build metadata URI. releaseMetadata bytes The release metadata URI.","title":"external function createVersion"},{"location":"contracts/interfaces/IRepository/#event-versioncreated","text":"Emitted if the same source exists in previous releases. event VersionCreated(uint8 release, uint16 build, address source, bytes buildMetadata) Input Type Description release uint8 The release number. build uint16 The build number. source address The address of the source code. buildMetadata bytes The build metadata URI.","title":"event VersionCreated"},{"location":"contracts/interfaces/IRepository/#event-releasemetadataupdated","text":"Emitted when a release's metadata was updated. event ReleaseMetadataUpdated(uint8 release, bytes releaseMetadata) Input Type Description release uint8 The release number. releaseMetadata bytes The release metadata URI.","title":"event ReleaseMetadataUpdated"},{"location":"contracts/interfaces/IRepository/#external-function-buildcount","text":"Gets the total number of builds for a given release number. function buildCount(uint8 release) external view returns (uint256) Input Type Description release uint8 The release number. Output 0 uint256 The number of builds of this release.","title":"external function buildCount"},{"location":"contracts/interfaces/IRepository/#external-function-getversion","text":"Returns the version for a tag hash. function getVersion(bytes32 tagHash) external view returns (struct Version) Input Type Description tagHash bytes32 The tag hash. Output 0 struct Version The version associated with a tag hash.","title":"external function getVersion"},{"location":"contracts/interfaces/IRepository/#external-function-getversion_1","text":"Returns the version associated with a tag. function getVersion(struct Tag tag) external view returns (struct Version) Input Type Description tag struct Tag The version tag. Output 0 struct Version The version associated with the tag.","title":"external function getVersion"},{"location":"contracts/interfaces/IRepository/#external-function-getlatestversion","text":"Returns the latest version for a given source. function getLatestVersion(address source) external view returns (struct Version) Input Type Description source address The source address Output 0 struct Version The latest version associated with the source.","title":"external function getLatestVersion"},{"location":"contracts/interfaces/IRepository/#external-function-getlatestversion_1","text":"Returns the latest version for a given release number. function getLatestVersion(uint8 release) external view returns (struct Version) Input Type Description release uint8 The release number. Output 0 struct Version The latest version of this release.","title":"external function getLatestVersion"},{"location":"contracts/interfaces/IRepository/#external-function-latestrelease","text":"Returns the latest version for a given release number. function latestRelease() external view returns (uint8) Output Type Description 0 uint8 The latest version of this repository.","title":"external function latestRelease"},{"location":"contracts/interfaces/IVInstaller/","text":"# enum VersionRequirementTypes # Enum defining the types of version requirements for repositories. - All: Matches any version. - MajorVersion: Matches any version with the same major version number. - ExactVersion: Matches the exact version specified. enum VersionRequirementTypes { All, MajorVersion, ExactVersion } # enum InstallationTypes # enum InstallationTypes { Cloneable, Constructable } # public struct VersionControl # Input Type Description Struct defining a version requirement for a repository. struct VersionControl { address source; struct Tag baseVersion; enum VersionRequirementTypes requirementType; } # public struct InstallationPlan # Input Type Description Struct defining the installation plan for a repository. struct InstallationPlan { struct VersionControl requiredSource; bytes4[] initializerFnSelectors; enum InstallationTypes installationType; } # public struct Envelope # struct Envelope { address destination; bytes[] data; } # Description # Implementation # error RepositoryIsNotAdded # error RepositoryIsNotAdded(contract IRepository repository) Error thrown when a repository is not added to the installer. error VersionDoesNotMatchRequirement # error VersionDoesNotMatchRequirement(address repository, struct Tag version, struct Tag requiredTag) Error thrown when the version does not match the requirement for a repository. event RepositoryRequirementUpdated # event RepositoryRequirementUpdated(contract IRepository repository, struct Tag oldTag, struct Tag newTag) Input Type Description repository contract IRepository The address of the repository. oldTag struct Tag The old version requirement for the repository. newTag struct Tag The new version requirement for the repository. Event emitted when the version requirement for a repository is updated. event RepositoryAdded # event RepositoryAdded(contract IRepository repository, address adder, struct VersionControl requirement, bytes32 metadata) Input Type Description repository contract IRepository The address of the repository. adder address The address of the account that added the repository. requirement struct VersionControl The version requirement for the repository. metadata bytes32 The metadata associated with the repository. Event emitted when a repository is added to the installer. event RepositoryRemoved # event RepositoryRemoved(contract IRepository repository) Input Type Description repository contract IRepository The address of the repository. Event emitted when a repository is removed from the installer. event Instantiated # event Instantiated(address newInstance, contract IRepository repository, address instantiator, struct Tag version, bytes metadata) Input Type Description newInstance address The address of the new instance. repository contract IRepository The address of the repository. instantiator address The address of the account that instantiated the instance. version struct Tag The version of the repository used for instantiation. metadata bytes The metadata associated with the instance. Event emitted when a new instance is instantiated from a repository. event UpgradedMinor # event UpgradedMinor(contract IRepository repository, uint16 oldMinor, uint16 newMinor, uint8 build, bytes metadata) Input Type Description repository contract IRepository The address of the repository. oldMinor uint16 The old minor version. newMinor uint16 The new minor version. build uint8 The build number. metadata bytes The metadata associated with the upgrade. Event emitted when source repository is upgraded to a new minor version. event UpgradedMajor # event UpgradedMajor(contract IRepository repository, uint8 oldMajor, uint8 newMajor, uint16 build, bytes metadata) Input Type Description repository contract IRepository The address of the repository. oldMajor uint8 The old major version. newMajor uint8 The new major version. build uint16 The build number. metadata bytes The metadata associated with the upgrade. Event emitted when source repository is upgraded to a new major version. external function addSource # function addSource(struct VersionControl versionedSource, struct InstallationPlan config, bytes32 metadata) external Input Type Description versionedSource struct VersionControl The version of the source repository. config struct InstallationPlan The configuration for the source repository. metadata bytes32 The metadata associated with the source repository. Adds new source repository to the installer. external function removeSource # function removeSource(contract IRepository repository) external Input Type Description repository contract IRepository The address of the repository. Removes a repository from the installer. external function installNewExact # function installNewExact(struct Envelope installationData, struct Tag version) external returns (address) Input Type Description installationData struct Envelope The payload for the installation. version struct Tag The version of the repository to install. Installs a new instance from the latest version of a repository. external function installNewLatest # function installNewLatest(struct Envelope installationData) external returns (address) Input Type Description installationData struct Envelope The payload for the installation. Installs a new instance from the latest version of a repository. external function upgradeSource # function upgradeSource(struct InstallationPlan newConfig, address migrationContract, bytes migrationData) external returns (address[] instances) Input Type Description newConfig struct InstallationPlan The new configuration for the source repository. migrationContract address The address of the migration contract. migrationData bytes The data for the migration contract. Upgrades versioned source new requirements. external function getInstances # function getInstances(contract IRepository repository) external view returns (address[]) Input Type Description repository contract IRepository The address of the repository. Output 0 address[] An array of addresses representing the instances. Gets all instances created by installer for a specific repository source external function getInstancesByVersion # function getInstancesByVersion(struct VersionControl sources) external view returns (address[]) Input Type Description sources struct VersionControl The version control for the repository. Output 0 address[] An array of addresses representing the instances. Gets all instances created by installer for a specific repository source external function getRepositories # function getRepositories() external view returns (address[]) Output Type Description 0 address[] An array of addresses representing the repositories. Gets all repositories added to the installer. external function getRepository # function getRepository(contract IRepository instance) external view returns (address) Input Type Description instance contract IRepository The address of the instance. Output 0 address The address of the repository. Gets the repository associated with a specific instance. external function getVersion # function getVersion(address instance) external view returns (struct Tag) Input Type Description instance address The address of the instance. Output 0 struct Tag The version of the instance. Gets the version of a specific instance. external function getVersionControl # function getVersionControl(address instance) external view returns (struct VersionControl) Input Type Description instance address The address of the instance. Output 0 struct VersionControl The version requirement for the instance. Gets the version requirement for a specific instance. external function getInstallationPlan # function getInstallationPlan(contract IRepository repository) external view returns (struct InstallationPlan) Input Type Description repository contract IRepository The address of the repository. Output 0 struct InstallationPlan The installation plan for the repository. Gets the installation plan for a specific repository.","title":"IVInstaller"},{"location":"contracts/interfaces/IVInstaller/#_1","text":"","title":""},{"location":"contracts/interfaces/IVInstaller/#enum-versionrequirementtypes","text":"Enum defining the types of version requirements for repositories. - All: Matches any version. - MajorVersion: Matches any version with the same major version number. - ExactVersion: Matches the exact version specified. enum VersionRequirementTypes { All, MajorVersion, ExactVersion }","title":"enum VersionRequirementTypes"},{"location":"contracts/interfaces/IVInstaller/#_2","text":"","title":""},{"location":"contracts/interfaces/IVInstaller/#enum-installationtypes","text":"enum InstallationTypes { Cloneable, Constructable }","title":"enum InstallationTypes"},{"location":"contracts/interfaces/IVInstaller/#_3","text":"","title":""},{"location":"contracts/interfaces/IVInstaller/#public-struct-versioncontrol","text":"Input Type Description Struct defining a version requirement for a repository. struct VersionControl { address source; struct Tag baseVersion; enum VersionRequirementTypes requirementType; }","title":"public struct VersionControl"},{"location":"contracts/interfaces/IVInstaller/#_4","text":"","title":""},{"location":"contracts/interfaces/IVInstaller/#public-struct-installationplan","text":"Input Type Description Struct defining the installation plan for a repository. struct InstallationPlan { struct VersionControl requiredSource; bytes4[] initializerFnSelectors; enum InstallationTypes installationType; }","title":"public struct InstallationPlan"},{"location":"contracts/interfaces/IVInstaller/#_5","text":"","title":""},{"location":"contracts/interfaces/IVInstaller/#public-struct-envelope","text":"struct Envelope { address destination; bytes[] data; }","title":"public struct Envelope"},{"location":"contracts/interfaces/IVInstaller/#_6","text":"","title":""},{"location":"contracts/interfaces/IVInstaller/#description","text":"","title":"Description"},{"location":"contracts/interfaces/IVInstaller/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IVInstaller/#error-repositoryisnotadded","text":"error RepositoryIsNotAdded(contract IRepository repository) Error thrown when a repository is not added to the installer.","title":"error RepositoryIsNotAdded"},{"location":"contracts/interfaces/IVInstaller/#error-versiondoesnotmatchrequirement","text":"error VersionDoesNotMatchRequirement(address repository, struct Tag version, struct Tag requiredTag) Error thrown when the version does not match the requirement for a repository.","title":"error VersionDoesNotMatchRequirement"},{"location":"contracts/interfaces/IVInstaller/#event-repositoryrequirementupdated","text":"event RepositoryRequirementUpdated(contract IRepository repository, struct Tag oldTag, struct Tag newTag) Input Type Description repository contract IRepository The address of the repository. oldTag struct Tag The old version requirement for the repository. newTag struct Tag The new version requirement for the repository. Event emitted when the version requirement for a repository is updated.","title":"event RepositoryRequirementUpdated"},{"location":"contracts/interfaces/IVInstaller/#event-repositoryadded","text":"event RepositoryAdded(contract IRepository repository, address adder, struct VersionControl requirement, bytes32 metadata) Input Type Description repository contract IRepository The address of the repository. adder address The address of the account that added the repository. requirement struct VersionControl The version requirement for the repository. metadata bytes32 The metadata associated with the repository. Event emitted when a repository is added to the installer.","title":"event RepositoryAdded"},{"location":"contracts/interfaces/IVInstaller/#event-repositoryremoved","text":"event RepositoryRemoved(contract IRepository repository) Input Type Description repository contract IRepository The address of the repository. Event emitted when a repository is removed from the installer.","title":"event RepositoryRemoved"},{"location":"contracts/interfaces/IVInstaller/#event-instantiated","text":"event Instantiated(address newInstance, contract IRepository repository, address instantiator, struct Tag version, bytes metadata) Input Type Description newInstance address The address of the new instance. repository contract IRepository The address of the repository. instantiator address The address of the account that instantiated the instance. version struct Tag The version of the repository used for instantiation. metadata bytes The metadata associated with the instance. Event emitted when a new instance is instantiated from a repository.","title":"event Instantiated"},{"location":"contracts/interfaces/IVInstaller/#event-upgradedminor","text":"event UpgradedMinor(contract IRepository repository, uint16 oldMinor, uint16 newMinor, uint8 build, bytes metadata) Input Type Description repository contract IRepository The address of the repository. oldMinor uint16 The old minor version. newMinor uint16 The new minor version. build uint8 The build number. metadata bytes The metadata associated with the upgrade. Event emitted when source repository is upgraded to a new minor version.","title":"event UpgradedMinor"},{"location":"contracts/interfaces/IVInstaller/#event-upgradedmajor","text":"event UpgradedMajor(contract IRepository repository, uint8 oldMajor, uint8 newMajor, uint16 build, bytes metadata) Input Type Description repository contract IRepository The address of the repository. oldMajor uint8 The old major version. newMajor uint8 The new major version. build uint16 The build number. metadata bytes The metadata associated with the upgrade. Event emitted when source repository is upgraded to a new major version.","title":"event UpgradedMajor"},{"location":"contracts/interfaces/IVInstaller/#external-function-addsource","text":"function addSource(struct VersionControl versionedSource, struct InstallationPlan config, bytes32 metadata) external Input Type Description versionedSource struct VersionControl The version of the source repository. config struct InstallationPlan The configuration for the source repository. metadata bytes32 The metadata associated with the source repository. Adds new source repository to the installer.","title":"external function addSource"},{"location":"contracts/interfaces/IVInstaller/#external-function-removesource","text":"function removeSource(contract IRepository repository) external Input Type Description repository contract IRepository The address of the repository. Removes a repository from the installer.","title":"external function removeSource"},{"location":"contracts/interfaces/IVInstaller/#external-function-installnewexact","text":"function installNewExact(struct Envelope installationData, struct Tag version) external returns (address) Input Type Description installationData struct Envelope The payload for the installation. version struct Tag The version of the repository to install. Installs a new instance from the latest version of a repository.","title":"external function installNewExact"},{"location":"contracts/interfaces/IVInstaller/#external-function-installnewlatest","text":"function installNewLatest(struct Envelope installationData) external returns (address) Input Type Description installationData struct Envelope The payload for the installation. Installs a new instance from the latest version of a repository.","title":"external function installNewLatest"},{"location":"contracts/interfaces/IVInstaller/#external-function-upgradesource","text":"function upgradeSource(struct InstallationPlan newConfig, address migrationContract, bytes migrationData) external returns (address[] instances) Input Type Description newConfig struct InstallationPlan The new configuration for the source repository. migrationContract address The address of the migration contract. migrationData bytes The data for the migration contract. Upgrades versioned source new requirements.","title":"external function upgradeSource"},{"location":"contracts/interfaces/IVInstaller/#external-function-getinstances","text":"function getInstances(contract IRepository repository) external view returns (address[]) Input Type Description repository contract IRepository The address of the repository. Output 0 address[] An array of addresses representing the instances. Gets all instances created by installer for a specific repository source","title":"external function getInstances"},{"location":"contracts/interfaces/IVInstaller/#external-function-getinstancesbyversion","text":"function getInstancesByVersion(struct VersionControl sources) external view returns (address[]) Input Type Description sources struct VersionControl The version control for the repository. Output 0 address[] An array of addresses representing the instances. Gets all instances created by installer for a specific repository source","title":"external function getInstancesByVersion"},{"location":"contracts/interfaces/IVInstaller/#external-function-getrepositories","text":"function getRepositories() external view returns (address[]) Output Type Description 0 address[] An array of addresses representing the repositories. Gets all repositories added to the installer.","title":"external function getRepositories"},{"location":"contracts/interfaces/IVInstaller/#external-function-getrepository","text":"function getRepository(contract IRepository instance) external view returns (address) Input Type Description instance contract IRepository The address of the instance. Output 0 address The address of the repository. Gets the repository associated with a specific instance.","title":"external function getRepository"},{"location":"contracts/interfaces/IVInstaller/#external-function-getversion","text":"function getVersion(address instance) external view returns (struct Tag) Input Type Description instance address The address of the instance. Output 0 struct Tag The version of the instance. Gets the version of a specific instance.","title":"external function getVersion"},{"location":"contracts/interfaces/IVInstaller/#external-function-getversioncontrol","text":"function getVersionControl(address instance) external view returns (struct VersionControl) Input Type Description instance address The address of the instance. Output 0 struct VersionControl The version requirement for the instance. Gets the version requirement for a specific instance.","title":"external function getVersionControl"},{"location":"contracts/interfaces/IVInstaller/#external-function-getinstallationplan","text":"function getInstallationPlan(contract IRepository repository) external view returns (struct InstallationPlan) Input Type Description repository contract IRepository The address of the repository. Output 0 struct InstallationPlan The installation plan for the repository. Gets the installation plan for a specific repository.","title":"external function getInstallationPlan"},{"location":"contracts/interfaces/IVRegistry/","text":"# Description # Implementation # external function register # Registers a contract with a specific version. function register(address source, struct Version version) external Input Type Description source address The address of the contract to register. version struct Version The version of the contract. external function invalidate # Sets the contract address of specific version to zero. function invalidate(address source, bool invalidateMinors, struct Version version) external Input Type Description source address The address of the contract to register. invalidateMinors bool version struct Version The version of the contract. external function getVersion # function getVersion(struct Version version) external view returns (address) Input Type Description version struct Version The version of the contract. Checks if a given address is registered in the IVRegistry.","title":"IVRegistry"},{"location":"contracts/interfaces/IVRegistry/#_1","text":"","title":""},{"location":"contracts/interfaces/IVRegistry/#description","text":"","title":"Description"},{"location":"contracts/interfaces/IVRegistry/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IVRegistry/#external-function-register","text":"Registers a contract with a specific version. function register(address source, struct Version version) external Input Type Description source address The address of the contract to register. version struct Version The version of the contract.","title":"external function register"},{"location":"contracts/interfaces/IVRegistry/#external-function-invalidate","text":"Sets the contract address of specific version to zero. function invalidate(address source, bool invalidateMinors, struct Version version) external Input Type Description source address The address of the contract to register. invalidateMinors bool version struct Version The version of the contract.","title":"external function invalidate"},{"location":"contracts/interfaces/IVRegistry/#external-function-getversion","text":"function getVersion(struct Version version) external view returns (address) Input Type Description version struct Version The version of the contract. Checks if a given address is registered in the IVRegistry.","title":"external function getVersion"},{"location":"contracts/interfaces/IVRepoFactory/","text":"IVRepoFactory # Description # This Interface creates IRepository contract proxies and registers them on a IVersionBasedRegistry contract. This is a modified source from Aragon X, where interface names have been changed by generalising \"plugin\" in to source code address\". this implies that Repository anymore will not be aware of source code implementation and initialization selectors must be passed. Implementation # event RepoCreated # event RepoCreated(contract IRepository repo, address proxy) Input Type Description repo contract IRepository The address of the newly created repository. proxy address The address of the proxy contract associated with the repository. Emitted when a new repository is created. external function createRepo # Creates a repository proxy pointing to the implementation of IRepository function createRepo(string _subdomain, address _initialOwner) external returns (contract IRepository) Input Type Description _subdomain string The repository subdomain. _initialOwner address The maintainer address. external function createRepoWithFirstVersion # Creates and registers a Repository with an ENS subdomain and publishes an initial version 1.1 . function createRepoWithFirstVersion(string _subdomain, address _source, address _maintainer, bytes _releaseMetadata, bytes _buildMetadata) external returns (contract IRepository repository) Input Type Description _subdomain string The repository subdomain. _source address contract associated with the version. _maintainer address The maintainer of the repo. This address has permission to update metadata, upgrade the repo logic, and manage the repo permissions. _releaseMetadata bytes The release metadata URI. _buildMetadata bytes The build metadata URI. After the creation of the and release of the first version by the factory, ownership is transferred to the _maintainer address.","title":"IVRepoFactory"},{"location":"contracts/interfaces/IVRepoFactory/#ivrepofactory","text":"","title":"IVRepoFactory"},{"location":"contracts/interfaces/IVRepoFactory/#description","text":"This Interface creates IRepository contract proxies and registers them on a IVersionBasedRegistry contract. This is a modified source from Aragon X, where interface names have been changed by generalising \"plugin\" in to source code address\". this implies that Repository anymore will not be aware of source code implementation and initialization selectors must be passed.","title":"Description"},{"location":"contracts/interfaces/IVRepoFactory/#implementation","text":"","title":"Implementation"},{"location":"contracts/interfaces/IVRepoFactory/#event-repocreated","text":"event RepoCreated(contract IRepository repo, address proxy) Input Type Description repo contract IRepository The address of the newly created repository. proxy address The address of the proxy contract associated with the repository. Emitted when a new repository is created.","title":"event RepoCreated"},{"location":"contracts/interfaces/IVRepoFactory/#external-function-createrepo","text":"Creates a repository proxy pointing to the implementation of IRepository function createRepo(string _subdomain, address _initialOwner) external returns (contract IRepository) Input Type Description _subdomain string The repository subdomain. _initialOwner address The maintainer address.","title":"external function createRepo"},{"location":"contracts/interfaces/IVRepoFactory/#external-function-createrepowithfirstversion","text":"Creates and registers a Repository with an ENS subdomain and publishes an initial version 1.1 . function createRepoWithFirstVersion(string _subdomain, address _source, address _maintainer, bytes _releaseMetadata, bytes _buildMetadata) external returns (contract IRepository repository) Input Type Description _subdomain string The repository subdomain. _source address contract associated with the version. _maintainer address The maintainer of the repo. This address has permission to update metadata, upgrade the repo logic, and manage the repo permissions. _releaseMetadata bytes The release metadata URI. _buildMetadata bytes The build metadata URI. After the creation of the and release of the first version by the factory, ownership is transferred to the _maintainer address.","title":"external function createRepoWithFirstVersion"},{"location":"contracts/interfaces/IVTag/","text":"# public struct Tag # The struct describing the tag of a version obtained by a release and build number as RELEASE.BUILD . Input Type Description Releases mark incompatible changes (e.g., the plugin interface, storage layout, or incompatible behavior) whereas builds mark compatible changes (e.g., patches and compatible feature additions). struct Tag { uint8 release; uint16 build; } # public struct Version # The struct describing a plugin version (release and build). Input Type Description struct Version { struct Tag tag; address source; bytes buildMetadata; }","title":"IVTag"},{"location":"contracts/interfaces/IVTag/#_1","text":"","title":""},{"location":"contracts/interfaces/IVTag/#public-struct-tag","text":"The struct describing the tag of a version obtained by a release and build number as RELEASE.BUILD . Input Type Description Releases mark incompatible changes (e.g., the plugin interface, storage layout, or incompatible behavior) whereas builds mark compatible changes (e.g., patches and compatible feature additions). struct Tag { uint8 release; uint16 build; }","title":"public struct Tag"},{"location":"contracts/interfaces/IVTag/#_2","text":"","title":""},{"location":"contracts/interfaces/IVTag/#public-struct-version","text":"The struct describing a plugin version (release and build). Input Type Description struct Version { struct Tag tag; address source; bytes buildMetadata; }","title":"public struct Version"},{"location":"contracts/libraries/LibArray/","text":"# Description # Implementation # internal function quickSort # function quickSort(uint256[] arr, int256 left, int256 right) internal view *Sorts the elements of the array in ascending order using the quicksort algorithm. Requirements: The array to be sorted must not be empty. The starting and ending indices must be within the bounds of the array. Modifies: The array is sorted in ascending order. Note: This function uses the in-place quicksort algorithm, which has an average-case complexity of O(n log n) and a worst-case complexity of O(n^2).*","title":"LibArray"},{"location":"contracts/libraries/LibArray/#_1","text":"","title":""},{"location":"contracts/libraries/LibArray/#description","text":"","title":"Description"},{"location":"contracts/libraries/LibArray/#implementation","text":"","title":"Implementation"},{"location":"contracts/libraries/LibArray/#internal-function-quicksort","text":"function quickSort(uint256[] arr, int256 left, int256 right) internal view *Sorts the elements of the array in ascending order using the quicksort algorithm. Requirements: The array to be sorted must not be empty. The starting and ending indices must be within the bounds of the array. Modifies: The array is sorted in ascending order. Note: This function uses the in-place quicksort algorithm, which has an average-case complexity of O(n log n) and a worst-case complexity of O(n^2).*","title":"internal function quickSort"},{"location":"contracts/libraries/LibCoinVending/","text":"# Description # This library is used to simulate the vending machine coin acceptor state machine that: - Supports large number of positions; Each represents requirements to acess different goods of the virtual vending machine. - Accepts multiple assets of following types: Native (Eth), ERC20, ERC721, and ERC1155 tokens that can be stacked together. - Allows for each individual asset action promise can be one of following: - Lock: The asset is locked in the acceptor with promise that asset will be returned to the sender at release funds time. - Bet: The asset is locked in the acceptor with promise that asset will be awarded to benificiary at release funds time. - Pay: The asset is locked in the acceptor with promise that asset will be paid to payee at release funds time. - Burn: The asset is locked in the acceptor with promise that asset will be destroyed at release funds time. - Maintains each position balance, hence allowing multiple participants to line up for the same position. - Allows three actions: - Fund position with assets - Refund assets to user - Consume assets and provide goods to user - Consuming asset might take a form of - Transferring assets to payee - Burning assets - Awarding beneficiary with assets - Returning locked assets back to sender This library DOES enforces that any position can only be refunded or processed only within amount funded boundaries This library DOES NOT store the addresses of senders, nor benificiaries, nor payees. This is to be stored within implementation contract. !!!!! IMPORTANT !!!!! This library does NOT invocates reentrancy guards. It is implementation contract's responsibility to enforce reentrancy guards. Reentrancy guards MUST be implemented in an implementing contract. Usage: Configure position via configure(...) fund position with assets via fund(...) release or refund assets via release(...) or refund(...) repeat steps 1 and 2 as needed. Position can be recofigured at any time when it's effective balance is zero: timesFunded - timesRefuned - timesReleased = 0 Test state: This library most functionality has been tested: see ../tests/LibCoinVending.ts and ../tests/report.md for details. ERC721 token is checked only for \"HAVE\" condition since putting requirements on non fungable token id yet to be resolved. (see ERC721 section in the code below) This library has not been yet audited Implementation # public struct Condition # struct Condition { mapping(enum LibCoinVending.ContractTypes => mapping(address => mapping(uint256 => struct LibCoinVending.ContractCondition))) contracts; struct LibCoinVending.NumericCondition ethValues; uint256 timesRefunded; uint256 timesReleased; uint256 timesFunded; enum LibCoinVending.ContractTypes[] contractTypes; address[] contractAddresses; uint256[] contractIds; bool _isConfigured; } enum RequirementTypes # enum RequirementTypes { HAVE, LOCK, BURN, BET, PAY } public struct TransactionProperties # struct TransactionProperties { bytes data; uint256 amount; } public struct ContractCondition # struct ContractCondition { struct LibCoinVending.TransactionProperties have; struct LibCoinVending.TransactionProperties lock; struct LibCoinVending.TransactionProperties burn; struct LibCoinVending.TransactionProperties pay; struct LibCoinVending.TransactionProperties bet; } public struct NumericCondition # struct NumericCondition { uint256 have; uint256 lock; uint256 burn; uint256 pay; uint256 bet; } enum TransferTypes # enum TransferTypes { FUND, REFUND, RELEASE } public struct ConditionReturn # struct ConditionReturn { struct LibCoinVending.NumericCondition ethValues; uint256 timesRefunded; uint256 timesReleased; uint256 timesFunded; address[] contractAddresses; uint256[] contractIds; enum LibCoinVending.ContractTypes[] contractTypes; bool _isConfigured; } public struct configSmartRequirement # struct configSmartRequirement { address contractAddress; uint256 contractId; enum LibCoinVending.ContractTypes contractType; struct LibCoinVending.ContractCondition contractRequirement; } public struct ConfigPosition # struct ConfigPosition { struct LibCoinVending.NumericCondition ethValues; struct LibCoinVending.configSmartRequirement[] contracts; } public struct LibCoinVendingStorage # struct LibCoinVendingStorage { mapping(bytes32 => struct LibCoinVending.Condition) positions; address beneficiary; } enum ContractTypes # enum ContractTypes { ERC20, ERC1155, ERC721 } internal variable COIN_VENDING_STORAGE_POSITION # bytes32 COIN_VENDING_STORAGE_POSITION internal function coinVendingPosition # function coinVendingPosition(bytes32 position) internal view returns (struct LibCoinVending.Condition) internal function coinVendingStorage # function coinVendingStorage() internal pure returns (struct LibCoinVending.LibCoinVendingStorage es) internal function refund # function refund(bytes32 position, address to) internal *Returns all position requirements back to fundee. position is the identifier of the condition. to is the address to refund the balance to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the to address. Increments the timesRefunded counter for the condition.* internal function batchRefund # function batchRefund(bytes32 position, address[] returnAddresses) internal *Returns all position requirements back to multiple fundees. position is the identifier of the condition. returnAddresses is an array of addresses to refund the balance to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to each address in returnAddresses . Increments the timesRefunded counter for the condition for each address in returnAddresses .* internal function release # function release(bytes32 position, address payee, address beneficiary, address returnAddress) internal *Releases the funds from a coin vending position to the specified addresses. position is the identifier of the condition. payee , beneficiary , and returnAddress are the addresses to release the funds to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the payee , beneficiary , and returnAddress . Increments the timesReleased counter for the condition.* internal function batchRelease # function batchRelease(bytes32 position, address payee, address beneficiary, address[] returnAddresses) internal *Releases the funds from a coin vending position to multiple return addresses. position is the identifier of the condition. payee , beneficiary , and returnAddresses are the addresses to release the funds to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the payee , beneficiary , and each address in returnAddresses . Increments the timesReleased counter for the condition for each address in returnAddresses .* internal function fund # function fund(bytes32 position) internal *Funds the position by msg.sender . position is the identifier of the condition. Requirements: The condition must be configured. Modifies: Transfers the funds from msg.sender to this contract. Increments the timesFunded counter for the condition.* internal function configure # function configure(bytes32 position, struct LibCoinVending.ConfigPosition configuration) internal *Configures the position. position is the identifier of the condition. configuration is the new configuration for the condition. Requirements: The condition must not have a positive balance. Modifies: Sets the configuration of the condition to configuration .* internal function getPosition # function getPosition(bytes32 position) internal view returns (struct LibCoinVending.ConditionReturn) *Returns the condition associated with the given position. position is the identifier of the condition. Returns: The condition associated with position .* internal function getPositionByContract # function getPositionByContract(bytes32 position, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) internal view returns (struct LibCoinVending.ContractCondition) *Returns the contract condition associated with the given position, contract address, contract ID, and contract type. position is the identifier of the condition. contractAddress is the address of the contract. contractId is the ID of the contract. contractType is the type of the contract. Returns: The contract condition associated with position , contractAddress , contractId , and contractType .*","title":"LibCoinVending"},{"location":"contracts/libraries/LibCoinVending/#_1","text":"","title":""},{"location":"contracts/libraries/LibCoinVending/#description","text":"This library is used to simulate the vending machine coin acceptor state machine that: - Supports large number of positions; Each represents requirements to acess different goods of the virtual vending machine. - Accepts multiple assets of following types: Native (Eth), ERC20, ERC721, and ERC1155 tokens that can be stacked together. - Allows for each individual asset action promise can be one of following: - Lock: The asset is locked in the acceptor with promise that asset will be returned to the sender at release funds time. - Bet: The asset is locked in the acceptor with promise that asset will be awarded to benificiary at release funds time. - Pay: The asset is locked in the acceptor with promise that asset will be paid to payee at release funds time. - Burn: The asset is locked in the acceptor with promise that asset will be destroyed at release funds time. - Maintains each position balance, hence allowing multiple participants to line up for the same position. - Allows three actions: - Fund position with assets - Refund assets to user - Consume assets and provide goods to user - Consuming asset might take a form of - Transferring assets to payee - Burning assets - Awarding beneficiary with assets - Returning locked assets back to sender This library DOES enforces that any position can only be refunded or processed only within amount funded boundaries This library DOES NOT store the addresses of senders, nor benificiaries, nor payees. This is to be stored within implementation contract. !!!!! IMPORTANT !!!!! This library does NOT invocates reentrancy guards. It is implementation contract's responsibility to enforce reentrancy guards. Reentrancy guards MUST be implemented in an implementing contract. Usage: Configure position via configure(...) fund position with assets via fund(...) release or refund assets via release(...) or refund(...) repeat steps 1 and 2 as needed. Position can be recofigured at any time when it's effective balance is zero: timesFunded - timesRefuned - timesReleased = 0 Test state: This library most functionality has been tested: see ../tests/LibCoinVending.ts and ../tests/report.md for details. ERC721 token is checked only for \"HAVE\" condition since putting requirements on non fungable token id yet to be resolved. (see ERC721 section in the code below) This library has not been yet audited","title":"Description"},{"location":"contracts/libraries/LibCoinVending/#implementation","text":"","title":"Implementation"},{"location":"contracts/libraries/LibCoinVending/#public-struct-condition","text":"struct Condition { mapping(enum LibCoinVending.ContractTypes => mapping(address => mapping(uint256 => struct LibCoinVending.ContractCondition))) contracts; struct LibCoinVending.NumericCondition ethValues; uint256 timesRefunded; uint256 timesReleased; uint256 timesFunded; enum LibCoinVending.ContractTypes[] contractTypes; address[] contractAddresses; uint256[] contractIds; bool _isConfigured; }","title":"public struct Condition"},{"location":"contracts/libraries/LibCoinVending/#enum-requirementtypes","text":"enum RequirementTypes { HAVE, LOCK, BURN, BET, PAY }","title":"enum RequirementTypes"},{"location":"contracts/libraries/LibCoinVending/#public-struct-transactionproperties","text":"struct TransactionProperties { bytes data; uint256 amount; }","title":"public struct TransactionProperties"},{"location":"contracts/libraries/LibCoinVending/#public-struct-contractcondition","text":"struct ContractCondition { struct LibCoinVending.TransactionProperties have; struct LibCoinVending.TransactionProperties lock; struct LibCoinVending.TransactionProperties burn; struct LibCoinVending.TransactionProperties pay; struct LibCoinVending.TransactionProperties bet; }","title":"public struct ContractCondition"},{"location":"contracts/libraries/LibCoinVending/#public-struct-numericcondition","text":"struct NumericCondition { uint256 have; uint256 lock; uint256 burn; uint256 pay; uint256 bet; }","title":"public struct NumericCondition"},{"location":"contracts/libraries/LibCoinVending/#enum-transfertypes","text":"enum TransferTypes { FUND, REFUND, RELEASE }","title":"enum TransferTypes"},{"location":"contracts/libraries/LibCoinVending/#public-struct-conditionreturn","text":"struct ConditionReturn { struct LibCoinVending.NumericCondition ethValues; uint256 timesRefunded; uint256 timesReleased; uint256 timesFunded; address[] contractAddresses; uint256[] contractIds; enum LibCoinVending.ContractTypes[] contractTypes; bool _isConfigured; }","title":"public struct ConditionReturn"},{"location":"contracts/libraries/LibCoinVending/#public-struct-configsmartrequirement","text":"struct configSmartRequirement { address contractAddress; uint256 contractId; enum LibCoinVending.ContractTypes contractType; struct LibCoinVending.ContractCondition contractRequirement; }","title":"public struct configSmartRequirement"},{"location":"contracts/libraries/LibCoinVending/#public-struct-configposition","text":"struct ConfigPosition { struct LibCoinVending.NumericCondition ethValues; struct LibCoinVending.configSmartRequirement[] contracts; }","title":"public struct ConfigPosition"},{"location":"contracts/libraries/LibCoinVending/#public-struct-libcoinvendingstorage","text":"struct LibCoinVendingStorage { mapping(bytes32 => struct LibCoinVending.Condition) positions; address beneficiary; }","title":"public struct LibCoinVendingStorage"},{"location":"contracts/libraries/LibCoinVending/#enum-contracttypes","text":"enum ContractTypes { ERC20, ERC1155, ERC721 }","title":"enum ContractTypes"},{"location":"contracts/libraries/LibCoinVending/#internal-variable-coin_vending_storage_position","text":"bytes32 COIN_VENDING_STORAGE_POSITION","title":"internal variable COIN_VENDING_STORAGE_POSITION"},{"location":"contracts/libraries/LibCoinVending/#internal-function-coinvendingposition","text":"function coinVendingPosition(bytes32 position) internal view returns (struct LibCoinVending.Condition)","title":"internal function coinVendingPosition"},{"location":"contracts/libraries/LibCoinVending/#internal-function-coinvendingstorage","text":"function coinVendingStorage() internal pure returns (struct LibCoinVending.LibCoinVendingStorage es)","title":"internal function coinVendingStorage"},{"location":"contracts/libraries/LibCoinVending/#internal-function-refund","text":"function refund(bytes32 position, address to) internal *Returns all position requirements back to fundee. position is the identifier of the condition. to is the address to refund the balance to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the to address. Increments the timesRefunded counter for the condition.*","title":"internal function refund"},{"location":"contracts/libraries/LibCoinVending/#internal-function-batchrefund","text":"function batchRefund(bytes32 position, address[] returnAddresses) internal *Returns all position requirements back to multiple fundees. position is the identifier of the condition. returnAddresses is an array of addresses to refund the balance to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to each address in returnAddresses . Increments the timesRefunded counter for the condition for each address in returnAddresses .*","title":"internal function batchRefund"},{"location":"contracts/libraries/LibCoinVending/#internal-function-release","text":"function release(bytes32 position, address payee, address beneficiary, address returnAddress) internal *Releases the funds from a coin vending position to the specified addresses. position is the identifier of the condition. payee , beneficiary , and returnAddress are the addresses to release the funds to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the payee , beneficiary , and returnAddress . Increments the timesReleased counter for the condition.*","title":"internal function release"},{"location":"contracts/libraries/LibCoinVending/#internal-function-batchrelease","text":"function batchRelease(bytes32 position, address payee, address beneficiary, address[] returnAddresses) internal *Releases the funds from a coin vending position to multiple return addresses. position is the identifier of the condition. payee , beneficiary , and returnAddresses are the addresses to release the funds to. Requirements: The sum of timesRefunded and timesReleased for the condition must be less than timesFunded . Modifies: Transfers the remaining balance of the condition to the payee , beneficiary , and each address in returnAddresses . Increments the timesReleased counter for the condition for each address in returnAddresses .*","title":"internal function batchRelease"},{"location":"contracts/libraries/LibCoinVending/#internal-function-fund","text":"function fund(bytes32 position) internal *Funds the position by msg.sender . position is the identifier of the condition. Requirements: The condition must be configured. Modifies: Transfers the funds from msg.sender to this contract. Increments the timesFunded counter for the condition.*","title":"internal function fund"},{"location":"contracts/libraries/LibCoinVending/#internal-function-configure","text":"function configure(bytes32 position, struct LibCoinVending.ConfigPosition configuration) internal *Configures the position. position is the identifier of the condition. configuration is the new configuration for the condition. Requirements: The condition must not have a positive balance. Modifies: Sets the configuration of the condition to configuration .*","title":"internal function configure"},{"location":"contracts/libraries/LibCoinVending/#internal-function-getposition","text":"function getPosition(bytes32 position) internal view returns (struct LibCoinVending.ConditionReturn) *Returns the condition associated with the given position. position is the identifier of the condition. Returns: The condition associated with position .*","title":"internal function getPosition"},{"location":"contracts/libraries/LibCoinVending/#internal-function-getpositionbycontract","text":"function getPositionByContract(bytes32 position, address contractAddress, uint256 contractId, enum LibCoinVending.ContractTypes contractType) internal view returns (struct LibCoinVending.ContractCondition) *Returns the contract condition associated with the given position, contract address, contract ID, and contract type. position is the identifier of the condition. contractAddress is the address of the contract. contractId is the ID of the contract. contractType is the type of the contract. Returns: The contract condition associated with position , contractAddress , contractId , and contractType .*","title":"internal function getPositionByContract"},{"location":"contracts/libraries/LibEIP712Storage/","text":"# Description # Implementation # internal variable EIP712_STORAGE_POSITION # bytes32 EIP712_STORAGE_POSITION public struct LibEIP712WithStorageStorage # struct LibEIP712WithStorageStorage { bytes32 _CACHED_DOMAIN_SEPARATOR; uint256 _CACHED_CHAIN_ID; address _CACHED_THIS; bytes32 _HASHED_NAME; bytes32 _HASHED_VERSION; bytes32 _TYPE_HASH; } internal function EIP712WithStorage # function EIP712WithStorage() internal pure returns (struct LibEIP712WithStorage.LibEIP712WithStorageStorage ds)","title":"LibEIP712Storage"},{"location":"contracts/libraries/LibEIP712Storage/#_1","text":"","title":""},{"location":"contracts/libraries/LibEIP712Storage/#description","text":"","title":"Description"},{"location":"contracts/libraries/LibEIP712Storage/#implementation","text":"","title":"Implementation"},{"location":"contracts/libraries/LibEIP712Storage/#internal-variable-eip712_storage_position","text":"bytes32 EIP712_STORAGE_POSITION","title":"internal variable EIP712_STORAGE_POSITION"},{"location":"contracts/libraries/LibEIP712Storage/#public-struct-libeip712withstoragestorage","text":"struct LibEIP712WithStorageStorage { bytes32 _CACHED_DOMAIN_SEPARATOR; uint256 _CACHED_CHAIN_ID; address _CACHED_THIS; bytes32 _HASHED_NAME; bytes32 _HASHED_VERSION; bytes32 _TYPE_HASH; }","title":"public struct LibEIP712WithStorageStorage"},{"location":"contracts/libraries/LibEIP712Storage/#internal-function-eip712withstorage","text":"function EIP712WithStorage() internal pure returns (struct LibEIP712WithStorage.LibEIP712WithStorageStorage ds)","title":"internal function EIP712WithStorage"},{"location":"contracts/libraries/LibMultipass/","text":"# Description # Implementation # public struct NameQuery # Input Type Description resolves user from any given argument Requirements: domainName must be given and must be initialized id OR username OR address must be given This method first tries to resolve by address, then by user id and finally by username struct NameQuery { bytes32 domainName; address wallet; bytes32 name; bytes32 id; bytes32 targetDomain; } public struct Domain # Input Type Description The domain name of the registrar. struct Domain { bytes32 name; uint256 fee; uint256 freeRegistrationsNumber; uint256 referrerReward; uint256 referralDiscount; bool isActive; address registrar; uint24 ttl; uint256 registerSize; } public struct Record # struct Record { address wallet; bytes32 name; bytes32 id; uint96 nonce; bytes32 domainName; } internal variable MULTIPASS_STORAGE_POSITION # bytes32 MULTIPASS_STORAGE_POSITION public struct DomainNameService # Input Type Description The domain name of the registrar. struct DomainNameService { struct LibMultipass.Domain properties; mapping(bytes32 => address) idToAddress; mapping(bytes32 => uint96) nonce; mapping(address => bytes32) addressToId; mapping(bytes32 => bytes32) nameToId; mapping(bytes32 => bytes32) idToName; } public struct MultipassStorageStruct # struct MultipassStorageStruct { mapping(uint256 => struct LibMultipass.DomainNameService) domains; mapping(bytes32 => uint256) domainNameToIndex; uint256 numDomains; } internal function MultipassStorage # function MultipassStorage() internal pure returns (struct LibMultipass.MultipassStorageStruct es) internal variable _TYPEHASH # bytes32 _TYPEHASH internal variable _TYPEHASH_REFERRAL # bytes32 _TYPEHASH_REFERRAL internal function _checkStringFits32b # function _checkStringFits32b(string value) internal pure returns (bool) internal function _checkNotEmpty # function _checkNotEmpty(bytes32 value) internal pure returns (bool) internal function resolveDomainIndex # function resolveDomainIndex(bytes32 domainName) internal view returns (uint256) internal function _getDomainStorage # function _getDomainStorage(bytes32 domainName) internal view returns (struct LibMultipass.DomainNameService) internal function _initializeDomain # function _initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) internal internal function _getModifyPrice # function _getModifyPrice(struct LibMultipass.Record userRecord) internal view returns (uint256) internal function resolveRecord # function resolveRecord(struct LibMultipass.NameQuery query) internal view returns (bool, struct LibMultipass.Record) resolves Record of name query in to status and identity internal function _setRecord # function _setRecord(struct LibMultipass.DomainNameService domain, struct LibMultipass.Record record) internal this function bears no security checks, it will ignore nonce in arg and will increment nonce value stored in domain instread internal function queryFromRecord # function queryFromRecord(struct LibMultipass.Record _record, bytes32 _domainName) internal pure returns (struct LibMultipass.NameQuery) internal function shouldRegisterForFree # function shouldRegisterForFree(struct LibMultipass.DomainNameService domain) internal view returns (bool) internal function _registerNew # function _registerNew(struct LibMultipass.Record newRecord, struct LibMultipass.DomainNameService domain) internal internal function _getContractState # function _getContractState() internal view returns (uint256) internal function _getDomainStorageByIdx # function _getDomainStorageByIdx(uint256 index) internal view returns (struct LibMultipass.DomainNameService)","title":"LibMultipass"},{"location":"contracts/libraries/LibMultipass/#_1","text":"","title":""},{"location":"contracts/libraries/LibMultipass/#description","text":"","title":"Description"},{"location":"contracts/libraries/LibMultipass/#implementation","text":"","title":"Implementation"},{"location":"contracts/libraries/LibMultipass/#public-struct-namequery","text":"Input Type Description resolves user from any given argument Requirements: domainName must be given and must be initialized id OR username OR address must be given This method first tries to resolve by address, then by user id and finally by username struct NameQuery { bytes32 domainName; address wallet; bytes32 name; bytes32 id; bytes32 targetDomain; }","title":"public struct NameQuery"},{"location":"contracts/libraries/LibMultipass/#public-struct-domain","text":"Input Type Description The domain name of the registrar. struct Domain { bytes32 name; uint256 fee; uint256 freeRegistrationsNumber; uint256 referrerReward; uint256 referralDiscount; bool isActive; address registrar; uint24 ttl; uint256 registerSize; }","title":"public struct Domain"},{"location":"contracts/libraries/LibMultipass/#public-struct-record","text":"struct Record { address wallet; bytes32 name; bytes32 id; uint96 nonce; bytes32 domainName; }","title":"public struct Record"},{"location":"contracts/libraries/LibMultipass/#internal-variable-multipass_storage_position","text":"bytes32 MULTIPASS_STORAGE_POSITION","title":"internal variable MULTIPASS_STORAGE_POSITION"},{"location":"contracts/libraries/LibMultipass/#public-struct-domainnameservice","text":"Input Type Description The domain name of the registrar. struct DomainNameService { struct LibMultipass.Domain properties; mapping(bytes32 => address) idToAddress; mapping(bytes32 => uint96) nonce; mapping(address => bytes32) addressToId; mapping(bytes32 => bytes32) nameToId; mapping(bytes32 => bytes32) idToName; }","title":"public struct DomainNameService"},{"location":"contracts/libraries/LibMultipass/#public-struct-multipassstoragestruct","text":"struct MultipassStorageStruct { mapping(uint256 => struct LibMultipass.DomainNameService) domains; mapping(bytes32 => uint256) domainNameToIndex; uint256 numDomains; }","title":"public struct MultipassStorageStruct"},{"location":"contracts/libraries/LibMultipass/#internal-function-multipassstorage","text":"function MultipassStorage() internal pure returns (struct LibMultipass.MultipassStorageStruct es)","title":"internal function MultipassStorage"},{"location":"contracts/libraries/LibMultipass/#internal-variable-_typehash","text":"bytes32 _TYPEHASH","title":"internal variable _TYPEHASH"},{"location":"contracts/libraries/LibMultipass/#internal-variable-_typehash_referral","text":"bytes32 _TYPEHASH_REFERRAL","title":"internal variable _TYPEHASH_REFERRAL"},{"location":"contracts/libraries/LibMultipass/#internal-function-_checkstringfits32b","text":"function _checkStringFits32b(string value) internal pure returns (bool)","title":"internal function _checkStringFits32b"},{"location":"contracts/libraries/LibMultipass/#internal-function-_checknotempty","text":"function _checkNotEmpty(bytes32 value) internal pure returns (bool)","title":"internal function _checkNotEmpty"},{"location":"contracts/libraries/LibMultipass/#internal-function-resolvedomainindex","text":"function resolveDomainIndex(bytes32 domainName) internal view returns (uint256)","title":"internal function resolveDomainIndex"},{"location":"contracts/libraries/LibMultipass/#internal-function-_getdomainstorage","text":"function _getDomainStorage(bytes32 domainName) internal view returns (struct LibMultipass.DomainNameService)","title":"internal function _getDomainStorage"},{"location":"contracts/libraries/LibMultipass/#internal-function-_initializedomain","text":"function _initializeDomain(address registrar, uint256 freeRegistrationsNumber, uint256 fee, bytes32 domainName, uint256 referrerReward, uint256 referralDiscount) internal","title":"internal function _initializeDomain"},{"location":"contracts/libraries/LibMultipass/#internal-function-_getmodifyprice","text":"function _getModifyPrice(struct LibMultipass.Record userRecord) internal view returns (uint256)","title":"internal function _getModifyPrice"},{"location":"contracts/libraries/LibMultipass/#internal-function-resolverecord","text":"function resolveRecord(struct LibMultipass.NameQuery query) internal view returns (bool, struct LibMultipass.Record) resolves Record of name query in to status and identity","title":"internal function resolveRecord"},{"location":"contracts/libraries/LibMultipass/#internal-function-_setrecord","text":"function _setRecord(struct LibMultipass.DomainNameService domain, struct LibMultipass.Record record) internal this function bears no security checks, it will ignore nonce in arg and will increment nonce value stored in domain instread","title":"internal function _setRecord"},{"location":"contracts/libraries/LibMultipass/#internal-function-queryfromrecord","text":"function queryFromRecord(struct LibMultipass.Record _record, bytes32 _domainName) internal pure returns (struct LibMultipass.NameQuery)","title":"internal function queryFromRecord"},{"location":"contracts/libraries/LibMultipass/#internal-function-shouldregisterforfree","text":"function shouldRegisterForFree(struct LibMultipass.DomainNameService domain) internal view returns (bool)","title":"internal function shouldRegisterForFree"},{"location":"contracts/libraries/LibMultipass/#internal-function-_registernew","text":"function _registerNew(struct LibMultipass.Record newRecord, struct LibMultipass.DomainNameService domain) internal","title":"internal function _registerNew"},{"location":"contracts/libraries/LibMultipass/#internal-function-_getcontractstate","text":"function _getContractState() internal view returns (uint256)","title":"internal function _getContractState"},{"location":"contracts/libraries/LibMultipass/#internal-function-_getdomainstoragebyidx","text":"function _getDomainStorageByIdx(uint256 index) internal view returns (struct LibMultipass.DomainNameService)","title":"internal function _getDomainStorageByIdx"},{"location":"contracts/libraries/LibQuadraticVoting/","text":"# error quadraticVotingError # error quadraticVotingError(string paramter, uint256 arg, uint256 arg2) LibQuadraticVoting # Description # A library for quadratic voting calculations. Implementation # public struct qVotingStruct # struct qVotingStruct { uint256 voteCredits; uint256 maxQuadraticPoints; uint256 minQuadraticPositons; } internal function precomputeValues # function precomputeValues(uint256 voteCredits, uint256 minExpectedVoteItems) internal pure returns (struct LibQuadraticVoting.qVotingStruct) *Precomputes the values for quadratic voting. voteCredits is the total number of vote credits. minExpectedVoteItems is the minimum expected number of vote items. Returns: A qVotingStruct containing the precomputed values.* internal function computeScoresByVPIndex # function computeScoresByVPIndex(struct LibQuadraticVoting.qVotingStruct q, uint256[][] VotersVotes, bool[] voterVoted, uint256 notVotedGivesEveyone, uint256 proposalsLength) internal pure returns (uint256[]) *Computes the scores for each proposal by voter preference index. q is the precomputed quadratic voting values. VotersVotes is a 2D array of votes, where each row corresponds to a voter and each column corresponds to a proposal. voterVoted is an array indicating whether each voter has voted. notVotedGivesEveyone is the number of points to distribute to each proposal for each voter that did not vote. proposalsLength is the number of proposals. Returns: An array of scores for each proposal.*","title":"LibQuadraticVoting"},{"location":"contracts/libraries/LibQuadraticVoting/#_1","text":"","title":""},{"location":"contracts/libraries/LibQuadraticVoting/#error-quadraticvotingerror","text":"error quadraticVotingError(string paramter, uint256 arg, uint256 arg2)","title":"error quadraticVotingError"},{"location":"contracts/libraries/LibQuadraticVoting/#libquadraticvoting","text":"","title":"LibQuadraticVoting"},{"location":"contracts/libraries/LibQuadraticVoting/#description","text":"A library for quadratic voting calculations.","title":"Description"},{"location":"contracts/libraries/LibQuadraticVoting/#implementation","text":"","title":"Implementation"},{"location":"contracts/libraries/LibQuadraticVoting/#public-struct-qvotingstruct","text":"struct qVotingStruct { uint256 voteCredits; uint256 maxQuadraticPoints; uint256 minQuadraticPositons; }","title":"public struct qVotingStruct"},{"location":"contracts/libraries/LibQuadraticVoting/#internal-function-precomputevalues","text":"function precomputeValues(uint256 voteCredits, uint256 minExpectedVoteItems) internal pure returns (struct LibQuadraticVoting.qVotingStruct) *Precomputes the values for quadratic voting. voteCredits is the total number of vote credits. minExpectedVoteItems is the minimum expected number of vote items. Returns: A qVotingStruct containing the precomputed values.*","title":"internal function precomputeValues"},{"location":"contracts/libraries/LibQuadraticVoting/#internal-function-computescoresbyvpindex","text":"function computeScoresByVPIndex(struct LibQuadraticVoting.qVotingStruct q, uint256[][] VotersVotes, bool[] voterVoted, uint256 notVotedGivesEveyone, uint256 proposalsLength) internal pure returns (uint256[]) *Computes the scores for each proposal by voter preference index. q is the precomputed quadratic voting values. VotersVotes is a 2D array of votes, where each row corresponds to a voter and each column corresponds to a proposal. voterVoted is an array indicating whether each voter has voted. notVotedGivesEveyone is the number of points to distribute to each proposal for each voter that did not vote. proposalsLength is the number of proposals. Returns: An array of scores for each proposal.*","title":"internal function computeScoresByVPIndex"},{"location":"contracts/libraries/LibRankify/","text":"# Description # Implementation # internal function compareStrings # function compareStrings(string a, string b) internal pure returns (bool) *Compares two strings for equality. a and b are the strings to compare. Returns: true if the strings are equal, false otherwise.* internal function getGameStorage # function getGameStorage(uint256 gameId) internal view returns (struct IRankifyInstanceCommons.RInstance game) *Returns the game storage for the given game ID. gameId is the ID of the game. Returns: The game storage for gameId .* internal function RInstanceStorage # function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog) *Returns the Rankify InstanceSettings storage. Returns: The RInstanceSettings storage.* internal variable _PROPOSAL_PROOF_TYPEHASH # bytes32 _PROPOSAL_PROOF_TYPEHASH internal variable _VOTE_PROOF_TYPEHASH # bytes32 _VOTE_PROOF_TYPEHASH internal variable _VOTE_SUBMIT_PROOF_TYPEHASH # bytes32 _VOTE_SUBMIT_PROOF_TYPEHASH internal function enforceIsInitialized # function enforceIsInitialized() internal view *Ensures that the contract is initialized. Requirements: The contract must be initialized.* internal function enforceGameExists # function enforceGameExists(uint256 gameId) internal view *Ensures that the game with the given ID exists. gameId is the ID of the game. Requirements: The game with gameId must exist.* internal function newGame # function newGame(uint256 gameId, address gameMaster, uint256 gameRank, address creator) internal *Creates a new game with the given parameters. gameId is the ID of the new game. gameMaster is the address of the game master. gameRank is the rank of the game. creator is the address of the creator of the game. Requirements: The game with gameId must not already exist. gameRank must not be 0. If the game price is not 0, the creator must have approved this contract to transfer the game price amount of the game payment token on their behalf. Modifies: Creates a new game with gameId . Transfers the game price amount of the game payment token from creator to this contract. Sets the payments balance of the game to the game price. Sets the creator of the game to creator . Increments the number of games. Sets the rank of the game to gameRank . Mints new rank tokens.* internal function enforceIsGameCreator # function enforceIsGameCreator(uint256 gameId, address candidate) internal view *Ensures that the candidate is the creator of the game with the given ID. gameId is the ID of the game. candidate is the address of the candidate. Requirements: The game with gameId must exist. candidate must be the creator of the game.* internal function enforceIsGM # function enforceIsGM(uint256 gameId, address candidate) internal view *Ensures that the candidate is the game master of the game with the given ID. gameId is the ID of the game. candidate is the address of the candidate. Requirements: The game with gameId must exist. candidate must be the game master of the game.* internal function joinGame # function joinGame(uint256 gameId, address player) internal *Allows a player to join a game. gameId is the ID of the game. player is the address of the player. Requirements: The game with gameId must exist. If the join game price is not 0, the player must have approved this contract to transfer the join game price amount of the game payment token on their behalf. Modifies: Transfers the join game price amount of the game payment token from player to this contract. Increases the payments balance of the game by the join game price. Adds player to the game.* internal function closeGame # function closeGame(uint256 gameId, address beneficiary, function (uint256,address) playersGameEndedCallback) internal returns (uint256[]) *Closes the game with the given ID and transfers the game's balance to the beneficiary. gameId is the ID of the game. beneficiary is the address to transfer the game's balance to. playersGameEndedCallback is a callback function to call for each player when the game ends. Requirements: The game with gameId must exist. Modifies: Emits rank rewards for the game. Removes and unlocks each player from the game. Calls playersGameEndedCallback for each player. Transfers the game's balance to beneficiary . Returns: The final scores of the game.* internal function quitGame # function quitGame(uint256 gameId, address player, bool slash, function (uint256,address) onPlayerLeftCallback) internal *Allows a player to quit a game. gameId is the ID of the game. player is the address of the player. slash is a boolean indicating whether to slash the player's payment refund. onPlayerLeftCallback is a callback function to call when the player leaves. Requirements: The game with gameId must exist. Modifies: If the join game price is not 0, transfers a refund to player and decreases the game's payments balance by the refund amount. Removes and unlocks player from the game. Calls onPlayerLeftCallback for player .* internal function cancelGame # function cancelGame(uint256 gameId, function (uint256,address) onPlayerLeftCallback, address beneficiary) internal *Cancels the game with the given ID, refunds half of the game's payment to the game creator, and transfers the remaining balance to the beneficiary. gameId is the ID of the game. onPlayerLeftCallback is a callback function to call for each player when they leave. beneficiary is the address to transfer the remaining balance to. Requirements: The game with gameId must exist. Modifies: Calls quitGame for each player in the game. Transfers half of the game's payment to the game creator. Decreases the game's payments balance by the refund amount. Transfers the remaining balance of the game to beneficiary . Deletes the game.* internal function fulfillRankRq # function fulfillRankRq(uint256 gameId, address player) internal *Fulfills the rank requirement for a player to join a game. gameId is the ID of the game. player is the address of the player. Modifies: Locks the rank token(s) of player in the rank token contract. If the game has additional ranks, locks the additional ranks of player in the respective rank token contracts.* internal function emitRankRewards # function emitRankRewards(uint256 gameId, address[] leaderboard) internal *Emits rank rewards to the top addresses in the leaderboard for each rank in the game. gameId is the ID of the game. leaderboard is an array of addresses representing the leaderboard. Modifies: Calls emitRankReward for the main rank and each additional rank in the game.* internal function removeAndUnlockPlayer # function removeAndUnlockPlayer(uint256 gameId, address player) internal *Removes a player from a game and unlocks their rank tokens. gameId is the ID of the game. player is the address of the player to be removed. Requirements: The game with gameId must exist. Modifies: Removes player from the game. If the game rank is greater than 1, unlocks the game rank token for player in the rank token contract and unlocks each additional rank token for player in the respective rank token contracts.* internal function tryPlayerMove # function tryPlayerMove(uint256 gameId, address player) internal returns (bool) *Tries to make a move for a player in a game. gameId is the ID of the game. player is the address of the player. The \"move\" is considered to be a state when player has made all actions he could in the given turn. Requirements: The game with gameId must exist. Modifies: If the player has not voted and a vote is expected, or if the player has not made a proposal and a proposal is expected, does not make a move and returns false . Otherwise, makes a move for player and returns true .* internal function calculateScoresQuadratic # function calculateScoresQuadratic(uint256 gameId, uint256[][] votesRevealed, uint256[] proposerIndicies) internal returns (uint256[], uint256[]) *Calculates the scores using a quadratic formula based on the revealed votes and proposer indices. gameId is the ID of the game. votesRevealed is an array of revealed votes. proposerIndicies is an array of proposer indices that links proposals to index in getPlayers(). Returns: An array of updated scores for each player. An array of scores calculated for the current round.*","title":"LibRankify"},{"location":"contracts/libraries/LibRankify/#_1","text":"","title":""},{"location":"contracts/libraries/LibRankify/#description","text":"","title":"Description"},{"location":"contracts/libraries/LibRankify/#implementation","text":"","title":"Implementation"},{"location":"contracts/libraries/LibRankify/#internal-function-comparestrings","text":"function compareStrings(string a, string b) internal pure returns (bool) *Compares two strings for equality. a and b are the strings to compare. Returns: true if the strings are equal, false otherwise.*","title":"internal function compareStrings"},{"location":"contracts/libraries/LibRankify/#internal-function-getgamestorage","text":"function getGameStorage(uint256 gameId) internal view returns (struct IRankifyInstanceCommons.RInstance game) *Returns the game storage for the given game ID. gameId is the ID of the game. Returns: The game storage for gameId .*","title":"internal function getGameStorage"},{"location":"contracts/libraries/LibRankify/#internal-function-rinstancestorage","text":"function RInstanceStorage() internal pure returns (struct IRankifyInstanceCommons.RInstanceSettings bog) *Returns the Rankify InstanceSettings storage. Returns: The RInstanceSettings storage.*","title":"internal function RInstanceStorage"},{"location":"contracts/libraries/LibRankify/#internal-variable-_proposal_proof_typehash","text":"bytes32 _PROPOSAL_PROOF_TYPEHASH","title":"internal variable _PROPOSAL_PROOF_TYPEHASH"},{"location":"contracts/libraries/LibRankify/#internal-variable-_vote_proof_typehash","text":"bytes32 _VOTE_PROOF_TYPEHASH","title":"internal variable _VOTE_PROOF_TYPEHASH"},{"location":"contracts/libraries/LibRankify/#internal-variable-_vote_submit_proof_typehash","text":"bytes32 _VOTE_SUBMIT_PROOF_TYPEHASH","title":"internal variable _VOTE_SUBMIT_PROOF_TYPEHASH"},{"location":"contracts/libraries/LibRankify/#internal-function-enforceisinitialized","text":"function enforceIsInitialized() internal view *Ensures that the contract is initialized. Requirements: The contract must be initialized.*","title":"internal function enforceIsInitialized"},{"location":"contracts/libraries/LibRankify/#internal-function-enforcegameexists","text":"function enforceGameExists(uint256 gameId) internal view *Ensures that the game with the given ID exists. gameId is the ID of the game. Requirements: The game with gameId must exist.*","title":"internal function enforceGameExists"},{"location":"contracts/libraries/LibRankify/#internal-function-newgame","text":"function newGame(uint256 gameId, address gameMaster, uint256 gameRank, address creator) internal *Creates a new game with the given parameters. gameId is the ID of the new game. gameMaster is the address of the game master. gameRank is the rank of the game. creator is the address of the creator of the game. Requirements: The game with gameId must not already exist. gameRank must not be 0. If the game price is not 0, the creator must have approved this contract to transfer the game price amount of the game payment token on their behalf. Modifies: Creates a new game with gameId . Transfers the game price amount of the game payment token from creator to this contract. Sets the payments balance of the game to the game price. Sets the creator of the game to creator . Increments the number of games. Sets the rank of the game to gameRank . Mints new rank tokens.*","title":"internal function newGame"},{"location":"contracts/libraries/LibRankify/#internal-function-enforceisgamecreator","text":"function enforceIsGameCreator(uint256 gameId, address candidate) internal view *Ensures that the candidate is the creator of the game with the given ID. gameId is the ID of the game. candidate is the address of the candidate. Requirements: The game with gameId must exist. candidate must be the creator of the game.*","title":"internal function enforceIsGameCreator"},{"location":"contracts/libraries/LibRankify/#internal-function-enforceisgm","text":"function enforceIsGM(uint256 gameId, address candidate) internal view *Ensures that the candidate is the game master of the game with the given ID. gameId is the ID of the game. candidate is the address of the candidate. Requirements: The game with gameId must exist. candidate must be the game master of the game.*","title":"internal function enforceIsGM"},{"location":"contracts/libraries/LibRankify/#internal-function-joingame","text":"function joinGame(uint256 gameId, address player) internal *Allows a player to join a game. gameId is the ID of the game. player is the address of the player. Requirements: The game with gameId must exist. If the join game price is not 0, the player must have approved this contract to transfer the join game price amount of the game payment token on their behalf. Modifies: Transfers the join game price amount of the game payment token from player to this contract. Increases the payments balance of the game by the join game price. Adds player to the game.*","title":"internal function joinGame"},{"location":"contracts/libraries/LibRankify/#internal-function-closegame","text":"function closeGame(uint256 gameId, address beneficiary, function (uint256,address) playersGameEndedCallback) internal returns (uint256[]) *Closes the game with the given ID and transfers the game's balance to the beneficiary. gameId is the ID of the game. beneficiary is the address to transfer the game's balance to. playersGameEndedCallback is a callback function to call for each player when the game ends. Requirements: The game with gameId must exist. Modifies: Emits rank rewards for the game. Removes and unlocks each player from the game. Calls playersGameEndedCallback for each player. Transfers the game's balance to beneficiary . Returns: The final scores of the game.*","title":"internal function closeGame"},{"location":"contracts/libraries/LibRankify/#internal-function-quitgame","text":"function quitGame(uint256 gameId, address player, bool slash, function (uint256,address) onPlayerLeftCallback) internal *Allows a player to quit a game. gameId is the ID of the game. player is the address of the player. slash is a boolean indicating whether to slash the player's payment refund. onPlayerLeftCallback is a callback function to call when the player leaves. Requirements: The game with gameId must exist. Modifies: If the join game price is not 0, transfers a refund to player and decreases the game's payments balance by the refund amount. Removes and unlocks player from the game. Calls onPlayerLeftCallback for player .*","title":"internal function quitGame"},{"location":"contracts/libraries/LibRankify/#internal-function-cancelgame","text":"function cancelGame(uint256 gameId, function (uint256,address) onPlayerLeftCallback, address beneficiary) internal *Cancels the game with the given ID, refunds half of the game's payment to the game creator, and transfers the remaining balance to the beneficiary. gameId is the ID of the game. onPlayerLeftCallback is a callback function to call for each player when they leave. beneficiary is the address to transfer the remaining balance to. Requirements: The game with gameId must exist. Modifies: Calls quitGame for each player in the game. Transfers half of the game's payment to the game creator. Decreases the game's payments balance by the refund amount. Transfers the remaining balance of the game to beneficiary . Deletes the game.*","title":"internal function cancelGame"},{"location":"contracts/libraries/LibRankify/#internal-function-fulfillrankrq","text":"function fulfillRankRq(uint256 gameId, address player) internal *Fulfills the rank requirement for a player to join a game. gameId is the ID of the game. player is the address of the player. Modifies: Locks the rank token(s) of player in the rank token contract. If the game has additional ranks, locks the additional ranks of player in the respective rank token contracts.*","title":"internal function fulfillRankRq"},{"location":"contracts/libraries/LibRankify/#internal-function-emitrankrewards","text":"function emitRankRewards(uint256 gameId, address[] leaderboard) internal *Emits rank rewards to the top addresses in the leaderboard for each rank in the game. gameId is the ID of the game. leaderboard is an array of addresses representing the leaderboard. Modifies: Calls emitRankReward for the main rank and each additional rank in the game.*","title":"internal function emitRankRewards"},{"location":"contracts/libraries/LibRankify/#internal-function-removeandunlockplayer","text":"function removeAndUnlockPlayer(uint256 gameId, address player) internal *Removes a player from a game and unlocks their rank tokens. gameId is the ID of the game. player is the address of the player to be removed. Requirements: The game with gameId must exist. Modifies: Removes player from the game. If the game rank is greater than 1, unlocks the game rank token for player in the rank token contract and unlocks each additional rank token for player in the respective rank token contracts.*","title":"internal function removeAndUnlockPlayer"},{"location":"contracts/libraries/LibRankify/#internal-function-tryplayermove","text":"function tryPlayerMove(uint256 gameId, address player) internal returns (bool) *Tries to make a move for a player in a game. gameId is the ID of the game. player is the address of the player. The \"move\" is considered to be a state when player has made all actions he could in the given turn. Requirements: The game with gameId must exist. Modifies: If the player has not voted and a vote is expected, or if the player has not made a proposal and a proposal is expected, does not make a move and returns false . Otherwise, makes a move for player and returns true .*","title":"internal function tryPlayerMove"},{"location":"contracts/libraries/LibRankify/#internal-function-calculatescoresquadratic","text":"function calculateScoresQuadratic(uint256 gameId, uint256[][] votesRevealed, uint256[] proposerIndicies) internal returns (uint256[], uint256[]) *Calculates the scores using a quadratic formula based on the revealed votes and proposer indices. gameId is the ID of the game. votesRevealed is an array of revealed votes. proposerIndicies is an array of proposer indices that links proposals to index in getPlayers(). Returns: An array of updated scores for each player. An array of scores calculated for the current round.*","title":"internal function calculateScoresQuadratic"},{"location":"contracts/libraries/LibReentrancyGuard/","text":"# Description # Implementation # internal variable TBG_STORAGE_POSITION # bytes32 TBG_STORAGE_POSITION public struct ReentrancyGuardStruct # struct ReentrancyGuardStruct { bool _entered; } internal function reentrancyGuardStorage # function reentrancyGuardStorage() internal pure returns (struct LibReentrancyGuard.ReentrancyGuardStruct ds)","title":"LibReentrancyGuard"},{"location":"contracts/libraries/LibReentrancyGuard/#_1","text":"","title":""},{"location":"contracts/libraries/LibReentrancyGuard/#description","text":"","title":"Description"},{"location":"contracts/libraries/LibReentrancyGuard/#implementation","text":"","title":"Implementation"},{"location":"contracts/libraries/LibReentrancyGuard/#internal-variable-tbg_storage_position","text":"bytes32 TBG_STORAGE_POSITION","title":"internal variable TBG_STORAGE_POSITION"},{"location":"contracts/libraries/LibReentrancyGuard/#public-struct-reentrancyguardstruct","text":"struct ReentrancyGuardStruct { bool _entered; }","title":"public struct ReentrancyGuardStruct"},{"location":"contracts/libraries/LibReentrancyGuard/#internal-function-reentrancyguardstorage","text":"function reentrancyGuardStorage() internal pure returns (struct LibReentrancyGuard.ReentrancyGuardStruct ds)","title":"internal function reentrancyGuardStorage"},{"location":"contracts/libraries/LibTurnBasedGame/","text":"LibTBG # Description # Library for managing turn-based games. It is designed to be used as a base library for games, and provides the following functionality: - setting game settings such as time per turn, max players, min players, etc as well as perform score and leaderboard tracking Limitations: - It is assumed there is only one game per player - It is assumed there is only on game master per game WARNING Some limitations: - This library is still under development and its interfaces may change. - getting game data (which has own storage assigement and can be encapsulated from library) however there is no storage slot collision checks in place Implementation # public struct GameSettings # struct GameSettings { uint256 timePerTurn; uint256 maxPlayersSize; uint256 minPlayersSize; uint256 timeToJoin; uint256 maxTurns; uint256 numWinners; uint256 voteCredits; string subject; } public struct GameInstance # struct GameInstance { address gameMaster; uint256 currentTurn; uint256 turnStartedAt; uint256 registrationOpenAt; bool hasStarted; bool hasEnded; struct EnumerableSet.AddressSet players; mapping(address => bool) madeMove; uint256 numPlayersMadeMove; mapping(address => uint256) score; bytes32 implemenationStoragePointer; bool isOvertime; address[] leaderboard; } public struct TBGStorageStruct # struct TBGStorageStruct { struct LibTBG.GameSettings settings; mapping(uint256 => struct LibTBG.GameInstance) games; mapping(address => uint256) playerInGame; uint256 totalGamesCreated; } internal variable TBG_STORAGE_POSITION # bytes32 TBG_STORAGE_POSITION internal variable IMPLEMENTATION_STORAGE_POSITION # bytes32 IMPLEMENTATION_STORAGE_POSITION internal function TBGStorage # function TBGStorage() internal pure returns (struct LibTBG.TBGStorageStruct es) internal function _getGame # function _getGame(uint256 gameId) internal view returns (struct LibTBG.GameInstance) internal function init # function init(struct LibTBG.GameSettings settings) internal *Initializes the game with the provided settings. settings is the settings for the game. Requirements: settings.timePerTurn must not be zero. settings.maxPlayersSize must not be zero. settings.minPlayersSize must be at least 2. settings.maxTurns must not be zero. settings.numWinners must not be zero and must be less than settings.minPlayersSize . settings.timeToJoin must not be zero. settings.maxPlayersSize must not be less than settings.minPlayersSize . settings.subject must not be an empty string. Modifies: Sets the settings of the game to settings .* internal function createGame # function createGame(uint256 gameId, address gm) internal *Creates a new game with the provided game ID and game master. gameId is the ID of the game. gm is the address of the game master. Requirements: The game with gameId must not already exist. gm must not be the zero address. gameId must not be zero. The game master of the game with gameId must be the zero address. Modifies: Sets the game master of the game with gameId to gm . Increments the total number of games created.* internal function deleteGame # function deleteGame(uint256 gameId) internal *Deletes a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. Modifies: Sets the game master, current turn, hasEnded, hasStarted, implementationStoragePointer, isOvertime, leaderboard, numPlayersMadeMove, players, registrationOpenAt, and turnStartedAt of the game with gameId to their initial values. Sets the score and madeMove of each player in the game with gameId to their initial values.* internal function canBeJoined # function canBeJoined(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID can be joined. gameId is the ID of the game. Returns: A boolean indicating whether the game can be joined.* internal function addPlayer # function addPlayer(uint256 gameId, address participant) internal *Adds a player to a game with the provided game ID. gameId is the ID of the game. participant is the address of the player. Requirements: The game with gameId must exist. participant must not already be in a game. The number of players in the game with gameId must be less than the maximum number of players. The game with gameId must be joinable. Modifies: Adds participant to the players of the game with gameId . Sets the madeMove of participant in the game with gameId to false. Sets the game of participant to gameId .* internal function isPlayerInGame # function isPlayerInGame(uint256 gameId, address player) internal view returns (bool) *Checks if a player is in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Returns: A boolean indicating whether the player is in the game.* internal function removePlayer # function removePlayer(uint256 gameId, address participant) internal *Removes a player from a game with the provided game ID. gameId is the ID of the game. participant is the address of the player. Requirements: The game with gameId must exist. participant must be in the game with gameId . The game with gameId must not have started or must have ended. Modifies: Sets the game of participant to 0. Removes participant from the players of the game with gameId .* internal function isTurnTimedOut # function isTurnTimedOut(uint256 gameId) internal view returns (bool) *Checks if the current turn in a game with the provided game ID has timed out. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started. Returns: A boolean indicating whether the current turn has timed out.* internal function gameExists # function gameExists(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID exists. gameId is the ID of the game. Returns: A boolean indicating whether the game exists.* internal function enforceHasStarted # function enforceHasStarted(uint256 gameId) internal view *Enforces that a game with the provided game ID has started. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started.* internal function canEndTurn # function canEndTurn(uint256 gameId) internal view returns (bool) *Enforces that a game with the provided game ID has started. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started.* internal function canEndTurnEarly # function canEndTurnEarly(uint256 gameId) internal view returns (bool) *Checks if the current turn in a game with the provided game ID can end early. gameId is the ID of the game. Returns: A boolean indicating whether the current turn can end early.* internal modifier onlyInTurnTime # modifier onlyInTurnTime(uint256 gameId) *Modifier that requires the current turn in a game with the provided game ID to be able to end. gameId is the ID of the game. Requirements: The current turn in the game with gameId must be able to end.* internal modifier onlyWhenTurnCanEnd # modifier onlyWhenTurnCanEnd(uint256 gameId) internal function _clearCurrentMoves # function _clearCurrentMoves(struct LibTBG.GameInstance game) internal *Clears the current moves in a game. game is the game. Modifies: Sets the madeMove of each player in game to false.* internal function _resetPlayerStates # function _resetPlayerStates(struct LibTBG.GameInstance game) internal *Resets the states of the players in a game. game is the game. Modifies: Sets the madeMove and score of each player in game to their initial values.* internal function setScore # function setScore(uint256 gameId, address player, uint256 value) internal *Sets the score of a player in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. value is the score. Requirements: player must be in the game with gameId . Modifies: Sets the score of player in the game with gameId to value .* internal function getScore # function getScore(uint256 gameId, address player) internal view returns (uint256) *Gets the score of a player in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Returns: The score of player in the game with gameId .* internal function getScores # function getScores(uint256 gameId) internal view returns (address[], uint256[]) *Gets the scores of the players in a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId . An array of the scores of the players in the game with gameId .* internal function openRegistration # function openRegistration(uint256 gameId) internal *Opens registration for a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. Modifies: Sets the registrationOpenAt of the game with gameId to the current block timestamp.* internal function isRegistrationOpen # function isRegistrationOpen(uint256 gameId) internal view returns (bool) *Checks if registration is open for a game with the provided game ID. gameId is the ID of the game. Returns: A boolean indicating whether registration is open for the game.* internal function canStart # function canStart(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID can start. gameId is the ID of the game. Returns: A boolean indicating whether the game can start.* internal function canStartEarly # function canStartEarly(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID can start early. gameId is the ID of the game. By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached. Returns: A boolean indicating whether the game can start early.* internal function startGameEarly # function startGameEarly(uint256 gameId) internal *Starts a game with the provided game ID early. gameId is the ID of the game. By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached. Requirements: The game with gameId must exist. The game with gameId must not have started. The game with gameId must have opened registration. The number of players in the game with gameId must be greater than or equal to the minimum number of players. The number of players in the game with gameId must be equal to the maximum number of players or the current block timestamp must be greater than the registration open time plus the time to join. Modifies: Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with gameId to their new values. Resets the states of the players in the game with gameId .* internal function startGame # function startGame(uint256 gameId) internal *Starts a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. The game with gameId must not have started. The game with gameId must have opened registration. The current block timestamp must be greater than the registration open time plus the time to join. Modifies: Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with gameId to their new values. Resets the states of the players in the game with gameId .* internal function getTurn # function getTurn(uint256 gameId) internal view returns (uint256) *Gets the current turn of a game with the provided game ID. gameId is the ID of the game. Returns: The current turn of the game with gameId .* internal function getGM # function getGM(uint256 gameId) internal view returns (address) *Gets the game master of a game with the provided game ID. gameId is the ID of the game. Returns: The game master of the game with gameId .* internal function isLastTurn # function isLastTurn(uint256 gameId) internal view returns (bool) *Checks if the current turn is the last turn in a game with the provided game ID. gameId is the ID of the game. Returns: A boolean indicating whether the current turn is the last turn in the game.* internal function isGameOver # function isGameOver(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID is over. gameId is the ID of the game. Returns: A boolean indicating whether the game is over.* internal function enforceIsNotOver # function enforceIsNotOver(uint256 gameId) internal view *Enforces that a game with the provided game ID is not over. gameId is the ID of the game. Requirements: The game with gameId must not be over.* internal function playerMove # function playerMove(uint256 gameId, address player) internal *Records a player's move in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Requirements: The game with gameId must have started. The game with gameId must not be over. player must not have made a move in the current turn of the game with gameId . player must be in the game with gameId . Modifies: Sets the madeMove of player in the game with gameId to true. Increments the numPlayersMadeMove of the game with gameId .* internal function isPlayerTurnComplete # function isPlayerTurnComplete(uint256 gameId, address player) internal view returns (bool) internal function enforceIsPlayingGame # function enforceIsPlayingGame(uint256 gameId, address player) internal view *Enforces that a player is in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Requirements: player must be in the game with gameId .* internal function hasStarted # function hasStarted(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID has started. gameId is the ID of the game. Returns: A boolean indicating whether the game has started.* internal function getLeaderBoard # function getLeaderBoard(uint256 gameId) internal view returns (address[]) *Gets the leaderboard of a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId , sorted by score.* internal function nextTurn # function nextTurn(uint256 gameId) internal returns (bool, bool, bool) *Advances to the next turn in a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must be able to end the current turn early. (all players have moved or the turn has timed out) Modifies: Clears the current moves in the game with gameId . Increments the currentTurn of the game with gameId . Sets the turnStartedAt of the game with gameId to the current block timestamp. If the current turn is the last turn or the game with gameId is in overtime, checks if the game is a tie and sets the isOvertime of the game with gameId to the result. Sets the hasEnded of the game with gameId to whether the game is over. Returns: A boolean indicating whether the current turn is the last turn. A boolean indicating whether the game is a tie. A boolean indicating whether the game is over.* internal function getDataStorage # function getDataStorage() internal pure returns (bytes32 pointer) *Gets the data storage pointer. Returns: The data storage pointer.* internal function getGameDataStorage # function getGameDataStorage(uint256 gameId) internal view returns (bytes32 pointer) *Gets the game data storage pointer of a game with the provided game ID. gameId is the ID of the game. Returns: The game data storage pointer of the game with gameId .* internal function getPlayersNumber # function getPlayersNumber(uint256 gameId) internal view returns (uint256) *Gets the number of players in a game with the provided game ID. gameId is the ID of the game. Returns: The number of players in the game with gameId .* internal function getPlayers # function getPlayers(uint256 gameId) internal view returns (address[]) *Gets the players in a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId .* internal function getGameSettings # function getGameSettings() internal view returns (struct LibTBG.GameSettings) *Gets the game settings. Returns: The game settings.* internal function enforceIsPreRegistrationStage # function enforceIsPreRegistrationStage(uint256 gameId) internal view *Enforces that a game with the provided game ID is in the pre-registration stage. gameId is the ID of the game. Requirements: Registration must not be open for the game with gameId . The game with gameId must not have started.* internal function addOvertime # function addOvertime(uint256 gameId) internal *Adds overtime to a game with the provided game ID. gameId is the ID of the game. Modifies: Sets the isOvertime of the game with gameId to true.* internal function isOvertime # function isOvertime(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID is in overtime. gameId is the ID of the game. Returns: A boolean indicating whether the game is in overtime.* internal function resetOvertime # function resetOvertime(uint256 gameId) internal *Resets the overtime of a game with the provided game ID. gameId is the ID of the game. Modifies: Sets the isOvertime of the game with gameId to false.* internal function isTie # function isTie(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID is a tie. gameId is the ID of the game. Tie being defined as at least two of the top numWinners players having the same score. Returns: A boolean indicating whether the game is a tie.* internal function getPlayersGame # function getPlayersGame(address player) internal view returns (uint256) *Gets the game ID of the game a player is in. player is the address of the player. Returns: The game ID of the game player is in.* internal function sortByScore # function sortByScore(uint256 gameId) internal view returns (address[], uint256[]) *Sorts the players in a game with the provided game ID by score in descending order. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId , sorted by score. An array of the scores of the players in the game with gameId , sorted in descending order.*","title":"LibTBG"},{"location":"contracts/libraries/LibTurnBasedGame/#libtbg","text":"","title":"LibTBG"},{"location":"contracts/libraries/LibTurnBasedGame/#description","text":"Library for managing turn-based games. It is designed to be used as a base library for games, and provides the following functionality: - setting game settings such as time per turn, max players, min players, etc as well as perform score and leaderboard tracking Limitations: - It is assumed there is only one game per player - It is assumed there is only on game master per game WARNING Some limitations: - This library is still under development and its interfaces may change. - getting game data (which has own storage assigement and can be encapsulated from library) however there is no storage slot collision checks in place","title":"Description"},{"location":"contracts/libraries/LibTurnBasedGame/#implementation","text":"","title":"Implementation"},{"location":"contracts/libraries/LibTurnBasedGame/#public-struct-gamesettings","text":"struct GameSettings { uint256 timePerTurn; uint256 maxPlayersSize; uint256 minPlayersSize; uint256 timeToJoin; uint256 maxTurns; uint256 numWinners; uint256 voteCredits; string subject; }","title":"public struct GameSettings"},{"location":"contracts/libraries/LibTurnBasedGame/#public-struct-gameinstance","text":"struct GameInstance { address gameMaster; uint256 currentTurn; uint256 turnStartedAt; uint256 registrationOpenAt; bool hasStarted; bool hasEnded; struct EnumerableSet.AddressSet players; mapping(address => bool) madeMove; uint256 numPlayersMadeMove; mapping(address => uint256) score; bytes32 implemenationStoragePointer; bool isOvertime; address[] leaderboard; }","title":"public struct GameInstance"},{"location":"contracts/libraries/LibTurnBasedGame/#public-struct-tbgstoragestruct","text":"struct TBGStorageStruct { struct LibTBG.GameSettings settings; mapping(uint256 => struct LibTBG.GameInstance) games; mapping(address => uint256) playerInGame; uint256 totalGamesCreated; }","title":"public struct TBGStorageStruct"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-variable-tbg_storage_position","text":"bytes32 TBG_STORAGE_POSITION","title":"internal variable TBG_STORAGE_POSITION"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-variable-implementation_storage_position","text":"bytes32 IMPLEMENTATION_STORAGE_POSITION","title":"internal variable IMPLEMENTATION_STORAGE_POSITION"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-tbgstorage","text":"function TBGStorage() internal pure returns (struct LibTBG.TBGStorageStruct es)","title":"internal function TBGStorage"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-_getgame","text":"function _getGame(uint256 gameId) internal view returns (struct LibTBG.GameInstance)","title":"internal function _getGame"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-init","text":"function init(struct LibTBG.GameSettings settings) internal *Initializes the game with the provided settings. settings is the settings for the game. Requirements: settings.timePerTurn must not be zero. settings.maxPlayersSize must not be zero. settings.minPlayersSize must be at least 2. settings.maxTurns must not be zero. settings.numWinners must not be zero and must be less than settings.minPlayersSize . settings.timeToJoin must not be zero. settings.maxPlayersSize must not be less than settings.minPlayersSize . settings.subject must not be an empty string. Modifies: Sets the settings of the game to settings .*","title":"internal function init"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-creategame","text":"function createGame(uint256 gameId, address gm) internal *Creates a new game with the provided game ID and game master. gameId is the ID of the game. gm is the address of the game master. Requirements: The game with gameId must not already exist. gm must not be the zero address. gameId must not be zero. The game master of the game with gameId must be the zero address. Modifies: Sets the game master of the game with gameId to gm . Increments the total number of games created.*","title":"internal function createGame"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-deletegame","text":"function deleteGame(uint256 gameId) internal *Deletes a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. Modifies: Sets the game master, current turn, hasEnded, hasStarted, implementationStoragePointer, isOvertime, leaderboard, numPlayersMadeMove, players, registrationOpenAt, and turnStartedAt of the game with gameId to their initial values. Sets the score and madeMove of each player in the game with gameId to their initial values.*","title":"internal function deleteGame"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-canbejoined","text":"function canBeJoined(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID can be joined. gameId is the ID of the game. Returns: A boolean indicating whether the game can be joined.*","title":"internal function canBeJoined"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-addplayer","text":"function addPlayer(uint256 gameId, address participant) internal *Adds a player to a game with the provided game ID. gameId is the ID of the game. participant is the address of the player. Requirements: The game with gameId must exist. participant must not already be in a game. The number of players in the game with gameId must be less than the maximum number of players. The game with gameId must be joinable. Modifies: Adds participant to the players of the game with gameId . Sets the madeMove of participant in the game with gameId to false. Sets the game of participant to gameId .*","title":"internal function addPlayer"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-isplayeringame","text":"function isPlayerInGame(uint256 gameId, address player) internal view returns (bool) *Checks if a player is in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Returns: A boolean indicating whether the player is in the game.*","title":"internal function isPlayerInGame"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-removeplayer","text":"function removePlayer(uint256 gameId, address participant) internal *Removes a player from a game with the provided game ID. gameId is the ID of the game. participant is the address of the player. Requirements: The game with gameId must exist. participant must be in the game with gameId . The game with gameId must not have started or must have ended. Modifies: Sets the game of participant to 0. Removes participant from the players of the game with gameId .*","title":"internal function removePlayer"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-isturntimedout","text":"function isTurnTimedOut(uint256 gameId) internal view returns (bool) *Checks if the current turn in a game with the provided game ID has timed out. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started. Returns: A boolean indicating whether the current turn has timed out.*","title":"internal function isTurnTimedOut"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-gameexists","text":"function gameExists(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID exists. gameId is the ID of the game. Returns: A boolean indicating whether the game exists.*","title":"internal function gameExists"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-enforcehasstarted","text":"function enforceHasStarted(uint256 gameId) internal view *Enforces that a game with the provided game ID has started. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started.*","title":"internal function enforceHasStarted"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-canendturn","text":"function canEndTurn(uint256 gameId) internal view returns (bool) *Enforces that a game with the provided game ID has started. gameId is the ID of the game. Requirements: gameId must not be zero. The game with gameId must have started.*","title":"internal function canEndTurn"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-canendturnearly","text":"function canEndTurnEarly(uint256 gameId) internal view returns (bool) *Checks if the current turn in a game with the provided game ID can end early. gameId is the ID of the game. Returns: A boolean indicating whether the current turn can end early.*","title":"internal function canEndTurnEarly"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-modifier-onlyinturntime","text":"modifier onlyInTurnTime(uint256 gameId) *Modifier that requires the current turn in a game with the provided game ID to be able to end. gameId is the ID of the game. Requirements: The current turn in the game with gameId must be able to end.*","title":"internal modifier onlyInTurnTime"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-modifier-onlywhenturncanend","text":"modifier onlyWhenTurnCanEnd(uint256 gameId)","title":"internal modifier onlyWhenTurnCanEnd"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-_clearcurrentmoves","text":"function _clearCurrentMoves(struct LibTBG.GameInstance game) internal *Clears the current moves in a game. game is the game. Modifies: Sets the madeMove of each player in game to false.*","title":"internal function _clearCurrentMoves"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-_resetplayerstates","text":"function _resetPlayerStates(struct LibTBG.GameInstance game) internal *Resets the states of the players in a game. game is the game. Modifies: Sets the madeMove and score of each player in game to their initial values.*","title":"internal function _resetPlayerStates"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-setscore","text":"function setScore(uint256 gameId, address player, uint256 value) internal *Sets the score of a player in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. value is the score. Requirements: player must be in the game with gameId . Modifies: Sets the score of player in the game with gameId to value .*","title":"internal function setScore"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getscore","text":"function getScore(uint256 gameId, address player) internal view returns (uint256) *Gets the score of a player in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Returns: The score of player in the game with gameId .*","title":"internal function getScore"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getscores","text":"function getScores(uint256 gameId) internal view returns (address[], uint256[]) *Gets the scores of the players in a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId . An array of the scores of the players in the game with gameId .*","title":"internal function getScores"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-openregistration","text":"function openRegistration(uint256 gameId) internal *Opens registration for a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. Modifies: Sets the registrationOpenAt of the game with gameId to the current block timestamp.*","title":"internal function openRegistration"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-isregistrationopen","text":"function isRegistrationOpen(uint256 gameId) internal view returns (bool) *Checks if registration is open for a game with the provided game ID. gameId is the ID of the game. Returns: A boolean indicating whether registration is open for the game.*","title":"internal function isRegistrationOpen"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-canstart","text":"function canStart(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID can start. gameId is the ID of the game. Returns: A boolean indicating whether the game can start.*","title":"internal function canStart"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-canstartearly","text":"function canStartEarly(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID can start early. gameId is the ID of the game. By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached. Returns: A boolean indicating whether the game can start early.*","title":"internal function canStartEarly"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-startgameearly","text":"function startGameEarly(uint256 gameId) internal *Starts a game with the provided game ID early. gameId is the ID of the game. By \"early\" it is assumed that time to join has not yet passed, but it's already cap players limit reached. Requirements: The game with gameId must exist. The game with gameId must not have started. The game with gameId must have opened registration. The number of players in the game with gameId must be greater than or equal to the minimum number of players. The number of players in the game with gameId must be equal to the maximum number of players or the current block timestamp must be greater than the registration open time plus the time to join. Modifies: Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with gameId to their new values. Resets the states of the players in the game with gameId .*","title":"internal function startGameEarly"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-startgame","text":"function startGame(uint256 gameId) internal *Starts a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must exist. The game with gameId must not have started. The game with gameId must have opened registration. The current block timestamp must be greater than the registration open time plus the time to join. Modifies: Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with gameId to their new values. Resets the states of the players in the game with gameId .*","title":"internal function startGame"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getturn","text":"function getTurn(uint256 gameId) internal view returns (uint256) *Gets the current turn of a game with the provided game ID. gameId is the ID of the game. Returns: The current turn of the game with gameId .*","title":"internal function getTurn"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getgm","text":"function getGM(uint256 gameId) internal view returns (address) *Gets the game master of a game with the provided game ID. gameId is the ID of the game. Returns: The game master of the game with gameId .*","title":"internal function getGM"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-islastturn","text":"function isLastTurn(uint256 gameId) internal view returns (bool) *Checks if the current turn is the last turn in a game with the provided game ID. gameId is the ID of the game. Returns: A boolean indicating whether the current turn is the last turn in the game.*","title":"internal function isLastTurn"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-isgameover","text":"function isGameOver(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID is over. gameId is the ID of the game. Returns: A boolean indicating whether the game is over.*","title":"internal function isGameOver"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-enforceisnotover","text":"function enforceIsNotOver(uint256 gameId) internal view *Enforces that a game with the provided game ID is not over. gameId is the ID of the game. Requirements: The game with gameId must not be over.*","title":"internal function enforceIsNotOver"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-playermove","text":"function playerMove(uint256 gameId, address player) internal *Records a player's move in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Requirements: The game with gameId must have started. The game with gameId must not be over. player must not have made a move in the current turn of the game with gameId . player must be in the game with gameId . Modifies: Sets the madeMove of player in the game with gameId to true. Increments the numPlayersMadeMove of the game with gameId .*","title":"internal function playerMove"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-isplayerturncomplete","text":"function isPlayerTurnComplete(uint256 gameId, address player) internal view returns (bool)","title":"internal function isPlayerTurnComplete"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-enforceisplayinggame","text":"function enforceIsPlayingGame(uint256 gameId, address player) internal view *Enforces that a player is in a game with the provided game ID. gameId is the ID of the game. player is the address of the player. Requirements: player must be in the game with gameId .*","title":"internal function enforceIsPlayingGame"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-hasstarted","text":"function hasStarted(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID has started. gameId is the ID of the game. Returns: A boolean indicating whether the game has started.*","title":"internal function hasStarted"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getleaderboard","text":"function getLeaderBoard(uint256 gameId) internal view returns (address[]) *Gets the leaderboard of a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId , sorted by score.*","title":"internal function getLeaderBoard"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-nextturn","text":"function nextTurn(uint256 gameId) internal returns (bool, bool, bool) *Advances to the next turn in a game with the provided game ID. gameId is the ID of the game. Requirements: The game with gameId must be able to end the current turn early. (all players have moved or the turn has timed out) Modifies: Clears the current moves in the game with gameId . Increments the currentTurn of the game with gameId . Sets the turnStartedAt of the game with gameId to the current block timestamp. If the current turn is the last turn or the game with gameId is in overtime, checks if the game is a tie and sets the isOvertime of the game with gameId to the result. Sets the hasEnded of the game with gameId to whether the game is over. Returns: A boolean indicating whether the current turn is the last turn. A boolean indicating whether the game is a tie. A boolean indicating whether the game is over.*","title":"internal function nextTurn"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getdatastorage","text":"function getDataStorage() internal pure returns (bytes32 pointer) *Gets the data storage pointer. Returns: The data storage pointer.*","title":"internal function getDataStorage"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getgamedatastorage","text":"function getGameDataStorage(uint256 gameId) internal view returns (bytes32 pointer) *Gets the game data storage pointer of a game with the provided game ID. gameId is the ID of the game. Returns: The game data storage pointer of the game with gameId .*","title":"internal function getGameDataStorage"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getplayersnumber","text":"function getPlayersNumber(uint256 gameId) internal view returns (uint256) *Gets the number of players in a game with the provided game ID. gameId is the ID of the game. Returns: The number of players in the game with gameId .*","title":"internal function getPlayersNumber"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getplayers","text":"function getPlayers(uint256 gameId) internal view returns (address[]) *Gets the players in a game with the provided game ID. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId .*","title":"internal function getPlayers"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getgamesettings","text":"function getGameSettings() internal view returns (struct LibTBG.GameSettings) *Gets the game settings. Returns: The game settings.*","title":"internal function getGameSettings"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-enforceispreregistrationstage","text":"function enforceIsPreRegistrationStage(uint256 gameId) internal view *Enforces that a game with the provided game ID is in the pre-registration stage. gameId is the ID of the game. Requirements: Registration must not be open for the game with gameId . The game with gameId must not have started.*","title":"internal function enforceIsPreRegistrationStage"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-addovertime","text":"function addOvertime(uint256 gameId) internal *Adds overtime to a game with the provided game ID. gameId is the ID of the game. Modifies: Sets the isOvertime of the game with gameId to true.*","title":"internal function addOvertime"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-isovertime","text":"function isOvertime(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID is in overtime. gameId is the ID of the game. Returns: A boolean indicating whether the game is in overtime.*","title":"internal function isOvertime"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-resetovertime","text":"function resetOvertime(uint256 gameId) internal *Resets the overtime of a game with the provided game ID. gameId is the ID of the game. Modifies: Sets the isOvertime of the game with gameId to false.*","title":"internal function resetOvertime"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-istie","text":"function isTie(uint256 gameId) internal view returns (bool) *Checks if a game with the provided game ID is a tie. gameId is the ID of the game. Tie being defined as at least two of the top numWinners players having the same score. Returns: A boolean indicating whether the game is a tie.*","title":"internal function isTie"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-getplayersgame","text":"function getPlayersGame(address player) internal view returns (uint256) *Gets the game ID of the game a player is in. player is the address of the player. Returns: The game ID of the game player is in.*","title":"internal function getPlayersGame"},{"location":"contracts/libraries/LibTurnBasedGame/#internal-function-sortbyscore","text":"function sortByScore(uint256 gameId) internal view returns (address[], uint256[]) *Sorts the players in a game with the provided game ID by score in descending order. gameId is the ID of the game. Returns: An array of the addresses of the players in the game with gameId , sorted by score. An array of the scores of the players in the game with gameId , sorted in descending order.*","title":"internal function sortByScore"},{"location":"contracts/tokens/RankToken/","text":"# Description # Implementation # public variable rank # mapping(address => uint256) rank public variable topRank # uint256 topRank internal variable _levelUpThreshold # uint256 _levelUpThreshold internal modifier onlyRankingInstance # modifier onlyRankingInstance() public function constructor # constructor(string uri_, address owner_, string cURI, uint256 levelUpThreshold, address[] components, uint256[] componentWeights) public public function getRankingInstance # function getRankingInstance() public view returns (address) *Gets the ranking instance which can emit new rank updates and mint rank tokens. Returns: The address of the ranking instance.* public function contractURI # function contractURI() public view returns (string) public function setURI # function setURI(string uri_) public public function setContractURI # function setContractURI(string uri_) public event Leader # event Leader(address account, uint256 rank) public function mint # function mint(address to, uint256 amount, uint256 level, bytes data) public public function updateRankingInstance # function updateRankingInstance(address newRankingInstance) public *Updates the ranking instance. newRankingInstance is the address of the new ranking instance. emits a RankingInstanceUpdated event.* public function lock # function lock(address account, uint256 id, uint256 amount) public public function unlock # function unlock(address account, uint256 id, uint256 amount) public public function batchMint # function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) public Mints specified amounts of tokens to an account. to is the address of the account to mint the tokens to. ids is the array of IDs of the tokens to mint. amounts is the array of amounts of tokens to mint. data is the additional data. public function levelUp # function levelUp(address to, uint256 level, bytes data) public public function findNewRank # function findNewRank(address account, uint256 oldRank) public view returns (uint256) *Finds the new rank of an account. account is the address of the account. oldRank is the old rank of the account. It checks the balance of the account and returns the new rank that can be upgraded to. Returns: The new rank of the account.* event RankUpdated # event RankUpdated(address account, uint256 rank) internal function _afterTokenTransfer # function _afterTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal *Hook that is called after any token transfer. This includes minting and burning, as well as batched variants. The same hook is called on both single and batched variants. For single transfers, the length of the id and amount arrays will be 1. Calling conditions (for each id and amount pair): When from and to are both non-zero, amount of from 's tokens of token type id will be transferred to to . When from is zero, amount tokens of token type id will be minted for to . when to is zero, amount of from 's tokens of token type id will be burned. from and to are never both zero. ids and amounts have the same, non-zero length. To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].* external function getAccountRank # function getAccountRank(address account) external view returns (uint256) *Gets the rank of an account. account is the address of the account. Returns: The rank of the account.* public function supportsInterface # function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)","title":"RankToken"},{"location":"contracts/tokens/RankToken/#_1","text":"","title":""},{"location":"contracts/tokens/RankToken/#description","text":"","title":"Description"},{"location":"contracts/tokens/RankToken/#implementation","text":"","title":"Implementation"},{"location":"contracts/tokens/RankToken/#public-variable-rank","text":"mapping(address => uint256) rank","title":"public variable rank"},{"location":"contracts/tokens/RankToken/#public-variable-toprank","text":"uint256 topRank","title":"public variable topRank"},{"location":"contracts/tokens/RankToken/#internal-variable-_levelupthreshold","text":"uint256 _levelUpThreshold","title":"internal variable _levelUpThreshold"},{"location":"contracts/tokens/RankToken/#internal-modifier-onlyrankinginstance","text":"modifier onlyRankingInstance()","title":"internal modifier onlyRankingInstance"},{"location":"contracts/tokens/RankToken/#public-function-constructor","text":"constructor(string uri_, address owner_, string cURI, uint256 levelUpThreshold, address[] components, uint256[] componentWeights) public","title":"public function constructor"},{"location":"contracts/tokens/RankToken/#public-function-getrankinginstance","text":"function getRankingInstance() public view returns (address) *Gets the ranking instance which can emit new rank updates and mint rank tokens. Returns: The address of the ranking instance.*","title":"public function getRankingInstance"},{"location":"contracts/tokens/RankToken/#public-function-contracturi","text":"function contractURI() public view returns (string)","title":"public function contractURI"},{"location":"contracts/tokens/RankToken/#public-function-seturi","text":"function setURI(string uri_) public","title":"public function setURI"},{"location":"contracts/tokens/RankToken/#public-function-setcontracturi","text":"function setContractURI(string uri_) public","title":"public function setContractURI"},{"location":"contracts/tokens/RankToken/#event-leader","text":"event Leader(address account, uint256 rank)","title":"event Leader"},{"location":"contracts/tokens/RankToken/#public-function-mint","text":"function mint(address to, uint256 amount, uint256 level, bytes data) public","title":"public function mint"},{"location":"contracts/tokens/RankToken/#public-function-updaterankinginstance","text":"function updateRankingInstance(address newRankingInstance) public *Updates the ranking instance. newRankingInstance is the address of the new ranking instance. emits a RankingInstanceUpdated event.*","title":"public function updateRankingInstance"},{"location":"contracts/tokens/RankToken/#public-function-lock","text":"function lock(address account, uint256 id, uint256 amount) public","title":"public function lock"},{"location":"contracts/tokens/RankToken/#public-function-unlock","text":"function unlock(address account, uint256 id, uint256 amount) public","title":"public function unlock"},{"location":"contracts/tokens/RankToken/#public-function-batchmint","text":"function batchMint(address to, uint256[] ids, uint256[] amounts, bytes data) public Mints specified amounts of tokens to an account. to is the address of the account to mint the tokens to. ids is the array of IDs of the tokens to mint. amounts is the array of amounts of tokens to mint. data is the additional data.","title":"public function batchMint"},{"location":"contracts/tokens/RankToken/#public-function-levelup","text":"function levelUp(address to, uint256 level, bytes data) public","title":"public function levelUp"},{"location":"contracts/tokens/RankToken/#public-function-findnewrank","text":"function findNewRank(address account, uint256 oldRank) public view returns (uint256) *Finds the new rank of an account. account is the address of the account. oldRank is the old rank of the account. It checks the balance of the account and returns the new rank that can be upgraded to. Returns: The new rank of the account.*","title":"public function findNewRank"},{"location":"contracts/tokens/RankToken/#event-rankupdated","text":"event RankUpdated(address account, uint256 rank)","title":"event RankUpdated"},{"location":"contracts/tokens/RankToken/#internal-function-_aftertokentransfer","text":"function _afterTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal *Hook that is called after any token transfer. This includes minting and burning, as well as batched variants. The same hook is called on both single and batched variants. For single transfers, the length of the id and amount arrays will be 1. Calling conditions (for each id and amount pair): When from and to are both non-zero, amount of from 's tokens of token type id will be transferred to to . When from is zero, amount tokens of token type id will be minted for to . when to is zero, amount of from 's tokens of token type id will be burned. from and to are never both zero. ids and amounts have the same, non-zero length. To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].*","title":"internal function _afterTokenTransfer"},{"location":"contracts/tokens/RankToken/#external-function-getaccountrank","text":"function getAccountRank(address account) external view returns (uint256) *Gets the rank of an account. account is the address of the account. Returns: The rank of the account.*","title":"external function getAccountRank"},{"location":"contracts/tokens/RankToken/#public-function-supportsinterface","text":"function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)","title":"public function supportsInterface"},{"location":"contracts/tokens/Rankify/","text":"# Description # Implementation # internal variable numTokens # uint256 numTokens public function constructor # constructor(address owner) public public function mint # function mint(address to, uint256 amount) public","title":"Rankify"},{"location":"contracts/tokens/Rankify/#_1","text":"","title":""},{"location":"contracts/tokens/Rankify/#description","text":"","title":"Description"},{"location":"contracts/tokens/Rankify/#implementation","text":"","title":"Implementation"},{"location":"contracts/tokens/Rankify/#internal-variable-numtokens","text":"uint256 numTokens","title":"internal variable numTokens"},{"location":"contracts/tokens/Rankify/#public-function-constructor","text":"constructor(address owner) public","title":"public function constructor"},{"location":"contracts/tokens/Rankify/#public-function-mint","text":"function mint(address to, uint256 amount) public","title":"public function mint"},{"location":"interfaces/js/","text":"JavaScript SDK #","title":"JavaScript SDK"},{"location":"interfaces/js/#javascript-sdk","text":"","title":"JavaScript SDK"},{"location":"support/","text":"Community channels # Discord Telegram Twitter","title":"Community channels"},{"location":"support/#community-channels","text":"Discord Telegram Twitter","title":"Community channels"},{"location":"support/faq/","text":"Frequently asked questions #","title":"Frequently asked questions"},{"location":"support/faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"}]}